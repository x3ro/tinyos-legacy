<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.3.9: http://docutils.sourceforge.net/" />
<title>Permanent Data Storage (Flash)</title>
<meta name="author" content="David Gay, Jonathan Hui" />
<style type="text/css">

/*
:Author: David Goodger
:Contact: goodger@users.sourceforge.net
:date: $Date: 2005/09/20 16:30:23 $
:version: $Revision: 1.6 $
:copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.
*/
body {
  font-family: Times;
  font-size: 16px;
}

.first {
  margin-top: 0 ! important }

.last {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dd {
  margin-bottom: 0.5em }

/* Uncomment (& remove this text!) to get bold-faced definition list terms
dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.attention, div.caution, div.danger, div.error, div.hint,
div.important, div.note, div.tip, div.warning, div.admonition {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

div.hint p.admonition-title, div.important p.admonition-title,
div.note p.admonition-title, div.tip p.admonition-title,
div.admonition p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em }

div.footer, div.header {
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin-left: 1em ;
  border: medium outset ;
  padding: 0em 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1 {
  font-family: Arial, sans-serif;
  font-size: 20px;
}

h1.title {
 text-align: center;
 font-size: 32px;
}

h2 {
 font-size: 16px;
 font-family: Arial, sans-serif;
}

h2.subtitle {
  text-align: center }

h3 {
 font-size: 12px;
 font-family: Arial, sans-serif;
}

hr {
  width: 75% }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font-family: serif ;
  font-size: 100% }

pre.line-block {
  font-family: serif ;
  font-size: 100% }

pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.option-argument {
  font-style: italic }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

table {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.citation {
  border-left: solid thin gray ;
  padding-left: 0.5ex }

table.docinfo {
  margin: 2em 4em;
}

table.footnote {
  border-left: solid thin black ;
  padding-left: 0.5ex }

td, th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

th.docinfo-name, th.field-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap;
  }

h1 tt, h2 tt, h3 tt, h4 tt, h5 tt, h6 tt {
  font-size: 100% }

tt {
  background-color: #eeeeee }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="permanent-data-storage-flash">
<h1 class="title">Permanent Data Storage (Flash)</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr class="field"><th class="docinfo-name">TEP:</th><td class="field-body">103</td>
</tr>
<tr class="field"><th class="docinfo-name">Group:</th><td class="field-body">Core Working Group</td>
</tr>
<tr class="field"><th class="docinfo-name">Type:</th><td class="field-body">Documentary</td>
</tr>
<tr><th class="docinfo-name">Status:</th>
<td>Draft</td></tr>
<tr class="field"><th class="docinfo-name">TinyOS-Version:</th><td class="field-body">2.0</td>
</tr>
<tr><th class="docinfo-name">Author:</th>
<td>David Gay, Jonathan Hui</td></tr>
<tr class="field"><th class="docinfo-name">Draft-Created:</th><td class="field-body">27-Sep-2004</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Version:</th><td class="field-body">1.5</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Modified:</th><td class="field-body">2005-02-14</td>
</tr>
<tr class="field"><th class="docinfo-name">Draft-Discuss:</th><td class="field-body">TinyOS Developer List &lt;tinyos-devel at mail.millennium.berkeley.edu&gt;</td>
</tr>
</tbody>
</table>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">This memo documents a part of TinyOS for the TinyOS Community, and
requests discussion and suggestions for improvements.  Distribution
of this memo is unlimited. This memo is in full compliance with
TEP 1.</p>
</div>
<div class="section" id="abstract">
<h1><a name="abstract">Abstract</a></h1>
<p>This TEP covers permanent storage abstractions for TinyOS 2.0, and the
HPL and HAL layers for various flash chips.</p>
</div>
<div class="section" id="introduction">
<h1><a name="introduction">1. Introduction</a></h1>
<div class="section" id="hardware-differences-between-the-current-platforms">
<h2><a name="hardware-differences-between-the-current-platforms">Hardware differences between the current platforms</a></h2>
<p>There are three different flash chip families under use or consideration
for TinyOS platforms: the Atmel AT45DB family (Mica family, Telos rev. A),
the ST M25P family (Telos rev. B, eyes) and the Intel Strataflash (imote2).
All three are &quot;NOR&quot; flash chips, but the AT45DB has fairly different
characteristics (see below). There also &quot;NAND&quot; flash chips which have
rather different tradeoffs from NOR flash. Compact flash/etc cards use
NAND flash but present a disk-like block interface.</p>
<p>A common restriction of flash technology is that each bit can only be
written once between erases. The table below summarizes the differences
between the various flash technologies:</p>
<pre class="literal-block">
                NOR                  AT45DB          NAND

Erase        :  Slow (seconds)       Fast (ms)       Fast (ms)
Erase unit   :  Large (64KB-128KB)   Small (256B)    Medium (8K-32KB)
Writes       :  Slow (100s kB/s)     Slow (60kB/s)   Fast (MBs/s)
Write unit   :  1 bit                256B            100's of bytes
Bit-errors   :  Low                  Low             High (requires ECC, 
                                                     bad-block mapping)
Read         :  Fast*                Slow+I/O bus    Fast (but limited by 
                                                     I/O bus)
Erase cycles :  10^4 - 10^5          10^4 **         10^5 - 10^7
Intended use :  Code storage         Data storage    Data storage

*  imote2 NOR flash is memory mapped (reads are very fast and can
   directly execute code)
** Or infinite? Data sheet just says that every page within a sector
   must be written every 10^4 writes within that sector
</pre>
<p>From the power consumption for erasing and writing, we can derive an
energy cost/byte written (for NAND flash, taken from a Samsung datasheet):</p>
<blockquote>
Energy/byte:    1uJ                  1uJ             .01uJ</blockquote>
<p>Energy/byte for reads appears to depend mostly on how long the read takes
(the power consumptions are comparable), i.e., on the efficiency of the bus
+ processor...</p>
</div>
</div>
<div class="section" id="architecture">
<h1><a name="architecture">2. Architecture</a></h1>
<p>The proposed architecture aligns with the three-layer Hardware
Abstraction Architecture (HAA).</p>
<div class="section" id="hpl-hal-hil-structure">
<h2><a name="hpl-hal-hil-structure">HPL/HAL/HIL Structure</a></h2>
<p>The very significant differences between the flash chips used in TinyOS
preclude common, low-level HIL interfaces such as a disk-like block
interface. Instead, we propose that the HIL interfaces correspond to 
high-level storage services useful for sensor network applications. We
have identified three storage abstractions:</p>
<blockquote>
<ol class="loweralpha">
<li><p class="first">Large objects  (Deluge, Large Data Transfer):</p>
<blockquote>
<p>This scenario involves getting a large (100's bytes to kilobytes or
more) free chunk (through alloc or erase), writing to each
byte/block once in any arbitrary order, and &quot;committing&quot; when the
chunk is filled.</p>
</blockquote>
<p>Size: large
Reads: random
Writes: random (minimum block size?), each block written once
Failure model: no fault tolerance (crash before commit leads to
object loss)
Other: a commit operation terminates writes, a validate operation
checks the object.</p>
</li>
<li><p class="first">Small objects (Deluge metadata, many other apps):</p>
<blockquote>
<p>This scenario involves keeping a small chunk (less than 100
some bytes). Requires multiple and random reads/writes.</p>
</blockquote>
<p>Size: small
Reads: random
Writes: random, no minimum block size, rewrite ok
Failure model: writes are atomic, failure during/between writes
does not lead to object loss</p>
</li>
<li><p class="first">Large sequential objects (Logs)</p>
<blockquote>
<p>Some applications (e.g., low-rate data collection, SNMS events) may
want to log all their results in a reliable fashion, possibly
in a circular buffer.</p>
</blockquote>
<p>Size: large
Reads: from memorized write points or beginning
Writes: sequential, object is linear or circular
Failure model: writes are atomic, failure during/between writes
does not lead to whole object loss, but may lead to loss of
some entries (but see sync)
Note: failure during write may lead to (minor) capacity reduction
Other: sync: guarantees already written data will not be lost to
(crash-style) failure</p>
</li>
</ol>
</blockquote>
<p>These interfaces will be offered on top of a uniform method of sharing
the flash. Volumes are allocated in a similar way to fdisk. Volumes
will be allocated and a partition table kept in non-volatile
storage. To use a volume, it must be mounted. Thus, volumes exist
independent of which components the applications are compiled
with. This allows switching of applications while managing the sharing
of flash.</p>
<p>We envision separate implementations of these abstractions for each class
of storage chip; these implementations will be found in the new 
tos/chips/CHIPNAME hierarchy.</p>
</div>
<div class="section" id="hardware-presentation-layer-hpl">
<h2><a name="hardware-presentation-layer-hpl">Hardware Presentation Layer (HPL)</a></h2>
<blockquote>
<ol class="loweralpha">
<li><p class="first">Implementation: system dependent</p>
</li>
<li><p class="first">Presentation: chip (family?) dependent (common HPL for same chip
(family?) on different systems)</p>
</li>
<li><p class="first">Stateless</p>
</li>
<li><p class="first">Atmel 45DB family low-level interfaces</p>
<blockquote>
<p>select, send/receive SPI byte, idle detection
(no commands, as efficiency dictates their integration in the HAL)
See tos/platform/mica/HPLFlashM</p>
</blockquote>
</li>
<li><p class="first">Intel Strataflash</p>
<blockquote>
<p>write data, erase, lock/unlock blocks, read config data, etc. 
details omitted - main interesting point is lack of reads, as device
is memory mapped</p>
</blockquote>
</li>
<li><p class="first">M25P family</p>
<blockquote>
<p>r/w data, erase (sector or chip), r/w status, etc
(full details omitted)</p>
</blockquote>
</li>
</ol>
</blockquote>
</div>
<div class="section" id="hardware-adaptation-layer-hal">
<h2><a name="hardware-adaptation-layer-hal">Hardware Adaptation Layer (HAL)</a></h2>
<blockquote>
<ol class="loweralpha">
<li><p class="first">Implementation: chip dependent</p>
</li>
<li><p class="first">Presentation: chip dependent</p>
</li>
<li><p class="first">Atmel 45DB:
i. read, write, erase pages
ii. compute page crc
iii. automatic buffer management (+ sync, flush)
iv. see tos/platform/mica/PageEEPROM|PageEEPROMM.nc</p>
</li>
<li><p class="first">Intel Strataflash (should extend to other memory-mapped NOR flashes):</p>
<pre class="literal-block">
interface HALStrata { /* In flux until higher level stuff written */
  command result_t lockRange(uint32_t from, uint32_t count);
  command result_t unlockRange(uint32_t from, uint32_t count);

  /* These return to read array mode when done */
  command result_t write(uint32_t address, uint16_t *data, uint8_t count);
  event   void     writeDone(result_t success);

  command result_t erase(uint32_t block);
  event   void     eraseDone(result_t success);

  /* Will probably want to read some amount of device info. Not clear what
     yet, exactly. */
 }
</pre>
</li>
<li><p class="first">M25P:</p>
<pre class="literal-block">
interface {
  command result_t read(addr_t addr, void* dest, addr_t len);
  event   result_t readDone(result_t result);

  command result_t write(addr_t addr, void* source, addr_t len);
  event   result_t writeDone(result_t result);

  command result_t erase(sector_t sector);
  event   result_t eraseDone(result_t result);

  command result_t bulkErase();
  event   result_t bulkEraseDone();
}
</pre>
</li>
</ol>
</blockquote>
</div>
<div class="section" id="hardware-interface-layer-hil">
<h2><a name="hardware-interface-layer-hil">Hardware Interface Layer (HIL)</a></h2>
<blockquote>
<ol class="loweralpha">
<li><p class="first">Implementation: Chip dependent</p>
</li>
<li><p class="first">Presentation: application-level OS service (see discussion above)</p>
</li>
<li><p class="first">Space allocation</p>
<p>This is similar to fdisk. Allocation of volumes can only occur
between calls to init() and commit(). init() wipes the volume
table clean and commit() writes out the volume table:</p>
<pre class="literal-block">
interface FStorage {
  command result_t init();
  command result_t allocate(uint8_t id, addr_t size);
  command result_t allocateFixed(uint8_t id, addr_t addr, addr_t size);
  command result_t commit();
  event   void     commitDone(storage_result_t result, uint8_t id);
}
</pre>
<p>The mount interface is used to setup access to a specific
volume:</p>
<pre class="literal-block">
interface Mount {
  command result_t mount(uint8_t id);
  event   void     mountDone(storage_result_t result, uint8_t id);
}
</pre>
<p>This interface is provided by the components implementing
BlockRead/Write, ConfigStorage, and LogRead/Write. This
interface is necessary for components to setup any required
metadata. For example, ConfigRead may need to know where to
read a specific configuration. LogWrite may need to search for
the current offset:</p>
<pre class="literal-block">
interface VolumeInit {
  command result_t init();
  event   void     initDone(storage_result_t result);
}
</pre>
</li>
<li><p class="first">Large object:</p>
<pre class="literal-block">
interface BlockWrite {
  // compile-time block storage size constant available,
  // varies by platform. Len must be a multiple of this.
  command result_t write(addr_t addr, void* source, addr_t len);
  event   void     writeDone(storage_result_t result);

  command result_t erase();
  event   void     eraseDone(storage_result_t result);

  command result_t commit();
  event   void     commitDone(storage_result_t result);
}

interface BlockRead {
  command result_t read(addr_t addr, void* dest, addr_t len);
  event   void     readDone(storage_result_t result);

  command result_t verify();
  event   void     verifyDone(storage_result_t result);
}
</pre>
</li>
<li><p class="first">Small object:</p>
<pre class="literal-block">
interface ConfigStorage {
  command result_t read(addr_t addr, void* dest, addr_t len);
  event   void     readDone(storage_result_t result);

  command result_t write(addr_t addr void* source, addr_t len);
  event   void     writeDone(storage_result_t result);

  command result_t commit();
  event   void     commitDone(storage_result_t result);
}
</pre>
</li>
<li><p class="first">Large sequential object:</p>
<pre class="literal-block">
interface LogWrite {
  command result_t erase();
  event   void     eraseDone(storage_result_t success);

  command result_t append(uint8_t* data, uint32_t numBytes);
  event   void     appendDone(uint8_t* data, uint32_t numBytes, result_t success);
  command uint32_t currentOffset();

  command result_t sync();
  event   void     syncDone(storage_result_t success);
}

interface LogRead {
  command result_t read(uint8_t* data, uint32_t numBytes);
  event   void     readDone(uint8_t* data, uint32_t numBytes, result_t success);

  command result_t seek(uint32_t cookie);
  event   void     seekDone(storage_result_t success);
}
</pre>
</li>
</ol>
<blockquote>
The circular-vs-linear distinction is made by offering separate
instances of the LogData, LogRead interfaces.</blockquote>
</blockquote>
</div>
</div>
<div class="section" id="implementation">
<h1><a name="implementation">3. Implementation</a></h1>
<p>An STM25P implementation can be found in tinyos-1.x/beta/STM25P.</p>
</div>
<div class="section" id="author-s-address">
<h1><a name="author-s-address">4. Author's Address</a></h1>
<div class="line-block">
<div class="line">David Gay &lt;dgay at acm.org&gt;,</div>
<div class="line">Jonathan Hui  &lt;jwhui at cs.berkeley.edu&gt;</div>
</div>
</div>
</div>
</body>
</html>

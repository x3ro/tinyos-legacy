
module AsyncAlarmM
{
	provides
	{
		interface AsyncAlarm<uint32_t> as Alarm[uint8_t timer];
		interface StdControl;
	}
	uses
	{
		interface LocalTime;
		interface HPLTimer<uint16_t> as HPLTimer;
		interface Debug;
	}

}
implementation
{
	#define DBG_LEVEL 1
	#include "Debug.h"
	
	#define NUM_CHANNELS 5
	enum {
		NUM_TIMERS = uniqueCount("AsyncAlarm"),
	};
	
	typedef struct {
		bool isset;
		uint16_t highStamp;
		uint16_t lowStamp;
	} Timer_t;

	Timer_t m_timers[NUM_TIMERS];

	uint8_t maxChannel = NUM_CHANNELS;
	
	uint8_t channelMap[NUM_CHANNELS];
	bool channelFree[NUM_CHANNELS];

	inline result_t armTimer(uint16_t highStamp, uint16_t lowStamp, uint8_t timer);
	inline void armHwTimer(Timer_t *tt, uint8_t timer);

	command result_t StdControl.init()
	{
		uint8_t i;
		for (i=0;i<NUM_TIMERS;i++) {
			m_timers[i].isset = FALSE;
		}
		for (i=0;i<maxChannel;i++) {
			atomic channelFree[i] = TRUE;
		}
		// Channel 3 reserved for short delays.
		atomic channelFree[3] = FALSE;
		atomic channelFree[4] = FALSE;
		return SUCCESS;
	}

	command result_t StdControl.start()
	{
		call HPLTimer.arm(0x7FFF, 4);
		return SUCCESS;
	}

	command result_t StdControl.stop()
	{
		return SUCCESS;
	}


	command result_t Alarm.armCountdown[uint8_t timer](uint32_t timeout)
	{
		if (timeout < 16) {
			channelMap[3] = timer;
			return call HPLTimer.shortDelay(timeout>>1,3);
		} else {
			uint32_t alarm = timeout+call LocalTime.getTime();
			// getTime is 16 micro second time instead of 32 micro second
			// time generated by hardware.
			alarm >>= 1;
			return armTimer(alarm>>16, alarm&0xFFFF, timer);
		}
	}
	
	command result_t Alarm.armAlarmClock[uint8_t timer](uint32_t time)
	{
		time >>= 1;
		return armTimer(time>>16, time&0xFFFF, timer);
	}

	inline result_t armTimer(uint16_t highStamp, uint16_t lowStamp, uint8_t timer)
	{
		result_t res = FAIL;
		atomic {
		uint32_t myTime = call LocalTime.getTime() >> 1;
		uint16_t nowHigh = myTime>>16;
		uint16_t nowLow = myTime&0xFFFF;
		if ((highStamp == nowHigh+1 && (lowStamp > nowLow)) || highStamp > nowHigh+1) {
			m_timers[timer].isset = TRUE;
			m_timers[timer].highStamp = highStamp;
			m_timers[timer].lowStamp = lowStamp;
			res = SUCCESS;
		} else {
			// Program hw timer immediately.
			uint8_t channel;
			m_timers[timer].isset = FALSE;
			for (channel=0; channel < maxChannel; channel++) {
				if (channelFree[channel]) {
					channelFree[channel] = FALSE;
					channelMap[channel] = timer;
					call HPLTimer.arm(lowStamp, channel);
					res = SUCCESS;
					break;
				}
			}
		}
		}
		return res;
	}

	command result_t Alarm.stop[uint8_t timer]()
	{
		uint8_t i;
		if (m_timers[timer].isset) {
			m_timers[timer].isset = FALSE;
			return SUCCESS;
		}
		for (i=0;i<maxChannel;i++) {
			if (channelMap[i] == timer) {
				// Timer is programmed, stop hw timer.
				call HPLTimer.stop(i);
				channelFree[i] = TRUE;
				return SUCCESS;	
			}
		}
		return FAIL;
	}
	
	async event void HPLTimer.wrapped()
	{
		atomic {
		// Decrement highstamps on all timers and enable hw timer if 0
		uint8_t timer;
		uint16_t nowHigh = call LocalTime.getHigh16();
		for (timer=0;timer<NUM_TIMERS;timer++) {
			Timer_t* tt = m_timers+timer;
			if (tt->isset) {
				if (tt->highStamp == nowHigh && tt->lowStamp > 0x7FFF) {
					armHwTimer(tt, timer);
				}
			}
		}
		}
	}
	
	async event void HPLTimer.fired(uint8_t channel)
	{
		atomic {
		if (channel == 4) {
			// We use channel 4 for signalling programming periods
			uint8_t timer;
			uint16_t nowHigh = call LocalTime.getHigh16()+1;
			for (timer=0;timer<NUM_TIMERS;timer++) {
				Timer_t* tt = m_timers+timer;
				if (tt->isset) {
					if (tt->highStamp == nowHigh && tt->lowStamp <= 0x7FFF) {
						armHwTimer(tt, timer);
					}
				}
			}
		} else {
			// Signal the right alarm.
			uint8_t timer = channelMap[channel];
			call HPLTimer.stop(channel);
			// Do not free special purpose channel 3.
			if (channel != 3) channelFree[channel] = TRUE;
			signal Alarm.alarm[timer]();
		}
		}
	}

	inline void armHwTimer(Timer_t *tt, uint8_t timer)
	{
		uint8_t channel;
		tt->isset = FALSE;
		for (channel=0; channel<maxChannel; channel++) {
			if (channelFree[channel]) {
				channelFree[channel] = FALSE;
				channelMap[channel] = timer;
				call HPLTimer.arm(tt->lowStamp, channel);
				break;
			}
		}
		if (channel >= maxChannel) {
			DBG_STR("FATAL: AsyncAlarm, No free HW timers left.",1);
		}
	}

	default async event result_t Alarm.alarm[uint8_t timer]()
	{
		DBG_STR("WARNING: AsyncTimer, Timer fired but not connected:",1);
		DBG_INT(timer,1);
		return SUCCESS;
	}

}

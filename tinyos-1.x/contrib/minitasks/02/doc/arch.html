<style>
<!--
.title {
  font-family:sans-serif;
  font-size:160%;
  font-weight:bold;
}
.heading1 {
  font-family:sans-serif;
  font-size:140%;
  font-weight:bold;
  margin-top:.25in;
}
.heading2 {
  font-family:sans-serif;
  font-size:125%;
  font-weight:bold;
  font-style:italic;
  margin-top:.25in;
}
.heading3 {
  font-family:sans-serif;
  font-size:110%;
  font-weight:bold;
  margin-top:.25in;
}
.heading4 {
  font-family:sans-serif;
  font-weight:bold;
  font-style:italic;
  margin-top:.25in;
}
.nesc_self {
  font-family:sans-serif;
  font-weight:bold;
  font-size:110%;
}
.code {
  border:1px solid black;
  padding:4px;
  background:#e8e8e8;
  margin-left:2em;
  margin-right:2em;
  font-family:monospace;
  font-size:10pt;
  white-space:pre;
}
.codefrag {
  font-family:monospace;
}
.subsection {
  margin-left:2em;
}
-->
</style>



<div class="title">NEST Challenge Architecture
</div>

<p> Document version: $Revision: 1.3 $ $Date: 2002/12/06 23:24:08 $ 
</p>




<div class="heading1">1. Introduction</div><div class="subsection">

<div class="heading2">1.1. Chapter Descriptions</div><div class="subsection">

<div class="heading3">Introduction</div><div class="subsection">
<p> Chapter Descriptions. Roles of Berkeley, Middleware Groups, and Document.
</p>
</div>

<div class="heading3">Demo Description</div><div class="subsection">
<p> Detailed description of the demo scenario, including what entities are
present and how they behave.  Also define high-level architecture decisions
such as global/local coordinate systems, global/local time, etc. 
</p>
</div>

<div class="heading3">Architecture Methodologies</div><div class="subsection">
<p> Informal, linguistic description of the philosophies used to construct each
component 
</p>
</div>

<div class="heading3">Estimation</div><div class="subsection">
<p>
</p>
</div>

<div class="heading3">Grouping</div><div class="subsection">
<p>
</p>
</div>

<div class="heading3">Localization</div><div class="subsection">
<p>
</p>
</div>

<div class="heading3">Power Management</div><div class="subsection">
<p>
</p>
</div>

<div class="heading3">Routing</div><div class="subsection">
<p>
</p>
</div>

<div class="heading3">Service Coordination</div><div class="subsection">
<p>
</p>
</div>

<div class="heading3">Time Synchronization</div><div class="subsection">
<p>
</p>
</div>

</div>

<div class="heading2">1.2. Group and Document Roles</div><div class="subsection">

<p> Berkeley's role 
</p>

<ul>
<li> Manage this NEST Challenge Architecture Document 
</li>
<li> Set revision dates 
</li>
<li> Provide the initial abstract architecture and concrete implementations 
</li>
<li> Review and integrate changes proposed by other groups 
</li>
<li> Web site 
</li>
<li> Mailing list 
</li>
<li> SourceForge facilities / repository 
</li>
<li> Provide the demo kits as well as the final demo test bed 
</li>
</ul>

<p> Middleware groups' role 
</p>

<ul>
<li> Work within the framework of the provided architecture 
</li>
<li> Conform to changes in revisions of the architecture 
</li>
<li> Suggest changes to the architecture 
</li>
<li> Use the collaborative infrastructure and facilities 
</li>
<li> Provide NesC component implementations 
</li>
<li> Provide Formal Architecture for their components 
</li>
</ul>

<p> Challenge Architecture Document goals 
</p>

<ul>
<li> Provide frameworks to allow for Middleware providers to develop individual
components in a reasonably independent manner 
</li>
<li> Define a Methodology subject to constraints extracted from the demo
description 
</li>
<li> Define Prototypes which form the core abstraction 
</li>
<li> Use those Prototypes create Concrete Implementations in NesC, subject to
constraints specified in the Formal Architecture 
</li>
<li> Always work toward abstractions when it makes sense to do so 
</li>
<li> Specify common types / structures used between components 
</li>
</ul>

</div>

</div>



<div class="heading1">2. Demo Description</div><div class="subsection">

<div class="heading2">2.1. Game Outline</div><div class="subsection">

<p> To start the game, the motes comprising the sensor network are deployed
onto the playing field in a sleep state.  An external node broadcasts a begin
signal to the sensor network to indicate the start of global time.  The
pursuers and evaders then enter the playing field and remain within the field
for the duration of the game.  The sensor network provides a variety of
services to both pursuers and other sensor motes: time synchronization,
localization, critter (moving object: pursuer or evader) estimation, etc.  For
the purpose of the game, the sole goal of these services is to produce
estimates on the positions, velocity, and identity of critters in the playing
field.  This information is time stamped and routed to all pursuers in the
playing field.  The pursuers have onboard computation facilities comparable to
a laptop computer and may optionally communicate through a separate robust
channel to coordinate to capture the evader.  When all evaders are captured (a
capture occurs when a pursuer is "close enough" to it), the game ends.  A base
station is outside the playing area and provides logging and visualization
services. 
</p>

</div>

<div class="heading2">2.2. Demo Implementation</div><div class="subsection">

<ul>
<li> <b>Location</b> - Richmond Field Station 
</li>
<li> <b>Playing</b> <b>Field</b> - 20m x 20m 
</li>
<li> <b>Coordinate</b> <b>System</b> - Aligned with the GPS coordinate system with origin
at the southeast corner of the field 
</li>
<li> <b>Sensor</b> <b>Network</b> - 100-400 motes with sensor boards dropped from
helicopter on a grid spacing of 1-2m 
</li>
<li> <b>Evader</b> - 1 Pioneer robot 
</li>
<li> <b>Pursuer</b> - 2-3 Pioneer robots 
</li>
</ul>

</div>

<div class="heading2">2.3. Functional Outline</div><div class="subsection">

<p> Pursuers 
</p>

<ol>
<li> Initialize 
</li>
<li> Listen for updates from the sensor network 
</li>
<li> Communicate, coordinate with the other pursuers if necessary 
</li>
<li> Actuate to capture the evader 
</li>
<li> Debugging/logging output 
</li>
<li> Go to Step 2 if evader has not been caught 
</li>
<li> Done 
</li>
</ol>

<p> Mote Sensors 
</p>

<ol>
<li> Initialize and calibrate 
</li>
<ol>
<li> Position and velocity estimates require the sensor motes to have self-localization 
</li>
<li> ... and time synchronization 
</li>
<li> Robust routing protocols may require initial network measurements 
</li>
</ol>
<li> Estimate the position and velocity of pursuers and evaders 
</li>
<ol>
<li> Filtering and sensor data reduction at each mote 
</li>
</ol>
<li> Send estimates to pursuers 
</li>
<li> Debugging/logging output 
</li>
<li> Go to Step 2 until "Stop" 
</li>
<li> Done 
</li>
</ol>

<p> Evaders 
</p>

<ol>
<li> Human controlled 
</li>
<li> Smart mote evaders get some subset of 
</li>
<ol>
<li> Listens to the network traffic 
</li>
<li> Knows the pursuit algorithms 
</li>
<li> Knows the pursuer dynamics 
</li>
</ol>
<li> Smart evaders maximally exploit any data they gather 
</li>
</ol>

</div>

</div>



<div class="heading1">3. Architecture Methodologies</div><div class="subsection">

<p> The architecture defines a set of components which may implement algorithms
and may behave as services.  The architecture further defines the input and
output structures and protocols accepted and emitted by components, implicit or
explicit constraints and behaviors pertinent to the components, and
interrelationships between components. 
</p>

<p> In this chapter, we first define just the subset of the architecture seen
from the application layer: the pursuit-evasion game demo.  From there, we
iteratively extend that architecture with likely supporting components up-to
and including top-level TinyOS components.  As this document evolves, we will
keep an eye toward abstraction and generality; ideally creating a refactored
specification with broader application than just the game demo. 
</p>
 
<div class="heading2">3.1. Overall Methodology</div><div class="subsection">

<div class="heading3">3.1.1. Prototypes</div><div class="subsection">

<p> Prototypes are the essence of the architecture.  Prototypes define the
minimal interface provided by components.  The goal is to create an
architecture in which dissimilar implementations of components are
interchangeable if they provide equivalent facilities, while at the same time
not imposing unnecessary constraints on the underlying algorithms. 
</p>

<p> These Prototypes formally describe the API that certain classes of
components and algorithms must adhere to.  Concrete implementations of these
prototypes provide at least the described interfaces, but may include
additional interfaces specific to the algorithm at hand, such as Sensor's and
Actuator's.  Concrete implementations that wish to be used in the demo must
fully specify themselves in the context of this document.  That is, they must
clearly define their abstract, formal, NesC, and graphical architectures.
These concrete specifications will be wholly included in the architecture
document.  
</p>

</div>

<div class="heading3">3.1.2. Services</div><div class="subsection">

<p> Each service is implemented as a separate component.  We intend a
coordination component that provides scheduling of other components and
management of shared resources.  Each component is initialized in turn, during
which it is responsible for registering itself with the coordination component.
Each component registers how often it should be executed (time-triggered) and
which events it should receive (messages, sensor readings, etc).  The
coordination component is responsible for meeting these demands of the
components. 
</p>

</div>

<div class="heading3">3.1.3. Filtering and Calibration Interfaces</div><div class="subsection">

<p> To filter data or calibrate a sensor or actuator, we intend to create
components that both provide and use the interface they are
filtering/calibrating. This allows us to chain any number of filters or
calibrations transparently.  
</p>

</div>

</div>

<div class="heading2">3.2. Implementation Methodology</div><div class="subsection">

<div class="heading3">3.2.1. Resources</div><div class="subsection">

<p> By default, we are not providing a resource sharing infrastructure beyond
the sharing of the CPU and RF channel via the service coordination component.
That is, we are assuming that in any particular configuration, no more than one
component will want to use, say, the sounder.  Creating a configuration in
which more than one component needs access to the same resource is considered
malformed.  If this becomes a problem in practice, we will work to develop a
resource sharing scheme.  We are deferring that solution until we see conflicts
arise in practice.   That way, we can develop something well-suited for the
problem (instead something ill-suited). 
</p>

</div>

<div class="heading3">3.2.2. Input/Output Convention</div><div class="subsection">

<p> Sensors readings (input) are event driven. Processing dependent on sensor
readings are also events, say for filtering data. And, it cascades all the way
up; events are fired for both estimating position and initiating the broadcast
of those estimates. Actuation (output) is command driven; that includes both
movement and outgoing communication.  
</p>

</div>

<div class="heading3">3.2.3. Send/Receive Structures</div><div class="subsection">

<p> We want to abstract from byte-packed messages used for radio communication.
Each component that communicates via messages to other components (either on
the local mote or remote motes) operates in the context of a structure
containing native types. We package all relevant information in a single
structure. This reduces the need to redefine interfaces when/if we adjust only
the particular data passed between components. This also results in a
one-to-one correspondence between message interfaces and message structures.
</p>

</div>

</div>

</div>




<div class="heading1">4. Estimation</div><div class="subsection">

<p>
This component aggregates sensor readings among a group of motes. The protocol
for data measurement and aggregation is application-specific and transparent to
the rest of demo code. If a target is detected, the component fires a
TargetPosition event on the motes attached to the pursuers. The event passes
the address of a target and a target identifier. The protocol will attempt to
use the same identifier consistently to refer to the same target. This is
accomplished with the help of the group management component described in
Section 4.  A higher-level protocol can be used to compile a list of all
identified targets and their current locations.
</p>

<p>
Estimate Target depends on the PacketRouting component. Especially, it will
need to use the RouteMobile interface to deliver the target information to the
pursuers. The target estimation component also interacts with the location
service. It needs the location information to calculate the position of the
target using the positions of the detecting motes. 
</p>

<pre class="code" id="module_PrototypeEstimateTargetM">module <span class="nesc_self">PrototypeEstimateTargetM</span> {
    provides {
        interface <a href="#interface_TargetPosition">TargetPosition</a>;
    } uses {
        interface ReceiveMsg;
        interface SendMobile;
    }
}</pre>

<pre class="code" id="interface_TargetPosition">interface <span class="nesc_self">TargetPosition</span> {
    event result_t <a href="#interface_TargetPosition">TargetPosition</a>(
        <a href="#typedef_location_t">location_t</a> position;
        char target_id 
    );
}</pre>

</div>



<div class="heading1">5. Grouping</div><div class="subsection">

<p>
Below is a preliminary API for group management services in NEST (MIT,
OSU, UVa).
</p>

<p>
The whole picture of definition is
</p>

<pre class="code" id="module_GroupManagementM">module <span class="nesc_self">GroupManagementM</span> {
    provides {
        interface StdControl;
        interface <a href="#interface_GroupManagementGlobal">GroupManagementGlobal</a> as GMGlobal;
        interface <a href="#interface_GroupManagementNeighbor">GroupManagementNeighbor</a> as GMNeighbor;
        interface <a href="#interface_GroupManagementTracking">GroupManagementTracking</a> as GMTracking;
    } uses {
        .;
    }
}</pre>

<p>
The group management component produces a suite of services with three
different functionalities, described below.
</p>


<div class="heading2">5.1. The Global Broadcast/Multicast service</div><div class="subsection">

<p>
This service exports these calls:
</p>

<pre class="code" id="interface_GroupManagementGlobal">Interface <span class="nesc_self">GroupManagementGlobal</span> {
    command result_t multicast(
        uint8_t type,
        char *msg 
    );
    event result_t receiveMulticast(
        uint8_t type,
        char *msg 
    );
    event result_t leader(
        uint8_t type,
        uint8_t on_off 
    );
}</pre>

<p>
The multicast primitive communicates a message efficiently to all
destinations within the given radius configured into the service or
indicated in the message header. The type parameter is used to distinguish
different types of multicast services described in this document. This
service has type LOCATION. The implementation transparently uses the MIT's
location-dependent group formation protocol. receiveMulticast is an event
raised to inform an application that a multicast message has been
received.  The underlying routing scheme uses a leader election protocol.
The nodes that are elected leaders are notified using the leader event
when they become and when cease to be leaders in this protocol. The
application can ignore that event or utilize it for application-level
functions that need to be performed at selected nodes in the network.
Check MITs group formation documentation for more info on how leaders are
elected and what properties they have.
</p>

</div>


<div class="heading2">5.2. Neighborhood Maitenance Component</div><div class="subsection">

<pre class="code" id="interface_GroupManagementNeighbor">interface <span class="nesc_self">GroupManagementNeighbor</span> {
    command result_t getNeighborhoodInfo();
}</pre>

<p>
The main call expored is getNeighborhoodInfo().
</p>

<p>
It returns a data structure with information regarding neighborhood
health.
</p>

<ul>
<li>
Why?

  
<p>
  Berkeley reports that the "raw" connectivity information in motes
  network may not necessarily be suitable for routing and other reliable
  communication and infrastructure tasks:
  
</p>

  
<ul>
  
<li>
     a link may be asymmetric so the communication can be reliable done
     only one way
  
</li>
  
<li>
     a link may be unreliable (so it would be easier to use
     two hop communication with two reliable links to bypass one
     unreliable link), a link may be "long", don't have enough
     bandwidth, etc.
  
</li>
  
<li>
     a node may have too many neighbors and thus may be potentially
     overloaded, a node may be just overloaded or run low on power
     so it should be avoided for routing and (transit) communication
  
</li>
  
</ul>

<li>
What to do?

  
<p>
  create Neighborhood Maintenance Component that depending
  on the application gives an "improved" neighborhood information.
  This "improved" information preserves the cardinal features of
  "raw" info such as connectivity.
  
</p>

  
<p>
  notice that it is not necessarily immediate neighborhood but
  possibly extended to 2-3 hops from a node.
  
</p>

  
<p>
  OSU has a few schemes how this can be done efficiently, locally
  and with great degree of fault tolerance.
  
</p>
</li>

<li>
Can't this be done by localization component (the component
that establishes mote's relative coordinates in physical space)?

  
<p>
  no, multiple reasons:
  
</p>

  
<ul>
  
<li>
    geographic proximity does not immediately translate into link
    quality
  
</li>
  
<li>
    there may be other factors besides link quality that influence
    topology maintenance:
        cluster size, node load, remaining battery life, etc.
  
</li>
  
<li>
    the information about neighbors still needs to be maintained
  
</li>
  
</ul>

</li>
<li>
  Can't this be done as a part of routing component?
  possibly, but better if neighborhood is maintained as a separate
  component:

  
<ul>
  
<li>
          neighborhood maintenance can be done locally and independently
          of routing (using messages from other components or their own).
  
</li>
  
<li>
          neighborhood info can be used by components other than
          routing
  
</li>
</li>
</ul>


<p>
Interface Specification
</p>

<ul>
<li>
  this component accepts messages to send from
  upper layer components and delivers received messages to them.
  Essentially it acts as a filter in the network stack (accepting
  messages from upper layers and sending them to lower layer)
</li>
<li>
  exports the neighborhood topology information (and possibly neighbor
  resources such as battery power, etc)
</li>
</ul>

</div>

<div class="heading2">5.3. Entity Tracking Service</div><div class="subsection">

<p>
The interface is:
</p>

<pre class="code" id="interface_GroupManagementTracking">interface <span class="nesc_self">GroupManagementTracking</span> {
    command result_t join(
        uint8_t target_signature 
    );
    command result_t leave(
        uint8_t target_signature 
    );
    command result_t setState(
        char state 
    );
    command result_t getState(
        char state 
    );
    event result_t leader(
        uint8_t type,
        uint8_t on_off 
    );
}</pre>

<p>
The main abstraction exported by the service is that of tracking groups.
A tracking group is formed among all nodes sensing the target, as
defined by a given sensory signature. The unique group name unambiguously
labels each target. As the target moves, the membership of the group
changes, but group identity remains the same. Hence, proximity-based
groups will help identify and track different evaders. The main API is:
</p>

<pre class="code">command result_t join( uint8_t target_signature )
</pre>

<p>
The call specifies the detected target signature.  The call is executed
when a node senses a target of that particular signature. The call
<b>returns</b> a group id specifying <b>which</b> target of that signature is
currently in the proximity of the joining node as maintained by the group
management service. Hence, a node's code might like something like:
</p>

<pre class="code">if( target_signature is detected ){
    target_id = join( target_signature )
    tell pursuer that I see target_id at my_location.
} 
</pre>

<p>
Observe that in the absence of tracking groups the node would not be able
to immediately identify which target it is seeing (e.g., whether it is
seeing the evader or one of the pursuers. Identifying the target locally
is the main advantage of tracking groups. Other API calls are:
</p>

<pre class="code">command result_t leave( target_signature )
</pre>

<p>
The leave call specifies that the target can no longer be locally sensed
by this node. The service also supports the calls:
</p>

<pre class="code">event result_t leader( type, on_off )
command result_t setState( state )
command result_t getState( state )
</pre>

<p>
As before, the leader call notifies the application when its node becomes
or ceases to be leader, except that when type=TRACKING, the event refers
to the leader of the tracking group. This leader changes as the group
migrates. The invariants maintained are the group id and the fact that the
leader is always within sensory horizon from the target tracked by this
specific group. setState and getState is used to save and restore state
that the algorithm maintains persistently across different leaders.
Hence, when a node becomes leader is can getState and resume computation
from where the last leader left it. The node would periodically checkpoint
the computation using setState. 
</p>

</div>

</div>




<div class="heading1">6. Localization API document</div><div class="subsection">

<p> We break localization into four sub-systems: 
</p>

<ol>
<li> sensing/actuation 
</li>
<li> data management 
</li>
<li> computation 
</li>
<li> system control 
</li>
</ol>

<p> This breakdown gives us modularity and interchangeability because each
sub-system has its own API. 
</p>

<p> First, we describe each sub-system and a few important points about them.
Then, we write down the APIs for each sub-system.  Finally, we make a few
concluding remarks about protocols, incremental development, non-homogenous
networks, and data representation. 
</p>

<div class="heading2">6.1. The Subsystems</div><div class="subsection">

<div class="heading3">6.1.1. Localization Sensing/Actuating</div><div class="subsection">

<p> The sensing/actuation sub-system gives you ranging and/or angle data (with
which you would later do multi-lateration and/or triangulation, respectively).
This sub-system should be broken into at least two components: sensor and
actuator.  This allows non-homogenous networks, e.g. an infrastructure might
always transmit localization beacons while the network always senses or vice
versa.  We can have a homogenous network by simply installing both components
on every mote. 
</p>

<p> This subsystem has three top interfaces with which it 
</p>

<ol>
<li> is requested to actuate (e.g. send a localization beacon) 
</li>
<li> gives new data (e.g. ranging estimates) 
</li>
<li> is commanded to turn on and off 
</li>
</ol>

<p> It also has a lower interface to interact with whatever actuator or sensor.
</p>

</div>

<div class="heading3">6.1.2. Localization Data Management</div><div class="subsection">

<p> The data sub-system holds ranging/angle/location data of all important
neighbors.  This subsystem is not just a passive data structure, it is actually
quite active.  Let.s say, for instance, that my localization algorithm works
best with 8 neighbors.  If I have more than 8 neighbors, I need to know which
neighbors to ignore (perhaps those with the noisiest ranging estimates or
perhaps those with short distances).  I also have to know when data becomes old
and invalid, etc.  Every implementation of this sub-system will have to make
all of these decisions based on the type of ranging being used and the type of
localization algorithm begin used. 
</p>

<p> This sub-system has a bottom interface with which it receives new data.  It
also has a top interface with which it gives data and a top interface with
which it can be commanded to start and stop (starting and stopping here might
not be well defined).   
</p>

</div>

<div class="heading3">6.1.3. Localization Computation</div><div class="subsection">

<p> The computational level is where we do triangulation, multilateration, or
whatever.  This is what most people think of when they hear .localization. but
it is really the easiest part to write for an embedded system like TinyOS. 
</p>

<p> This sub-system has a bottom interface with which it requests data from the
data management sub-system.  It also has a top interface with which it gives
new location estimates and a top interface with which is can be commanded to
start or stop.   
</p>

</div>

<div class="heading3">6.1.4. Localization System Control</div><div class="subsection">

<p> This sub-system controls all the other sub-systems.  This should be
separate from the other systems because its functionality is completely defined
by the application.   For example, in a static environment we may only want to
localize once in the beginning of the application and then never again.  If
something walks into the room we might want all nodes near the moving node to
help it localize.  In a completely dynamic environment we might want all nodes
localizing by following some scheduling algorithm, which would be implemented
here.  Sometimes, we may want very frequent ranging estimates but only
infrequent location estimates, etc. etc. 
</p>

<p> This sub-system has a bottom interfaces with which it controls all lower
sub-systems.  It also has a top interface with it is told to start and stop.
</p>
 
</div>

</div>

<div class="heading2">6.2. API Definitions</div><div class="subsection">

<div class="heading3">6.2.1. Localization Sensing/Actuating</div><div class="subsection">

<pre class="code" id="module_PrototypeLocalizationActuatorM">module <span class="nesc_self">PrototypeLocalizationActuatorM</span> {
    provides {
        interface StdControl;
        interface <a href="#interface_LocalizationActuator">LocalizationActuator</a>;
    } uses {
        interface Actuator;
    }
}</pre>

<pre class="code" id="module_PrototypeLocalizationSensorM">module <span class="nesc_self">PrototypeLocalizationSensorM</span> {
    provides {
        interface StdControl;
        interface <a href="#interface_LocalizationSensor">LocalizationSensor</a>;
    } uses {
        interface Sensor;
    }
}</pre>

</div>
 
<div class="heading3">6.2.2. Localization Data Management</div><div class="subsection">

<pre class="code" id="module_PrototypeLocalizationDataManagerM">module <span class="nesc_self">PrototypeLocalizationDataManagerM</span> {
    provides {
        interface StdControl;
        interface <a href="#interface_LocalizationData">LocalizationData</a>;
    } uses {
        interface <a href="#interface_LocalizationSensor">LocalizationSensor</a>;
    }
}</pre>

</div>

<div class="heading3">6.2.3. Localization Computation</div><div class="subsection">

<pre class="code" id="module_PrototypeLocalizationComputationM">module <span class="nesc_self">PrototypeLocalizationComputationM</span> {
    provides {
        interface StdControl;
        interface <a href="#interface_LocalizationCompute">LocalizationCompute</a>;
        interface <a href="#interface_LocalizationSensor">LocalizationSensor</a>;
    } uses {
        interface <a href="#interface_LocalizationData">LocalizationData</a>;
    }
}</pre>

</div>

<div class="heading3">6.2.4. Localization System Control</div><div class="subsection">

<pre class="code" id="module_PrototypeLocalizationControlM">module <span class="nesc_self">PrototypeLocalizationControlM</span> {
    provides {
        interface StdControl;
    } uses {
        interface StdControl as LocalizationSensorControl;
        interface StdControl as LocalizationActuatorControl;
        interface StdControl as LocalizationDataControl;
        interface StdControl as LocalizationComputationControl;
        interface <a href="#interface_LocalizationActuator">LocalizationActuator</a>;
        interface <a href="#interface_LocalizationCompute">LocalizationCompute</a>;
    }
}</pre>

</div>

</div>

<div class="heading2">6.3. Interfaces</div><div class="subsection">

<pre class="code" id="interface_LocalizationActuator">interface <span class="nesc_self">LocalizationActuator</span> {
    command result_t Actuate(
        uint16_t actuationDestinationAddress,
        uint16_t dataDestinationAddress 
    );
}</pre>

<pre class="code" id="interface_LocalizationSensor">interface <span class="nesc_self">LocalizationSensor</span> {
    event result_t DataSensed(
        <a href="#typedef_localization_t">localization_t</a> newData 
    );
}</pre>

<pre class="code" id="interface_LocalizationData">interface <span class="nesc_self">LocalizationData</span> {
    command result_t GetLocalizationInfo(
        uint16_t moteID 
    );
}</pre>

<pre class="code" id="interface_LocalizationCompute">interface <span class="nesc_self">LocalizationCompute</span> {
    command result_t Localize();
}</pre>

</div>


<div class="heading2">6.4. Data Types</div><div class="subsection">

<pre class="code" id="typedef_localization_t">typedef struct {
    uint16_t moteID;
    distance_t* distanceFromMe;
    <a href="#typedef_angle_t">angle_t</a>* distanceFromMe;
    <a href="#typedef_location_t">location_t</a>* distanceStdv;
} <span class="nesc_self">localization_t</span>;</pre>

<pre class="code" id="typedef_location_t">typedef struct {
    uint16_t EstimatedXCoord; //or theta angle for spherical coords
    uint16_t XCoordStdv;
    uint16_t EstimatedYCoord; //or phi angle
    uint16_t YCoordStdv;
    uint16_t EstimatedZCoord; //or r value
    uint16_t ZCoordStdv;
    uint16_t CoordinateSystemID;
} <span class="nesc_self">location_t</span>;</pre>
 
<pre class="code" id="typedef_ranging_t">typedef struct {
    uint16_t DistanceFromMe;
    uint16_t DistanceStdv;
} <span class="nesc_self">ranging_t</span>;</pre>
 
<pre class="code" id="typedef_angle_t">typedef struct {
    uint16_t phiAngleRelativeToMe;
    uint16_t phiAngleStdv;
    uint16_t thetaAngleRelativeToMe;
    uint16_t thetaAngleStdv;
} <span class="nesc_self">angle_t</span>;</pre>

</div>

<div class="heading2">6.5. Important Notes and Problems</div><div class="subsection">

<div class="heading3">6.5.1. Protocols</div><div class="subsection">

<p> Note that these interfaces are really simple and don.t support any
protocols.  However, you can always wrap any sub-system in a component that
gives you a more sophisticated interface to support your protocol.  For
example, you may want an interface that allows you to request N chirps at
frequency F.  This can be done with a wrapper class around your
<span class="codefrag"><a href="#interface_LocalizationActuator">LocalizationActuator</a></span> component.  You might also have motes that want to ask
other motes for their locations.  You can do this by wrapping your
<span class="codefrag"><a href="#interface_LocalizationData">LocalizationData</a></span> component in a wrapper component that interprets packet
commands.  By not including these things in the interfaces above, we are
separating the functionality from the protocol, thereby allowing us to
interchange protocols. 
</p>

</div>

<div class="heading3">6.5.2. Incremental Development and Non-homogeneity</div><div class="subsection">

<p> Given the above about protocols, we do not have to make any assumption that
each mote has all four sub-systems (i.e. a homogenous assumption).  For
example, system control might be contained in a single "leader" mote or all
computational sub-system might be implemented centrally on a PC.  In my
particular case, for example, all I have is a sensor/actuator system that sends
time of flight chirps and makes ranging estimates.  I could wrap it in a
wrapper component that chirps when it receives my command packet and sends me
back the data in a data packet.  Then, data management, computation, and chirp
scheduling is done centrally in Matlab.  This is good for incremental
development. 
</p>

</div>

<div class="heading3">6.5.3. Data Representation Problems</div><div class="subsection">

<p> Notice that we have a huge problem with data representation.  If the above
<span class="codefrag"><a href="#typedef_localization_t">localization_t</a></span> data structure is not sufficient for all or most
localization applications, there is little hope of interchanging components.  I
note three main problems here: units, coordinate systems, and error terms. 
</p>

<div class="heading4">6.5.3.1. Units</div><div class="subsection">

<p> Do we store every distance estimate with its units (i.e. cm or meters or
hop-counts) or do we just use the convention that all distances are in
centimeters.  What about systems with relative distances that don.t know the
units of their ranging estimates?  In the above <span class="codefrag"><a href="#typedef_localization_t">localization_t</a></span> data
structure I assumed we would use the convention that all distance estimates are
in centimeters and all rho/theta estimates are in degrees. 
</p>

</div>

<div class="heading4">6.5.3.2. Coordinate Systems</div><div class="subsection">

<p> Are all of our positions stored with their coordinate systems, eg.  if this
position is in GPS coordinates it should say so?   What about relative
coordinate systems?  Do we need a LocalizationCoordinateSystem component to
bootstrap a coordinate system?  How do we identify the units of a relative
coordinate system?  How do we identify the identity of a relative coordinate
system, i.e. when two networks that have different relative coordinate systems
meet, how do we resolve them?  What about networks that have two overlaid
coordinate systems, i.e. it has some GPS nodes and some nodes on a relative
coordinate system or room-based coordinate system.  In the above
<span class="codefrag"><a href="#typedef_localization_t">localization_t</a></span> data structure I assumed that we could identify each
coordinate system with the ID of the leader or creator of that coordinate
system.  However, I have not defined a coordinateSystem component. 
</p>

</div>

<div class="heading4">6.5.3.3. Error terms</div><div class="subsection">

<p> Quite often your ranging or angle estimations or location estimations come
with error terms.  How do we represent this?  With a canonical probability
distribution?  We could assume Gaussian noise on everything and always couple
every estimate with a standard deviation.  Is that sufficient for everybody?
In the above <span class="codefrag"><a href="#typedef_localization_t">localization_t</a></span> data structure I assumed that it is. 
</p>

</div>

</div>

</div>

</div>



<div class="heading1">7. Power management component proposed by CMU</div><div class="subsection">

<p> We propose the following tentative module for power management in NEST
challenge application on Berkeley OEP. The module provides interfaces for
implementing both centralized and decentralized power state control algorithms
of wireless sensors.  
</p>

<p> The centralized version contains <span class="codefrag"><a href="#interface_TurnOn">TurnOn</a></span> and <span class="codefrag"><a href="#interface_TurnOff">TurnOff</a></span> interfaces for
a sentry to control the power states of each individual sensor in its group. If
a sentry needs to turn a particular sensor off, it broadcasts a
<span class="codefrag"><a href="#typedef_remote_turn_off">remote_turn_off</a></span> message with the sensor ID and the period in which the
sensor wakes up and checks for <span class="codefrag"><a href="#typedef_remote_turn_on">remote_turn_on</a></span> messages; If such a message
is detected, that sensor stays on, otherwise, goes back off. The sentry knows
when to send out <span class="codefrag"><a href="#typedef_remote_turn_on">remote_turn_on</a></span> or new <span class="codefrag"><a href="#typedef_remote_turn_off">remote_turn_off</a></span> messages to a
sensor because it knows when that sensor wakes up to check for messages. 
</p>

<p> In the decentralized version, each non-sentry sensor decides locally on the
power state transitions. This approach uses PowerMangementAlgorithm interface
to control the power state transitions. The algorithm interface, based on
current length of idle time, decides whether the sensor turns off or stays on,
and when is the next control epoch. Before the sensor turns off, it sends out a
<span class="codefrag"><a href="#typedef_off_notification">off_notification</a></span> message to notify the sentry that it is going to wake up
and check for messages at the next control epoch; The sentry can then use
<span class="codefrag"><a href="#typedef_remote_turn_on">remote_turn_on</a></span> message to wake up the sensor if it needs to do that at that
time. 
</p>

<div class="heading2">7.1. Modules</div><div class="subsection">
 
<pre class="code" id="module_PowerManagement">module <span class="nesc_self">PowerManagement</span> {
    // module <a href="#module_Sentry">Sentry</a>;
    // module <a href="#module_NonSentry">NonSentry</a>;
    provides {
        interface <a href="#interface_TurnOff">TurnOff</a>;
        interface <a href="#interface_TurnOn">TurnOn</a>;
    } uses {
        interface PowerMangementAlgorithm;
    }
}</pre>

<pre class="code" id="module_Sentry">module <span class="nesc_self">Sentry</span> {
    provides {
        interface <a href="#interface_TurnOff">TurnOff</a>;
        interface <a href="#interface_TurnOn">TurnOn</a>;
        interface <a href="#interface_OffNotified">OffNotified</a>;
    } uses {
        command remoteTurnOff;
        command remoteTurnOn;
    }
}</pre>

<pre class="code" id="module_NonSentry">module <span class="nesc_self">NonSentry</span> {
    provides {
        interface <a href="#interface_LocalTurnOff">LocalTurnOff</a>;
        interface <a href="#interface_LocalTurnOn">LocalTurnOn</a>;
    } uses {
        interface <a href="#interface_OffNotifying">OffNotifying</a>;
        interface <a href="#interface_PowerManagementAlgorithm">PowerManagementAlgorithm</a>;
    }
}</pre>

</div>
 
<div class="heading2">7.2. Interfaces</div><div class="subsection">

<pre class="code" id="interface_TurnOff">interface <span class="nesc_self">TurnOff</span> {
    command result_t remoteTurnOff(
        <a href="#typedef_remote_turn_off">remote_turn_off</a>* msg 
    );
}</pre>

 
<pre class="code" id="interface_TurnOn">interface <span class="nesc_self">TurnOn</span> {
    command result_t remoteTurnOn(
        <a href="#typedef_remote_turn_on">remote_turn_on</a>* msg 
    );
}</pre>

<pre class="code" id="interface_OffNotified">interface <span class="nesc_self">OffNotified</span> {
    event result_t offNotification(
        <a href="#typedef_off_notification">off_notification</a>* msg 
    );
}</pre>

<pre class="code" id="interface_LocalTurnOff">interface <span class="nesc_self">LocalTurnOff</span> {
    event result_t localTurnOff(
        boolean remote_or_local,
        <a href="#typedef_remote_turn_off">remote_turn_off</a>* msg,
        <a href="#typedef_power_state_control">power_state_control</a>* action 
    );
}</pre>

<pre class="code" id="interface_LocalTurnOn">Interface <span class="nesc_self">LocalTurnOn</span> {
    event result_t localTurnOn(
        boolean remote_or_local,
        <a href="#typedef_remote_turn_on">remote_turn_on</a>* msg,
        power_state-control* action 
    );
}</pre>

<pre class="code" id="interface_OffNotifying">interface <span class="nesc_self">OffNotifying</span> {
    command result_t offNotifying(
        <a href="#typedef_off_notification">off_notification</a>* msg 
    );
}</pre>
 
<pre class="code" id="interface_PowerManagementAlgorithm">interface <span class="nesc_self">PowerManagementAlgorithm</span> {
    command result_t powerMangementAlgorithm(
        unsigned int idle_time_length,
        <a href="#typedef_power_state_control">power_state_control</a>* action 
    );
}</pre>

</div>
 
<div class="heading2">7.3. Types</div><div class="subsection">

<pre class="code" id="typedef_remote_turn_off">typedef struct {
    unsigned int moteID;
    unsigned int waking_up_period;
} <span class="nesc_self">remote_turn_off</span>;</pre>

<pre class="code" id="typedef_remote_turn_on">typedef struct {
    unsigned int moteID;
    unsigned int current_time;
} <span class="nesc_self">remote_turn_on</span>;</pre>

<pre class="code" id="typedef_off_notification">typedef struct {
    unsigned int moteID;
    unsigned int expected_wake_up_time;
} <span class="nesc_self">off_notification</span>;</pre>

<pre class="code" id="typedef_power_state_control">typedef struct {
    boolean on_or_off;
    unsigned int next_control_epoch;
} <span class="nesc_self">power_state_control</span>;</pre>

</div>

</div>
 


<div class="heading1">8. Interface for the Routing Component of TinyOS</div><div class="subsection">

<p> We consider routing as passing a message of arbitrary size (with some upper
limit defined by length type) from a source to one or a set of destinations
anywhere in the entire network. There are two functions for the routing
components: one is to segment data into packets at the source and reassemble at
the destinations, and the other is to choose one or a set of next hops for
passing the packets to their destinations. 
</p>

<p> There are various ways to specify message destinations and preferable
routes. In this architecture, we present some commonly used ones, although it
is subject to extensions. We intend to only make common routing interfaces,
rather than common routing algorithms and component implementations.
Applications should be able to switch between different routing components that
provide the same set of interfaces. In addition to message sending interfaces,
there is a routing interface that signals the message arrival event, which can
be wired to upper-layer components.  Each routing component will be required to
implement this capability.  
</p>

<p> The following diagram shows how the routing components will be composed in
the context of TinyOS. Routing components, e.g. ROUTE-1 or ROUTE-2, will be on
top of AM_STANDARD component. AM_STANDARD demultiplexes incoming requests to
the appropriate routing component.  Each routing component will be used by one
or more high-level application components. In the following diagram, ROUTE-1 is
used by COM-11 and COM-12, and ROUTE-2 by COM-21 and COM-22. 
</p>

<div align=center><img src="routing_fig1.png"></div>

<p> All communication goes through AM_STANDARD, which defines the top of the
shared network stack. The routing components implement the same generic
interface. That is, the interface between COM-11 and ROUTE-1, the interface
COM-21 and ROUTE-2 is the same regardless of the routing algorithm.  This makes
it easier to .wire together. components in TinyOS.   
</p>

<p> By sharing the same interface, we can easily add new components in the
communication stack whenever necessary. For example, we can add the
SECURITY_COM component, which can be used by more than one routing components
like the following. Here, ROUTE-1 and ROUTE-2 use the SECURITY_COM whereas
ROUTE-3 does not. 
</p>

<div align=center><img src="routing_fig2.png"></div>

<div class="heading2">8.1. Proposed Interfaces</div><div class="subsection">

<div class="heading3">8.1.1. Receiving Routing Message Interface</div><div class="subsection">

<pre class="code" id="interface_ReceiveRoutingMsg">interface <span class="nesc_self">ReceiveRoutingMsg</span> {
    /**
    Receive message done signal &lt;p&gt;
    @param length The length of the message
    @param msg The message just sent out
    */
    event result_t receive(
        uint8_t length,
        char* msg 
    );
}</pre>

<p> This interface provides a message arrival signal, indicating a message
arrived to one of its destinations. In addition to the message itself, the
length of the message is provided. All routing modules have to provide the
above interface. In addition, routing modules may also provide some of the
following interfaces. 
</p>

<pre class="code" id="interface_GetRoutingMsgSource">interface <span class="nesc_self">GetRoutingMsgSource</span> {
    /**
    Get the source of the last message received &lt;p&gt;
    */
    command uint16_t get();
}</pre>

<pre class="code" id="interface_GetRoutingMsgHopCount">interface <span class="nesc_self">GetRoutingMsgHopCount</span> {
    /**
    Get the hop count of the last message received &lt;p&gt;
    */
    command uint8_t get();
}</pre>

<pre class="code" id="interface_GetRoutingMsgTimeStamp">interface <span class="nesc_self">GetRoutingMsgTimeStamp</span> {
    /**
    Get the time stamp of last message received &lt;p&gt;
    */
    command uint8_t get();
}</pre>

</div>

<div class="heading3">8.1.2. Generic Routing Sending Message Interface</div><div class="subsection">

<pre class="code" id="interface_SendRoutingMsg">interface <span class="nesc_self">SendRoutingMsg</span> {
    /**
    Send a message out to one or more remote motes &lt;p&gt;
    @param dest The destination( s )
    @param length The length of the message
    @param msg The array of bytes need to send out
    @return SUCCESS if successful
    */
    command result_t send(
        <a href="#typedef_destination_t">destination_t</a> dest,
        uint8_t length,
        char* msg 
    );
    /**
    Send message done signal &lt;p&gt;
    @param msg The message just sent out
    @param success If the send is done successfully
    */
    event result_t sendDone(
        char* msg,
        result_t success 
    );
}</pre>

<p> This is a general interface for all routing components. We have identified
a number of specific routing techniques that can be implemented using this
interface.  Here the destination is a union of all the types used for these
techniques. This is a parameterized interface where the type of destinations
shall be associated with send when the actual wire takes place. The union type
is defined now as: 
</p>

<pre class="code" id="typedef_destination_t">typedef union {
    uint8_t hops;
    uint16_t address;
    <a href="#typedef_location_t">location_t</a> *location;
    <a href="#typedef_CBR_t">CBR_t</a> *dest;
} <span class="nesc_self">destination_t</span>;</pre>

<p> where CBR_t is 
</p>

<pre class="code" id="typedef_CBR_t">typedef struct {
    routing_t type;
    <a href="#typedef_constraints_t">constraints_t</a> *dest;
    <a href="#typedef_constraints_t">constraints_t</a> *rout;
    <a href="#typedef_objectives_t">objectives_t</a> *objs;
} <span class="nesc_self">CBR_t</span>;</pre>

<p> In the following sections, we specify separate interfaces that may be used
to wrap the generic interface for specific routing techniques.  
</p>

</div>

<div class="heading3">8.1.3. Local Broadcast Interface</div><div class="subsection">

<pre class="code" id="interface_SendMsgByBct">interface <span class="nesc_self">SendMsgByBct</span> {
    /**
    Send a message out &lt;p&gt;
    @param hops The number of hops to the source
    @param length The length of the message
    @param msg The array of bytes need to send out
    @return SUCCESS if successful
    */
    command result_t send(
        uint8_t hops,
        uint8_t length,
        char* msg 
    );
    /**
    Send message done signal &lt;p&gt;
    @param msg The message just sent out
    @param success If the send is done successfully
    */
    event result_t sendDone(
        char* msg,
        result_t success 
    );
}</pre>

<p> This interface specifies a local broadcast function of routing, i.e., send
the given message to all nodes within the number of hops. 
</p>

</div>

<div class="heading3">8.1.4. Send Message By ID Interface</div><div class="subsection">

<pre class="code" id="interface_SendMsgByID">interface <span class="nesc_self">SendMsgByID</span> {
    /**
    Send a message out &lt;p&gt;
    @param address The ID of a remote mote
    @param length The length of the message
    @param msg The array of bytes need to send out
    @return SUCCESS if successful
    */
    command result_t send(
        uint16_t address,
        uint8_t length,
        char* msg 
    );
    /**
    Send message done signal &lt;p&gt;
    @param msg The message just sent out
    @param success If the send is done successfully
    */
    event result_t sendDone(
        char* msg,
        result_t success 
    );
}</pre>

<p> This is the simplest interface where node ID/address is specified for
destination. 
</p>

</div>


<div class="heading3">8.1.5. Send Message By Geographical Location Interface</div><div class="subsection">

<pre class="code" id="interface_SendMsgByGeo">interface <span class="nesc_self">SendMsgByGeo</span> {
    /**
    Send a message out to location( s )&lt;p&gt;
    @param location The pointer to a location structure representing
    a remote mote or motes
    @param length The length of the message
    @param msg The array of bytes need to send out
    @return SUCCESS if successful
    */
    command result_t send(
        <a href="#typedef_location_t">location_t</a> *location,
        uint8_t length,
        char* msg 
    );
    /**
    Send message done signal &lt;p&gt;
    @param msg The message just sent out
    @param success If the send is done successfully
    */
    event result_t sendDone(
        char* msg,
        result_t success 
    );
}</pre>

<p> This interface is for sending an array of bytes to one or all nodes defined
by geographical locations. Locations are described by 
</p>

<pre class="code" id="typedef_location_t">typedef struct {
    routing_t type; //one or all
    int16_t xCenter;
    int16_t yCenter;
    uint16_t range;
} <span class="nesc_self">location_t</span>;
</pre>

<p> The same interface can be used for position-based as well as
direction-based locations. For direction-based routing, x and y are interpreted
as directions. 
</p>

</div>

<div class="heading3">8.1.6. Send Message By Constraints Interface</div><div class="subsection">

<pre class="code" id="interface_SendMsgByCBR">interface <span class="nesc_self">SendMsgByCBR</span> {
    /**
    Send a message out to a remote motes satisfying a set of constraints
    while choosing a route that is optimal and satisfying route constraints &lt;p&gt;
    @param type one or all
    @param dest destination constraints
    @param rout route constraints
    @param objs objectives
    @param length message length
    @param msg array of bytes need to send out
    @return SUCCESS if successful
    */
    command result_t send(
        routing_t type,
        <a href="#typedef_constraints_t">constraints_t</a> *dest,
        <a href="#typedef_constraints_t">constraints_t</a> *rout,
        <a href="#typedef_objectives_t">objectives_t</a> *objs,
        uint8_t length,
        char* msg 
    );
    /**
    Send message done signal &lt;p&gt;
    @param msg The message just sent out
    @param success If the send is done successfully
    */
    event result_t sendDone(
        char* msg,
        result_t success 
    );
}</pre>

<p> In this interface, destinations are specified by constraints, each of which
is a range of attribute values. Attributes can be constant (ID, energy cost,
etc.) or be variables (sensor readings, battery level, time, etc). 
</p>

<p> The attribute interface in TinyOS-1.x will be used. In addition to
destinations, this interface can also specify route constraints and objectives,
where objectives are represented as minimizing or maximizing some attribute
values over the overall routing path. The types of constraints and objectives
are defined as follows. 
</p>

<pre class="code" id="typedef_constraint_t">typedef struct {
    uint8_t id; //attribute id
    int16_t lower;
    int16_t upper;
} <span class="nesc_self">constraint_t</span>;</pre>

<pre class="code" id="typedef_objective_t">typedef struct {
    uint8_t id; //attribute id
    uint8_t type; //maximize or minimize
} <span class="nesc_self">objective_t</span>;</pre>

<pre class="code" id="typedef_constraints_t">typedef struct {
    <a href="#typedef_constraint_t">constraint_t</a> *cons;
    uint8_t num;
} <span class="nesc_self">constraints_t</span>;</pre>

<pre class="code" id="typedef_objectives_t">typedef struct {
    <a href="#typedef_objective_t">objective_t</a> *objs;
    uint8_t num;
} <span class="nesc_self">objectives_t</span>;</pre>

</div>

<div class="heading3">8.1.7. Local Lookup Interface</div><div class="subsection">

<pre class="code" id="interface_LocalLookup">interface <span class="nesc_self">LocalLookup</span> {
    /**
    lookup remote attributes by name&lt;p&gt;
    @param address The ID of the remote mote
    @param name The name of the attribute
    @param result The result of the lookup
    @return SUCCESS if attribute exist otherwise FAIL
    */
    command result_t lookupByName(
        uint16_t address,
        char *name,
        char *result 
    );
    /**
    lookup remote attributes by attribute ID&lt;p&gt;
    @param address The ID of the remote mote
    @param id The id of the attribute
    @param result The result of the lookup
    @return SUCCESS if attribute exist otherwise FAIL
    */
    command result_t lookupByID(
        uint16_t address,
        uint8_t id,
        char *result 
    );
}</pre>

<p> Some routing components may be able to provide some local information for
remote nodes, such as the estimated number of hops, etc. This interface
provides a generic way of accessing such information, and assuming such
information would be stored in the form of attributes (provided by the
attribute interface in TinyOS-1.x) 
</p>

</div>

</div>

<div class="heading2">8.2. Component Implementation and Usage of the Above Interface</div><div class="subsection">

<p> Given the above set of interfaces, there will be the component
implementations by various groups participating in routing. One can implement a
single module that provides <i>all</i> the interfaces, or implement a set of
modules, each of which provide a subset of interfaces. Applications should be
able to switch from one set of implementations to another set of
implementations.  Implementations from different groups are not required to be
compatible to be compiled and linked into one application, beyond the
compatibility of the common interface. Here we just gave one example of the
skeleton of the implementation. Note that <span class="codefrag"><a href="#interface_SendRoutingMsg">SendRoutingMsg</a></span> is a parameterized
interface with <span class="codefrag">type</span> specified as: 
</p>

<pre class="code" id="typedef_routing_service_t">typedef enum {
    tSEND_BY_BROADCAST = 0,
    tSEND_BY_ID = 1,
    tSEND_BY_LOCATION = 2,
    tSEND_BY_DIRECTION = 3,
    tSEND_BY_CBR = 4
} <span class="nesc_self">routing_service_t</span>;</pre>


<pre class="code" id="module_ParcRoutingM">module <span class="nesc_self">ParcRoutingM</span> {
    provides {
        interface <a href="#interface_SendMsgByID">SendMsgByID</a>;
        interface <a href="#interface_SendMsgByGeo">SendMsgByGeo</a> as SendMsgByLoc;
        interface <a href="#interface_SendMsgByGeo">SendMsgByGeo</a> as SendMsgByDir;
        interface <a href="#interface_SendMsgByBct">SendMsgByBct</a>;
        interface <a href="#interface_SendMsgByCBR">SendMsgByCBR</a>;
        interface <a href="#interface_SendRoutingMsg">SendRoutingMsg</a>[uint8_t type];
        interface <a href="#interface_ReceiveRoutingMsg">ReceiveRoutingMsg</a>;
        interface <a href="#interface_GetRoutingMsgSource">GetRoutingMsgSource</a>;
        interface <a href="#interface_LocalLookup">LocalLookup</a>;
        interface StdControl;
    } uses {
        interface Leds;
        interface SendMsg as SendMsgGenericComm;
        interface ReceiveMsg as ReceiveMsgGenericComm;
        interface StdControl as StdControlGenericComm;
    }
}</pre>

</div>

</div>



<div class="heading1">9. Proposal for Time-Triggered Function (TTF) Support in Coordinator Component in TinyOS (U.C.Irvine)</div><div class="subsection">

<div class="heading2">9.1. Requirement</div><div class="subsection">

<p> Three types of functions will be supported in the <span class="codefrag"><a href="#interface_TTF_Coordinator">TTF_Coordinator</a></span>
component. 
</p>

<ol>
<li> Time-triggered function (TTF): A TTF can be described as, "From GlobalTime
= T1 to T2, do a task TTF every P time-units (iteration-interval) by the GCT of
D" where GCT denotes guaranteed completion time. 
</li>
<li> Service function (SvF): A SvF should be started at the earliest convenient
time (when a TTF initiated earlier is not in execution) and completed within
the maximum execution duration (MED) of D after the invocation (i.e., one -way
non-blocking request for execution of the SvF) occurs. The notion of a SvF is
similar to that of a task in the current TinyOS if the MED for a task can be
specified and the task can be invoked from other components. 
</li>
<li> Conventional utility function to which a blocking-call can be made from
within a TTF or a SvF. 
</li>
</ol>

</div>

<div class="heading2">9.2. Assumption</div><div class="subsection">

<p> Clocks are well synchronized among motes. 
</p>

</div>

<div class="heading2">9.3. Interface</div><div class="subsection">

<pre class="code" id="module_Coordinator">module <span class="nesc_self">Coordinator</span> {
    provides {
        interface <a href="#interface_TTF_Coordinator">TTF_Coordinator</a>;
    } uses {
    }
}</pre>

<pre class="code" id="interface_TTF_Coordinator">interface <span class="nesc_self">TTF_Coordinator</span> {
    /* to register a TT function with the coordinator */
    command <a href="#typedef_INDEX">INDEX</a> RegisterTTF(
        <a href="#typedef_TTFRequest">TTFRequest</a> * 
    );
    /* to invoke a service function */
    command void InvokeSvF(
        <a href="#typedef_SvFRequest">SvFRequest</a> * 
    );
    /* to update t he execution schedule based on existing registered TTFs */
    command void UpdateExecSchedule();
    /* to dispatch next ready function in the execution engine */
    command FuncType* DispatchNextFunc();
    /* to retrieve a timing error report */
    command <a href="#typedef_TimingErrorRept">TimingErrorRept</a> * RetrieveNextErrorRept();
}</pre>

<div align=center><img src="servicecoordination_fig1.png"></div>

<p> <span class="codefrag"><a href="#interface_TTF_Coordinator">TTF_Coordinator</a></span> component contains data structures which maintain
timing requirements for TT functions, the execution schedule, and possible
error records, and provides several APIs for manipulat ion of those data
structures.  Application designers will provide bodies of Time -triggered (TT)
functions in application components and will register them to
<span class="codefrag"><a href="#interface_TTF_Coordinator">TTF_Coordinator</a></span> along with relevant timing requirements and interrupt
enabling/disabling options.  <span class="codefrag"><a href="#interface_TTF_Coordinator">TTF_Coordinator</a></span> is responsible for maintaining
the execution schedule by reflecting the timing requirements of registered TTFs
and the SvF requests generated.  The function of main() will dispatch TTFs and
SvFs according to the Execution Schedule and execute them with interrupts
enabled and disabled as specified.  Possible error conditions, such as deadline
violation, can be detected/reported either by <span class="codefrag"><a href="#interface_TTF_Coordinator">TTF_Coordinator</a></span> or by main(),
and error records will be stored in <span class="codefrag"><a href="#interface_TTF_Coordinator">TTF_Coordinator</a></span>.  Application
components may retrieve the error records later and take appropriate actions.
</p>

</div>

<div class="heading2">9.4. Appendix: Basic Data and Function Types</div><div class="subsection">

<pre class="code">/* function pointer type for all TTFs and SvFs */
typedef void( *FuncPtr )( void* );
</pre>

<pre class="code" id="typedef_INDEX">/* an index to a registered TT function, used for future unregistration */
typedef int <span class="nesc_self">INDEX</span>;</pre>

<pre class="code" id="typedef_MicroSec">typedef int <span class="nesc_self">MicroSec</span>;</pre>

<pre class="code" id="typedef_ERR_CODE">/* indicating the type of execution errors, such as deadline violation */
typedef int <span class="nesc_self">ERR_CODE</span>;</pre>

<pre class="code" id="typedef_AAC">typedef struct {
    /*the time when a TT function will be ready to be scheduled */
    <a href="#typedef_MicroSec">MicroSec</a> LoopStartTime;
    /* the time when a TT function will be deleted from the TT scheduler */
    <a href="#typedef_MicroSec">MicroSec</a> LoopEndTime;
    /*LoopStartTime+( i-1 )*IterationInterval is the time the i-th TT function will be scheduled /
    executed */
    <a href="#typedef_MicroSec">MicroSec</a> IterationInterval;
    /*The earliest time at which a TT function may start in each cycle */
    <a href="#typedef_MicroSec">MicroSec</a> EST;
    /*The latest time at which a TT function may star */
    <a href="#typedef_MicroSec">MicroSec</a> LST;
    /*LoopStartTime +( i-1 )*IterationInterval +GCT is the time by which the i-th TT function
    should finish its execution */
    <a href="#typedef_MicroSec">MicroSec</a> GCT;
} <span class="nesc_self">AAC</span>;</pre>

<pre class="code" id="typedef_TTFRequest">typedef struct {
    /* function pointer to TT function */
    TTFunc ptr_to_ttf;
    /* input parameters for TT function */
    void * parameter;
    /* timing requirements */
    <a href="#typedef_AAC">AAC</a> aac;
    /* indicating whether enabling/disabling certain interrupts during a TTF execution */
    int interrupt_vector;
} <span class="nesc_self">TTFRequest</span>;</pre>

<pre class="code" id="typedef_SvFRequest">typedef struct {
    /* function pointer to SvF */
    TTFunc ptr_to_svf;
    /* input parameters for SvF */
    void * parameter;
    /* timing requirements */
    <a href="#typedef_MicroSec">MicroSec</a> MED;
    /* indicating whether enabling/disabling certain interrupts during a SvF execution */
    int interrupt_vector;
} <span class="nesc_self">SvFRequest</span>;</pre>

<pre class="code" id="typedef_TimingErrorRept">typedef struct {
    /* indicating the type of the error detected, e.g., deadline violation */
    <a href="#typedef_ERR_CODE">ERR_CODE</a> err_code;
    /* indicating the reporter of the error, e.g., main()or timer interrupt handler ? */
    int reporter_id;
    /* indicating the time of error detection */
    <a href="#typedef_MicroSec">MicroSec</a> timestamp;
} <span class="nesc_self">TimingErrorRept</span>;</pre>

<pre class="code" id="typedef_FuncInfo">typedef struct {
    /* indicating whether it is a TTF or a SvF */
    int func_type;
    /* function pointer to a TTF or a SvF */
    FuncPtr ptr_to_func;
    /* pointer to the input parameter of a TTF or a SvF */
    void * parameter;
    /* start time window of a TTF */
    <a href="#typedef_MicroSec">MicroSec</a> EST,
    LST;
    /* for a TTF, it represents GCT; for a SvF it represents MED */
    <a href="#typedef_MicroSec">MicroSec</a> GCT_or_MED;
    / * interrupt enabling/disabling options */
    int interrupt_vector;
} <span class="nesc_self">FuncInfo</span>;</pre>

</div>

</div>




<div class="heading1">10. TimeSync</div><div class="subsection">

<p> Prepared 17 October 2002 by Ted Herman, University of Iowa (OSU group).
</p>

<p> The pursuer-evader scenarios for the NEST Challenge, including near-term
experiments, the midterm demo, and later demonstrations, require that motes
have a synchronized time-base. Time synchronization is needed for mote location
determination (localization), position and velocity estimation of evaders, and
real-time calculations for pursuer strategies. These several needs for time
synchronization have slightly different requirements for accuracy and tolerate
differing interfaces for how the time bases of distinct motes can be compared.
Accordingly, we suggest an API with various time services.  
</p>

<p> Accurate localization may require time synchronization within about 10
microseconds; evader velocity estimation could be calculated to sufficient
accuracy with time synchronized to within about 300 microseconds.  For
localization, it may be that differential calculations between pairs of motes
separated by a few meters is sufficient; for the planning of multiple pursuers,
a real-time calculation involving distant motes (tens of meters) may be needed.
</p>

<p> Time synchronization requires communication; localization requires time
synchronization; the speci- fication of communication services proposed by UVA
(Routing, Estimation, and Group Management APIs) depends on localization. These
dependencies need not be circular, since one of the communication services
(<span class="codefrag">SendLocal</span>) is little more than a TOS local broadcast. Nevertheless, we prefer
to use some "communication services" outside of the current set of proposed
interfaces; these are documented below (they could well be implemented within
the TimeSync component, but we have a hunch that they may be useful elsewhere).
</p>

<p> Note: UVA looked at these communication services and is agreeable to
considering some support for them in the routing component; we'll wait until
specifications are finalized and we also have more precise ideas about
implementation to nail down these communication service specifications. 
</p>

<div class="heading2">10.1. NesC Prototype for TimeSync</div><div class="subsection">

<pre class="code" id="module_PrototypeTimeSyncM">module <span class="nesc_self">PrototypeTimeSyncM</span> {
    provides {
        interface <a href="#interface_Time">Time</a>;
    } uses {
        interface bdNeighbors;
        interface receiveMsg as ReceiveStampedMsg;
        interface sendLocal as sendNeighbors;
        interface sendByID;
    }
}</pre>

<div class="heading3">10.1.1. Interface: Time</div><div class="subsection">

<p> Perhaps not the best choice, we bundle the commands into one interface (we
could change this later). 
</p>

<pre class="code" id="interface_Time">interface <span class="nesc_self">Time</span> {
    command result_t getLocalTime(
        <a href="#typedef_time_t">time_t</a>* time 
    );
    command result_t getGlobalTime(
        <a href="#typedef_time_t">time_t</a>* time 
    );
    command result_t xlatTime(
        <a href="#typedef_time_t">time_t</a>* ourtime,
        mote_id m,
        <a href="#typedef_time_t">time_t</a>* othertime 
    );
}</pre>

<p> <span class="codefrag">getLocalTime</span> is used to obtain the high-accuracy form of time, which has a
local time-base.  Think of it intuitively as every mote having its own "time
zone". Such time is consistent for local real-time calculations. We imagine
that this command fails if the clocks have not yet been synchronized (eg, the
<span class="codefrag">getLocalTime</span> command is invoked too early in the initialization phase of system
startup). 
</p>

<p> <span class="codefrag">xlatTime</span> is used to convert local time to the time-base of some other mote
in the near vicinity (as mentioned above, this has to do with having a beacon
in common to the two motes). There are two failure modes for this command: it
fails if invoked before TimeSync initialization is completed; and it fails if
attempting a conversion outside of common beacon vicinity (these should be
distinct failure indications). Should applications need high-accuracy
conversion between <i>arbitrary</i> motes -- not residing in a common beacon area --
we can also imagine adding another command for such a conversion. However, this
would be a more expensive call, and it would be asynchronous (only later
delivering the result via an event). 
</p>

<p> <span class="codefrag">getGlobalTime</span> obtains the lower accuracy form of time, which is common
(plus or minus an error tolerance) to all motes in the system. Again, this
command fails if invoked too early in system startup. 
</p>

<p> Robert Szewczyk suggest that we should use 48 bit counters (at the
granularity of 32 KHz, or 31.25 microsec) for planning beyond the challenge to
other applications. 
</p>

<pre class="code" id="typedef_time_t">typedef uint48_t <span class="nesc_self">time_t</span>;</pre>

<p> We don't yet have a spec for the message format(s), frame definitions and
other things internal. 
</p>

</div>

<div class="heading3">10.1.2. Notes on Interfaces Used</div><div class="subsection">

<ul>

<li> The command <span class="codefrag">bdNeighbors</span> returns a pointer to a list of up to <i>k</i> mote
identifiers, where <i>k</i> is the assumed upper bound on a "neighborhood" size
(more about this shortly). Each item in the list is the identifier of a mote to
which the invoker has a direct, bidirectional link (that is, if <i>i</i> invokes and
<i>j</i> is in the resulting list, then <i>i</i> and <i>j</i> can both use <span class="codefrag">sendLocal</span> to
transmit to each other). 
</li>

<li> The event <span class="codefrag">receiveMsg</span>, documented in the routing component description,
carries a pointer to a message with "TimeSync" as its type. Presumably, the
routing component also supplies a "register" command interface that the
TimeSync component invokes as part of initialization (so that the routing
component has knowledge of the TimeSync message type -- or was it intended to
resolve this at compile/link time?). 
</li>

<li> The command <span class="codefrag">sendLocal</span> is documented in the routing component. 
</li>

<li> The command <span class="codefrag">sendByID</span> is needed so that motes in the local neighborhood
of a beacon (a concept internal to the TimeSync component) can address each
other, in a message send primitive, by identifier -- in view of the basic need
for TimeSync before locations are determined, we need some such primitive. For
the type of synchronization algorithm developed by UCLA, this <span class="codefrag">sendByID</span> only
transmits messages that travel two hops: from a mote, to a beacon, and then to
another mote within the beacon's neighborhood.
</li>

</div>

</div>

</div>



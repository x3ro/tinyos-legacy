function [E2P,evaders] = dynamic_assignment(t,toptrack)

% Copyright (c) 2004 Songhwai Oh and Luca Schenato 

global gvs

evaders = []; 
Ne = 0;
if ~isempty(toptrack)  %check if there is at least one evader
    vtrack = [];
    for k=1:size(gvs.record.trackinfo.track,2)
        if length(find(gvs.record.trackinfo.track(:,k)>0))>3
            vtrack = [vtrack; k];
        end
    end
    Ne = length(vtrack);  % estimated number of evaders present on SN
end

if Ne>0
    evaders.Vx = zeros(Ne,1);
    evaders.Vy = zeros(Ne,1);
    evaders.Px = zeros(Ne,1);
    evaders.Py = zeros(Ne,1);
    for p=1:Ne  
        list = find(toptrack.pos{vtrack(p)}(1,:)~=0);
        index1 = list(end);
        index2 = length(toptrack.pos{vtrack(p)}(1,:));
        % get position and velocity generated by the multiple target tracking (MTT) Module 
        evaders.Vx(p) = toptrack.pos{vtrack(p)}(3,index1);  
        evaders.Vy(p) = toptrack.pos{vtrack(p)}(4,index1);
        % this propagate forward estimated position of evader if there was packet delay
        evaders.Px(p) = toptrack.pos{vtrack(p)}(1,index1)+evaders.Vx(p)*(index2-index1); 
        evaders.Py(p) = toptrack.pos{vtrack(p)}(2,index1)+evaders.Vy(p)*(index2-index1);
    end
    
    T2cap = [];
    for p=1:Ne
        for k=1:gvs.peg.Np
            dPx = evaders.Px(p)-gvs.peg.Px(k,t-1);    % distance error from pursuer k and evader p along x
            dPy = evaders.Py(p)-gvs.peg.Py(k,t-1);    % distance error along y
            dVx = evaders.Vx(p)-gvs.peg.Vx(k,t-1);    % velocity error along x
            dVy = evaders.Vy(p)-gvs.peg.Vy(k,t-1);    % velocity error along y
            Tx = time2capture(dPx,dVx,gvs.peg.U);   % time to capture along x direction    
            Ty = time2capture(dPy,dVy,gvs.peg.U);   % time to capture along y direction
            Tcap = max(Tx,Ty);
            T2cap(k,p) = Tcap;  % cost matrix (time-to-capture) from every evader to every pursuer
        end
    end
    [P2E E2P]= bottleneckAssigM2N(T2cap);   % computes the assigment given the time-to-capture matrix T2cap
    
    for k=1:gvs.peg.Np
        if P2E(k)==0   % if pursuer is not assigned to any evader, do nothing 
            gvs.peg.ux(k,t) = 0;
            gvs.peg.uy(k,t) = 0;
        else
            % if pursuer is assigned to an evader, calculate optimal feedback based on relative distance and velocity 
            dPx = evaders.Px(P2E(k))-gvs.peg.Px(k,t-1); 
            dPy = evaders.Py(P2E(k))-gvs.peg.Py(k,t-1);
            dVx = evaders.Vx(P2E(k))-gvs.peg.Vx(k,t-1);
            dVy = evaders.Vy(P2E(k))-gvs.peg.Vy(k,t-1);
            
            gvs.peg.ux(k,t) = feedback3(dPx,dVx,gvs.peg.U,gvs.peg.dt);                                          
            gvs.peg.uy(k,t) = feedback3(dPy,dVy,gvs.peg.U,gvs.peg.dt);
        end
    end
else  % if no evader is detected pursuers do not move
    for k=1:gvs.peg.Np
        gvs.peg.ux(k,t) = 0;
        gvs.peg.uy(k,t) = 0;
    end
    E2P = [];
end

%%% pursuer motion given the input calculated above
[gvs.peg.Px(:,t) gvs.peg.Vx(:,t)] = move(gvs.peg.Px(:,t-1),gvs.peg.Vx(:,t-1),gvs.peg.dt,gvs.peg.ux(:,t));   
[gvs.peg.Py(:,t) gvs.peg.Vy(:,t)] = move(gvs.peg.Py(:,t-1),gvs.peg.Vy(:,t-1),gvs.peg.dt,gvs.peg.uy(:,t)); 

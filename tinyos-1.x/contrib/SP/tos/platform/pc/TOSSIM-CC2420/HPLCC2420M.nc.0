// $Id: HPLCC2420M.nc.0,v 1.1 2006/04/14 00:15:38 binetude Exp $

/*									tab:4
 * "Copyright (c) 2000-2003 The Regents of the University  of California.  
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 * 
 * IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF
 * CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
 *
 * Copyright (c) 2002-2003 Intel Corporation
 * All rights reserved.
 *
 * This file is distributed under the terms in the attached INTEL-LICENSE     
 * file. If you do not find these files, copies can be found by writing to
 * Intel Research Berkeley, 2150 Shattuck Avenue, Suite 1300, Berkeley, CA, 
 * 94704.  Attention:  Intel License Inquiry.
 */

/*
 * @author Joe Polastre, Yang Zhang
 *
 * Authors: Joe Polastre, Yang Zhang
 * Date last modified:  $Revision: 1.1 $
 *
 */

// NOTES
// Currently, an ack is always being sent, since autoack is always enabled in
// CC2420Lib.

module HPLCC2420M {
  provides {
    interface StdControl;
    interface HPLCC2420;
    interface HPLCC2420RAM;
    interface HPLCC2420FIFO;
    interface HPLCC2420Interrupt as FIFOP;
    interface HPLCC2420Interrupt as FIFO;
    interface HPLCC2420Interrupt as CCA;
    interface HPLCC2420Capture as SFD;
  }
  uses {
    interface PowerState;
  }
}

implementation
{

  // TODO try making all the events instantaneous instead of posted?

  // Container for structure for a packet, along with various metadata.
  typedef struct FrameData {
    uint8_t length; // The true, full length of frame.
    uint16_t sourceId;
    uint8_t* frame;
    double rssi;
    double lqi;

    // Set by the recipient; whether the packet currently being received
    // has the correct address. This is the result of the address recognition
    // routine.
    bool isDestAddrCorrect;

    // Set by the recipient; whether the packet's length field is corrupt,
    // due to interference with concurrent radio signals.
    bool wasLengthCorrupt;
  } FrameData;

  // Neighbor data. A mote is a neighbor for the currently transmitting frame if it
  // will be able to hear the frame.
  typedef struct Neighbor {
    bool isNeighbor;
    double rssi;
    double lqi;
  } Neighbor;

  // Generic transmission data to identify the source.
  typedef struct SourceData {
    uint16_t sourceId;
    double rssi;
  } SourceData;

  // TODO change these all to const's.

  // TODO these really belong in the CC2420Const.h
#define CC2420_IOCFG1_CCAMUX_START CC2420_IOCFG1_CCAMUX
#define CC2420_IOCFG1_CCAMUX_END 4
#define CC2420_IOCFG0_FIFOTHR_START CC2420_IOCFG0_FIFOTHR
#define CC2420_IOCFG0_FIFOTHR_END 6
#define CC2420_RSSI_CCA_THRESH_START CC2420_RSSI_CCA_THRESH
#define CC2420_RSSI_CCA_THRESH_END 15
#define CC2420_MDMCTRL0_CCAMODE_START CC2420_MDMCTRL0_CCAMODE
#define CC2420_MDMCTRL0_CCAMODE_END 7

  // The number of radio configuration registers.
#define REGISTER_COUNT 0x40
  // The size in bytes of the radio's RAM.
#define RAM_SIZE 368
  // The size in bytes of the radio's queues (both RX and TX are this length).
#define QUEUE_SIZE 128
  // The voltage regulator startup time, in seconds.
#define VREG_ON_LATENCY .0006
  // The crystal oscillator startup time, in seconds.
#define OSCILLATOR_ON_LATENCY .00086
  // The ACK TX calibration time, in symbols.
#define TX_ACK_CALIBRATE_LATENCY 12
  // The default FIFO threshold, in bytes.
#define DEFAULT_FIFO_THRESHOLD 64
  // The default CCA mode.
  // TODO is this correct?
#define DEFAULT_CCA_MODE 3
  // The default CCA threshold, in dB.
#define DEFAULT_CCA_THRESHOLD -77
  // The default TX calibration time, in symbols.
#define DEFAULT_TX_TURNAROUND 12
  // The RX calibration time, in symbols.
#define RX_CALIBRATION_LATENCY 12
  // The transmit bit rate, in bits per second.
#define TX_TRANSMIT_BIT_RATE 250000
  // The length of the preamble, in bytes.
#define PREAMBLE_LENGTH 4
  // The length of the SFD, in bytes.
#define SFD_LENGTH 1
  // The preamble and SFD transmit time, in seconds.
#define PREAMBLE_SFD_TRANSMIT_LATENCY calculateTransmitTime(PREAMBLE_LENGTH + SFD_LENGTH)
  // The preamble and SFD transmit time, in seconds.
#define ADDRESS_TRANSMIT_LATENCY calculateTransmitTime(LENGTH_BYTE_NUMBER)

  // TODO check that the latency is approx. correct (packet sniffer said .0009 seconds per packet).

  // TODO Should I be using these? (search for TODO on MANOR) What's the correct
  // size?
#define BIT_COUNT 16
#define CC2420_BIT_XOSC16M_PD 0
#define CC2420_BIT_BIAS_PD 1
  norace bool bits[BIT_COUNT];

  // TODO Can I get a real assert()? I grepped the other .nc files but didn't
  // find assert!
#define assert(w) ((!(w)) ? (*((int*) 0) = 1) : 0)
#define fail(reason) assert(FALSE && reason)

  // The radio state machine (see figure 23). The state is in register FSMSTATE.
#define STATE_VREG_OFF         100
#define STATE_VREG_POWERUP     101
#define STATE_IDLE               0
#define STATE_XOSC_POWERUP     102
#define STATE_XOSC_ON            1
#define STATE_RX_CALIBRATE       2 // 40
#define STATE_RX_SFD_SEARCH      3 // 4 5 6
#define STATE_RX_FRAME          16 // 40
#define STATE_RX_WAIT           14
#define STATE_TX_ACK_CALIBRATE  48
#define STATE_TX_ACK_PREAMBLE   49 // 50 51
#define STATE_TX_ACK            52 // 53 54
#define STATE_TX_CALIBRATE      32
#define STATE_TX_PREAMBLE       34 // 35 36
#define STATE_TX_FRAME          37 // 38 39
#define MAX_REAL_STATE         100 // anything > 100 has no state ID
  norace uint8_t radioState = STATE_VREG_OFF;

  // This is a hack so that we know if the radio is on.
  // It's needed because TOSSIM doesn't let us initialize our fields
  // until the mote boots.
  // However, states are just static variables in app.c, so they're
  // guaranteed to be zero; hasInitialized will always start off as FALSE.
  norace bool hasInitialized = FALSE;

  // The configuration registers on the chip.
  norace uint16_t registers[REGISTER_COUNT];
  // The contents of the memory, cleared every time the system is reset.
  norace uint8_t ram[RAM_SIZE];
  // A circular buffer which holds the messages that have arrived.
  norace uint8_t rxQueue[QUEUE_SIZE];
  // Byte offset specifying the first empty byte of rxQueue.
  norace uint8_t rxQueueEnd = 0;
  // A circular buffer which holds the message to be sent.
  norace uint8_t txQueue[QUEUE_SIZE];
  // Byte offset specifying the first empty byte of rxQueue.
  norace uint8_t txQueueEnd = 0;
  // The radio's status register.
  norace uint8_t statusReg = 0;

  // Storage for the frame being received.
  norace FrameData* receivingFrame = NULL;
  // Storage for the frame being transmitted.
  norace FrameData* transmittingFrame = NULL;
  // Whether motes will be able to hear the currently transmitting packet.
  norace Neighbor* neighbors = NULL;
  // Status of the channel.
  norace double channelEnergy = 0;
  norace uint8_t channelSourceCount = 0;
  norace bool isReceivingInterference = FALSE;

  // Ack-related state: this information must be saved across event time for
  // sending acks to work. (TODO this can be moved into the event.)
  // TODO how do we know who the ACK is being sent to? i guess it's not necessary
  // since we're broadcasting this, but then that means some nodes might misinterpret
  // the ack as responding to their own packets.
  norace uint8_t ackDsn = 0;
  // The hard-coded length of an ack, obtained by sniffing actual ack traffic.
#define ACK_LENGTH 5

  // Interrupt mechanisms.
  norace bool fifopEnabled   = FALSE;
  norace bool fifopLowToHigh = FALSE;
  norace bool fifoEnabled    = FALSE;
  norace bool fifoLowToHigh  = FALSE;
  norace bool ccaEnabled     = FALSE;
  norace bool ccaLowToHigh   = FALSE;
  norace bool sfdEnabled     = FALSE;
  norace bool sfdLowToHigh   = FALSE;

  // Storage for receiving and transmitting data.
  norace uint8_t* rxbuf     = NULL;
  norace uint8_t* txbuf     = NULL;
  norace uint8_t* rambuf    = NULL;
  norace uint8_t* rxrambuf  = NULL;
  norace uint8_t txlen      = 0;
  norace uint8_t rxlen      = 0;
  norace uint8_t ramlen     = 0;
  norace uint16_t ramaddr   = 0;
  norace uint8_t rxramlen   = 0;
  norace uint16_t rxramaddr = 0;

  // A data table that maps from distance to various stats for loss rate,
  // LQI, and RSSI.

#define TABLE_SIZE   24
#define TABLE_FIELDS 7

  static double table[TABLE_SIZE][TABLE_FIELDS] = {
    // { distance, recv mean, recv stddev, lqi mean, lqi stddev, rssi mean, rssi stddev }
    { 1.00e+00, 1.00e+00, 0.00e+00, 9.32e-01, 4.07e-03, -5.00e+00, 0.00e+00 },
    { 3.00e+00, 1.00e+00, 0.00e+00, 9.32e-01, 3.82e-03, -3.70e+01, 5.44e+00 },
    { 9.00e+00, 1.00e+00, 0.00e+00, 9.28e-01, 4.89e-03, -3.76e+01, 3.71e+00 },
    { 1.20e+01, 1.00e+00, 0.00e+00, 9.26e-01, 6.66e-03, -5.23e+01, 2.35e+00 },
    { 1.50e+01, 1.00e+00, 0.00e+00, 9.27e-01, 6.01e-03, -5.82e+01, 3.49e+00 },
    { 2.00e+01, 9.98e-01, 1.52e-06, 9.24e-01, 7.76e-03, -5.98e+01, 3.85e+00 },
    { 2.50e+01, 9.93e-01, 1.60e-02, 9.11e-01, 3.15e-02, -6.28e+01, 3.52e+00 },
    { 3.00e+01, 9.92e-01, 1.67e-02, 9.03e-01, 3.99e-02, -6.89e+01, 4.13e+00 },
    { 3.50e+01, 9.71e-01, 8.58e-02, 8.78e-01, 9.75e-02, -7.06e+01, 3.45e+00 },
    { 5.00e+01, 9.90e-01, 3.12e-02, 8.96e-01, 4.10e-02, -7.14e+01, 4.52e+00 },
    { 5.50e+01, 9.00e-01, 1.59e-01, 7.96e-01, 1.70e-01, -7.06e+01, 7.69e+00 },
    { 6.50e+01, 9.29e-01, 2.04e-01, 8.37e-01, 1.25e-01, -7.11e+01, 1.30e+01 },
    { 7.50e+01, 6.71e-01, 2.77e-01, 5.87e-01, 1.75e-01, -7.02e+01, 1.73e+01 },
    { 8.50e+01, 7.09e-01, 3.74e-01, 6.62e-01, 2.84e-01, -7.10e+01, 2.14e+01 },
    { 9.50e+01, 7.73e-01, 2.57e-01, 6.36e-01, 1.80e-01, -7.03e+01, 1.49e+01 },
    { 1.05e+02, 6.07e-01, 3.27e-01, 4.96e-01, 2.04e-01, -7.10e+01, 3.20e+01 },
    { 1.15e+02, 4.84e-01, 1.16e-01, 3.31e-01, 1.21e-01, -7.00e+01, 2.35e+01 },
    { 1.25e+02, 6.68e-01, 4.28e-01, 5.38e-01, 2.53e-01, -7.12e+01, 1.50e+00 },
    { 1.35e+02, 5.07e-01, 3.13e-01, 3.55e-01, 1.41e-01, -7.61e+01, 1.40e+01 },
    { 1.50e+02, 5.36e-01, 3.62e-01, 4.44e-01, 1.92e-01, -7.88e+01, 8.34e+00 },
    { 1.75e+02, 3.67e-01, 2.98e-01, 3.69e-01, 1.56e-01, -8.00e+01, 3.43e+00 },
    { 1.90e+02, 2.50e-01, 1.35e-01, 2.77e-01, 1.09e-01, -8.02e+01, 7.92e+00 },
    { 2.00e+02, 1.24e-01, 2.67e-01, 1.47e-01, 3.37e-02, -8.20e+01, 1.40e+01 },
    { 2.25e+02, 0.00e+00, 0.00e+00, 0.00e+00, 0.00e+00, -8.60e+01, 2.02e+00 }
  };

  //
  // Temporary debug items.
  //

  bool dbgstate[1000];
  double dbgrssi[1000];
  void DBGSTATE(uint16_t moteId, bool isSending, double rssi) {
    assert(dbgstate[moteId] == !isSending);
    if (isSending == TRUE) {
      dbgrssi[moteId] = rssi;
    } else {
      assert( dbgrssi[moteId] == rssi );
    }
    dbgstate[moteId] = isSending;
  }

  //
  // Declarations.
  //

  void setCca();
  void clearCca();
  void setSfd();
  void clearSfd();
  void setFifo();
  void clearFifo();
  void setFifop();
  void clearFifop();
  bool isFifopInverted();
  void sendAck(uint8_t dest, uint8_t dsn);
  void initializeMetastate();
  void setState(uint8_t nextState);
  void handleVregOnEvent(event_t* ev, struct TOS_state* state);
  void createVregOnEvent();
  void setRegister(uint8_t reg, uint16_t value);
  void setRegisterBits(uint8_t reg, uint8_t start, uint8_t end, uint16_t value);
  uint16_t getRegisterBits(uint8_t reg, uint8_t start, uint8_t end);
  bool getRegisterBit(uint8_t reg, uint8_t bit);
  void updateNeighbors();
  Neighbor* getNeighbor(uint16_t moteId);
  FrameData* createFrame(uint16_t moteId);
  void setNeighbor(uint16_t moteId, bool isNeighbor, double lqi, double rssi);
  void removeChannelSource(double rssi, uint16_t source);
  void createTxCalibratedEvent();
  SourceData* createSourceData(uint8_t moteId);
  double getDecodedRssi(int8_t rssi);
  void createOscillatorOnEvent();
  int8_t getEncodedRssi(double rssi);
  int8_t getEncodedLqi(double lqi);
  void updateCca();
  bool getStatusReg(uint8_t bit);
  double fromDbm(double value);

  //
  // General utility functions.
  //

#define MAX_BUF 255
#define STR_LENGTH 200
  // activates or deactivates verbose packet-sending debug information
#define DEBUG_SENDING FALSE

  void* alloc(size_t size) {
    void* pointer = malloc(size);
    assert(pointer != NULL);
    return pointer;
  }

  // Convenience function for outputting debug information
  // TODO should i be using DBG_AM instead?
  void pp(const char *fmt, ...) {
    va_list argp;
    char str[MAX_BUF];
    char timeStr[128];

    va_start(argp, fmt);
    vsnprintf(str, MAX_BUF, fmt, argp);
    va_end(argp);

    printTime(timeStr, 128);
    dbg(DBG_PACKET, "HPLCC2420 (%s): %s\n", timeStr, str);
  }

  // Convenience function for outputting debug information.
  void p(const char *str) {
    pp("%s", str);
  }

  // Converts symbol periods to seconds.
  // 1 symbol period = 16 microsecond.
  double symbolsToSeconds(double syms) {
    return (syms * 16.0) / 1000000;
  }

  // Converts seconds to TinyOS units of time (ticks).
  // 1 second = 4,000,000 ticks.
  uint64_t secondsToTicks(double secs) {
    return (secs * 4000000.0);
  }

  // Converts symbol periods to TinyOS units of time (ticks).
  uint64_t symbolsToTicks(double syms) {
    return secondsToTicks(symbolsToSeconds(syms));
  }

  // Returns the time in seconds to transmit the given number of bytes.
  double calculateTransmitTime(uint8_t byteCount) {
    return ((double) byteCount * 8) / ((double) TX_TRANSMIT_BIT_RATE);
  }

  // Gets the MAC short address.
  uint16_t getMacAddr() {
    uint16_t addr = ((uint16_t) ram[CC2420_RAM_SHORTADR]);
    return fromLSB16(addr);
  }

  //
  // Packet-parsing functions.
  //

  // Gets the frame type.
  uint8_t getFrameType(TOS_MsgPtr msg) {
    return msg->fcfhi & 0x07;
  }

  // Checks if the frame type is valid.
  bool isValidFrameType(uint8_t type) {
    return type < 4;
  }

  // Gets the source PAN ID.
  // TODO I don't know how to find the source pan ID
  uint16_t getSrcPan(TOS_MsgPtr msg) {
    return 0;
  }

  // Gets the destination PAN ID.
  uint16_t getDestPan(TOS_MsgPtr msg) {
    return msg->destpan;
  }

  // Gets the destination short address.
  uint16_t getDestAddr(TOS_MsgPtr msg) {
    return msg->addr;
  }

  // Gets the MAC PAN ID.
  // TODO I don't know how to find the MAC pan ID
  uint16_t getMacPan(TOS_MsgPtr msg) {
    return 0;
  }

  // Performs the address recognition routine.
  bool isAddressCorrect(TOS_MsgPtr msg) {
    uint8_t frameType = getFrameType(msg);
//    if (!getRegisterBit(CC2420_MDMCTRL0, CC2420_MDMCTRL0_ADRDECODE)) {
//      return TRUE;
//    }
    if (!isValidFrameType(frameType)) {
      return FALSE;
    }
    if (frameType == CC2420_DEF_FCF_TYPE_BEACON &&
        !(getSrcPan(msg) == getMacPan(msg) || getMacPan(msg) == 0xFFFF)) {
      return FALSE;
    }
    if (!(getDestPan(msg) == getMacPan(msg) || getDestPan(msg) == 0xFFFF)) {
      return FALSE;
    }
    if (!(getDestAddr(msg) == getMacAddr() || getDestAddr(msg) == 0xFFFF)) {
      return FALSE;
    }
    // TODO If only source addressing fields are included in a data or MAC
    // command frame, the frame shall only be accepted if the device is a PAN
    // coordinator and the source PAN identifier matches macPANId.
    return TRUE;
  }

  // Sets the specified bits of a 16-bit integer.
  uint16_t setBits(uint16_t regValue, uint8_t start, uint8_t end, uint16_t value) {
    uint8_t mask;

    // Check for sanity.
    assert(start < 16 && end < 16 && start <= end);

    // Clear out the bits already there.
    mask = (1 << (end - start + 1)) - 1;
    regValue &= value;

    // Write in the new bits (shifted to the correct position).
    regValue |= value << start;
    return regValue;
  }

  // Gets the specified bits of a 16-bit integer.
  uint16_t getBits(uint16_t regValue, uint8_t start, uint8_t end) {
    uint8_t mask;

    // Check for sanity.
    assert(start < 16 && end < 16 && start <= end);

    // Mask out the bits we want, then shift it over.
    mask = (1 << (end - start + 1)) - 1;
    return ((regValue >> start) & mask);
  }

  // Gets the specified bit of a 16-bit integer.
  bool getBit(uint16_t regValue, uint8_t bit) {
    uint16_t value = getBits(regValue, bit, bit);
    assert(value < 2);
    return value == 1;
  }

  //
  // StdControl.
  //

  // Initializes the component.
  command result_t StdControl.init() {
    p("enter StdControl.init()");

    // Note: this is never freed.
    neighbors = (Neighbor*) alloc(sizeof(Neighbor) * tos_state.num_nodes);

    return SUCCESS;
  }

  // Starts the component.
  command result_t StdControl.start() {
    uint16_t i;

    p("enter StdControl.start()");

    initializeMetastate();

    // TODO this should be bound with VREN, somehow
    setState(STATE_VREG_POWERUP);
    // TODO note that TOSH_wait doesn't actually do anything!
    // so this timeout mechanism *will not* work
    //createVregOnEvent();
    // TODO this is a temporary workaround
    handleVregOnEvent(NULL, NULL);

    // Clear all pins.
    TOSH_CLR_CC_SFD_PIN();
    TOSH_CLR_RADIO_CCA_PIN();
    TOSH_CLR_CC_FIFO_PIN();
    TOSH_CLR_CC_FIFOP_PIN();

    // Reset the RAM.
    for (i = 0; i < RAM_SIZE; i++) {
      ram[i] = 0;
    }

    // Initialize neighbor table.
    for (i = 0; i < tos_state.num_nodes; i++) {
      setNeighbor(i, FALSE, 0, 0);
    }

    // Initialize register values (to their defaults).
    for (i = 0; i < REGISTER_COUNT; i++) {
      registers[i] = 0;
    }
    setRegisterBits(CC2420_RSSI, CC2420_RSSI_CCA_THRESH_START,
        CC2420_RSSI_CCA_THRESH_END, DEFAULT_CCA_THRESHOLD);
    setRegisterBits(CC2420_IOCFG0, CC2420_IOCFG0_FIFOTHR_START,
        CC2420_IOCFG0_FIFOTHR_END, DEFAULT_FIFO_THRESHOLD);
    setRegisterBits(CC2420_MDMCTRL0, CC2420_MDMCTRL0_CCAMODE_START,
        CC2420_MDMCTRL0_CCAMODE_END, DEFAULT_CCA_MODE);
    statusReg = 0;

    // Initialize buffer markers and event pointers.
    rxQueueEnd     = 0;
    txQueueEnd     = 0;
    rxbuf          = NULL;
    txbuf          = NULL;
    rambuf         = NULL;
    rxrambuf       = NULL;
    txlen          = 0;
    rxlen          = 0;
    ramlen         = 0;
    ramaddr        = 0;
    rxramlen       = 0;
    rxramaddr      = 0;;

    // Initialize interrupt mechanism state.
    fifopEnabled   = FALSE;
    fifopLowToHigh = FALSE;
    fifoEnabled    = FALSE;
    fifoLowToHigh  = FALSE;
    ccaEnabled     = FALSE;
    ccaLowToHigh   = FALSE;
    sfdEnabled     = FALSE;
    sfdLowToHigh   = FALSE;

    // Initialize various state information.
    ackDsn                   = 0;
    receivingFrame           = NULL;
    transmittingFrame        = NULL;
    channelEnergy            = 0; // TODO find a better starting value?
    channelSourceCount       = 0;
    isReceivingInterference  = FALSE;

    return SUCCESS;
  }

  // Stops the component.
  command result_t StdControl.stop() { 
    p("enter StdControl.stop()");
    setState(STATE_VREG_OFF);
    return SUCCESS;
  }

  //
  // Radio state.
  //

  // Initializes state variables that do not correspond to states actually
  // in the radio chip.
  void initializeMetastate() {
    hasInitialized = TRUE;
    radioState = STATE_VREG_OFF;
  }

  // If the mote has not been turned on before, then we had better initialize the values!
  void checkInitialized() {
    if (!hasInitialized) {
      initializeMetastate();
    }
  }

  // Gets the state of the system.
  uint8_t getState() {
    return radioState;
  }

  // Gets the string representation of the specified state.
  char* getStateStr(uint8_t state) {
    char* stateStr = NULL;
    switch (state) {
      case STATE_VREG_OFF:
        stateStr = "STATE_VREG_OFF";
        break;
      case STATE_VREG_POWERUP:
        stateStr = "STATE_VREG_POWERUP";
        break;
      case STATE_IDLE:
        stateStr = "STATE_IDLE";
        break;
      case STATE_XOSC_POWERUP:
        stateStr = "STATE_XOSC_POWERUP";
        break;
      case STATE_XOSC_ON:
        stateStr = "STATE_XOSC_ON";
        break;
      case STATE_RX_CALIBRATE:
        stateStr = "STATE_RX_CALIBRATE";
        break;
      case STATE_RX_SFD_SEARCH:
        stateStr = "STATE_RX_SFD_SEARCH";
        break;
      case STATE_RX_FRAME:
        stateStr = "STATE_RX_FRAME";
        break;
      case STATE_RX_WAIT:
        stateStr = "STATE_RX_WAIT";
        break;
      case STATE_TX_ACK_CALIBRATE:
        stateStr = "STATE_TX_ACK_CALIBRATE";
        break;
      case STATE_TX_ACK_PREAMBLE:
        stateStr = "STATE_TX_ACK_PREAMBLE";
        break;
      case STATE_TX_ACK:
        stateStr = "STATE_TX_ACK";
        break;
      case STATE_TX_CALIBRATE:
        stateStr = "STATE_TX_CALIBRATE";
        break;
      case STATE_TX_PREAMBLE:
        stateStr = "STATE_TX_PREAMBLE";
        break;
      case STATE_TX_FRAME:
        stateStr = "STATE_TX_FRAME";
        break;
      default:
        fail("not a valid state");
    }

    return stateStr;
  }

  // Update the state of the radio, stored in register FSMSTATE.
  void setState(uint8_t nextState) {
    // Check that the transition from the current state to the next one is
    // valid.
    switch (nextState) {
      case STATE_VREG_OFF:
        // TODO implement/fix
        fail("not allowed to go to this state...yet (can't turn me off!)");
        call PowerState.radioStop();
        break;
      case STATE_VREG_POWERUP:
        assert(radioState == STATE_VREG_OFF);
        call PowerState.radioStart();
        break;
      case STATE_IDLE:
        call PowerState.radioRFPower(0);
        break;
      case STATE_XOSC_POWERUP:
        assert(radioState == STATE_IDLE);
        call PowerState.radioRFPower(1);
        break;
      case STATE_XOSC_ON:
        assert(radioState != STATE_IDLE);
        break;
      case STATE_RX_CALIBRATE:
        // TODO so apparently, we can accept multiple (quick) calls to SRXON, right?
        // (see TuneManual, followed by RxMode, in lib)
        call PowerState.radioRFPower(2);
        assert(radioState == STATE_XOSC_ON ||
            radioState == STATE_RX_CALIBRATE ||
            radioState == STATE_TX_FRAME ||
            radioState == STATE_TX_ACK);
        break;
      case STATE_RX_SFD_SEARCH:
        // TODO so apparently, we can accept multiple (quick) calls to SRXON, right?
        // (see TuneManual, followed by RxMode, in lib)
        // TODO this is dangerous since we can have several overlapping calibration events!
        assert(radioState == STATE_RX_CALIBRATE ||
            radioState == STATE_RX_SFD_SEARCH ||
            radioState == STATE_RX_WAIT);
        break;
      case STATE_RX_FRAME:
        call PowerState.radioRxMode();
        assert(radioState == STATE_RX_SFD_SEARCH);
        break;
      case STATE_RX_WAIT:
        assert(radioState == STATE_RX_FRAME);
        break;
      case STATE_TX_ACK_CALIBRATE:
        call PowerState.radioTxMode();
        assert(radioState == STATE_RX_FRAME ||
            radioState == STATE_RX_SFD_SEARCH);
        break;
      case STATE_TX_ACK_PREAMBLE:
        assert(radioState == STATE_TX_ACK_CALIBRATE);
        break;
      case STATE_TX_ACK:
        assert(radioState == STATE_TX_ACK_PREAMBLE);
        break;
      case STATE_TX_CALIBRATE:
        call PowerState.radioTxMode();
        assert(radioState == STATE_TX_ACK ||
            radioState == STATE_RX_CALIBRATE ||
            radioState == STATE_RX_SFD_SEARCH ||
            radioState == STATE_RX_FRAME ||
            radioState == STATE_RX_WAIT);
        break;
      case STATE_TX_PREAMBLE:
        assert(radioState == STATE_TX_CALIBRATE);
        break;
      case STATE_TX_FRAME:
        assert(radioState == STATE_TX_PREAMBLE);
        break;
      default:
        fail("Not a valid state");
    }

    pp("setState( from %s to %s )", getStateStr(radioState), getStateStr(nextState));

    if (nextState < MAX_REAL_STATE) {
      registers[CC2420_FSMSTATE] = nextState;
    }
    radioState = nextState;
  }

  //
  // Registers.
  //

  // Verifies that the register ID is valid.
  void checkRegisterId(uint8_t reg) {
    assert(reg < 64);
  }

  // Gets the value (all bits) of a register.
  uint16_t getRegister(uint8_t reg) {
    checkRegisterId(reg);
    return registers[reg];
  }

  // Sets the value (all bits) of a register.
  void setRegister(uint8_t reg, uint16_t value) {
    uint16_t oldValue;
    checkRegisterId(reg);
    oldValue = registers[reg];
    registers[reg] = value;
    switch (reg) {
      case CC2420_IOCFG0:
        {
          // Check the polarity.
          bool wasInverted = getBit(oldValue, CC2420_IOCFG0_FIFOPPOL);
          bool isInverted = isFifopInverted();
          if (wasInverted != isInverted) {
            // Flip the pin.
            if (TOSH_READ_CC_FIFOP_PIN() == 0) {
              setFifop();
            } else {
              clearFifop();
            }
          }
          break;
        }
      case CC2420_IOCFG1:
        {
          // Check the function of the CCA pin.
          uint8_t ccaMux = getRegisterBits(CC2420_IOCFG1,
              CC2420_IOCFG1_CCAMUX_START, CC2420_IOCFG1_CCAMUX_END);
          switch (ccaMux) {
            case 0:
              updateCca();
              break;
            case 24:
              if (getStatusReg(CC2420_XOSC16M_STABLE)) {
                setCca();
              } else {
                clearCca();
              }
              break;
          }
          break;
        }
    }
  }

  // Sets the specified bits of a register between start and end, inclusive.
  void setRegisterBits(uint8_t reg, uint8_t start, uint8_t end, uint16_t value) {
    uint16_t regValue = getRegister(reg);
    regValue = setBits(regValue, start, end, value);
    setRegister(reg, regValue);
  }

  // Gets the specified bits of a register between start and end, inclusive.
  uint16_t getRegisterBits(uint8_t reg, uint8_t start, uint8_t end) {
    return getBits(getRegister(reg), start, end);
  }

  // Gets the specified bit of a register.
  bool getRegisterBit(uint8_t reg, uint8_t bit) {
    uint16_t value;
    checkRegisterId(reg);
    value = getRegisterBits(reg, bit, bit);
    assert(value < 2);
    return value == 1;
  }

  // Checks to see if the specified bit is a valid one in the status register.
  void checkStatusRegBit(uint8_t bit) {
    bool bitValid;
    switch (bit) {
      case CC2420_XOSC16M_STABLE:
      case CC2420_TX_UNDERFLOW:
      case CC2420_ENC_BUSY:
      case CC2420_TX_ACTIVE:
      case CC2420_LOCK:
      case CC2420_RSSI_VALID:
        bitValid = 1;
        break;
      default:
        bitValid = 0;
    }
    assert(bitValid);
  }

  // Gets the specified bit of the status register.
  bool getStatusReg(uint8_t bit) {
    checkStatusRegBit(bit);
    return statusReg & (1 << bit) ? TRUE : FALSE;
  }

  // Sets the specified bit of the status register.
  void setStatusReg(uint8_t bit, bool value) {
    checkStatusRegBit(bit);
    if (value) {
      statusReg |= (1 << bit);
    } else {
      statusReg &= ~(1 << bit);
    }
  }

  //
  // Clear channel assessment.
  //

  // Update the CCA pin, using the two procedures specified in the datasheet.
  void updateCca() {
    bool isChannelClear = FALSE;
    uint8_t ccaMux;
    uint8_t ccaMode = getRegisterBits(CC2420_MDMCTRL0,
        CC2420_MDMCTRL0_CCAMODE_START, CC2420_MDMCTRL0_CCAMODE_END);
    int8_t ccaThresholdEncoded = getRegisterBits(CC2420_RSSI, // TODO is this a valid cast?
        CC2420_RSSI_CCA_THRESH_START, CC2420_RSSI_CCA_THRESH_END);
    double ccaThreshold = fromDbm(getDecodedRssi(ccaThresholdEncoded));
    switch (ccaMode) {
      case 0:
        fail("reserved CCA mode.");
        break;
      case 1:
        isChannelClear = channelEnergy < ccaThreshold;
        break;
      case 2:
        // If there's only one source, then the data is valid.
        // Otherwise, then the data is not valid, so the channel is clear.
        isChannelClear = channelSourceCount != 1;
        break;
      case 3:
        isChannelClear = channelSourceCount != 1 && channelEnergy < ccaThreshold;
        break;
      default:
        fail("not a valid CCA mode.");
        break;
    }

    ccaMux = getRegisterBits(CC2420_IOCFG1,
        CC2420_IOCFG1_CCAMUX_START, CC2420_IOCFG1_CCAMUX_END);
    if (ccaMux == 0) {
      if (isChannelClear) {
        setCca();
      } else {
        clearCca();
      }
    }
  }

  // Converts from the value from dBm to mW.
  // Here are some example values, in the form (dBm: mW):
  // -86: 5e-5
  // -77: 1.42e-4
  // -5:  0.56234
  double fromDbm(double value) {
    return pow(10, value / 20);
  }

  // This adjusts the CCA observed by the current node by the given energy level.
  void removeChannelSource(double rssi, uint16_t source) {
    if (!(channelSourceCount != 0)) {
      dbg(DBG_USR3, "==0: source=%hd, count=%hd", channelSourceCount, source);
      exit(1);
    }
    channelSourceCount--;
    channelEnergy -= fromDbm(rssi);
    if (channelSourceCount == 0) {
      if (!(channelEnergy < 1e-10 &&
          channelEnergy > -1e-10)) {
        dbg(DBG_USR3, "!=0: count=%hd, energy=%f, source=%hd", channelSourceCount, channelEnergy, source);
        exit(1);
      }
      isReceivingInterference = FALSE;
      if (getState() != STATE_VREG_OFF) {
        clearSfd();
      }
    }
    {
      char timeStr[128];
      printTime(timeStr, 128);
      dbg(DBG_USR3, "%s removeChannelSource(): count=%hd, source=%hd, energy=%f\n", timeStr, channelSourceCount, source, channelEnergy);
    }
    if (getState() != STATE_VREG_OFF) {
      updateCca();
    }
  }

  // TODO is there any other situation in which the channel data could be invalidated, aside from multiple sources talking?
  // This adjusts the CCA observed by the current node by the given energy level.
  void addChannelSource(double rssi, uint16_t source) {
    channelSourceCount++;
    channelEnergy += fromDbm(rssi);
    if (channelSourceCount > 0) {
      if (!(channelSourceCount < 100)) {
        printf(">=100: %hd, %hd, %f, %hd", NODE_NUM, channelSourceCount, channelEnergy, source);
        exit(1);
      }
    }
    if (channelSourceCount > 1) {
      isReceivingInterference = TRUE;
    }
    {
      char timeStr[128];
      printTime(timeStr, 128);
      dbg(DBG_USR3, "%s addChannelSource(): count=%hd, source=%hd, energy=%f\n", timeStr, channelSourceCount, source, channelEnergy);
    }
    if (getState() != STATE_VREG_OFF) {
      updateCca();
    }
  }

  //
  // Packet loss.
  //

  // Accessor function.
  Neighbor* getNeighbor(uint16_t moteId) {
    return &neighbors[moteId];
  }

  // Accessor function.
  void setNeighbor(uint16_t moteId, bool isNeighbor, double lqi, double rssi) {
    neighbors[moteId].isNeighbor = isNeighbor;
    neighbors[moteId].lqi = lqi;
    neighbors[moteId].rssi = rssi;
  }

  // Determines whether the packet should be dropped, using the giant
  // table above to calculate the probability.
  bool canSend(int receiver, double* lqi, double* rssi) {
    static uint8_t DISTANCE     = 0;
    static uint8_t RECV_MEAN    = 1;
    static uint8_t RECV_STDDEV  = 2;
    static uint8_t LQI_MEAN     = 3;
    static uint8_t LQI_STDDEV   = 4;
    static uint8_t RSSI_MEAN    = 5;
    static uint8_t RSSI_STDDEV  = 6;

    static uint8_t ADC_LOCATION_X = 128;
    static uint8_t ADC_LOCATION_Y = 129;

    // Divide by SCALE, and multiply by mote scale width/height.
    // This was deduced from CoordinateTransformer.java,
    // (reflect/)SimObject.java, and LocationPlugin.java.
    uint16_t senderX = generic_adc_read(NODE_NUM, ADC_LOCATION_X, 0) / 65535.0 * 100;
    uint16_t senderY = generic_adc_read(NODE_NUM, ADC_LOCATION_Y, 0) / 65535.0 * 100;
    uint16_t receiverX = generic_adc_read(receiver, ADC_LOCATION_X, 0) / 65535.0 * 100;
    uint16_t receiverY = generic_adc_read(receiver, ADC_LOCATION_Y, 0) / 65535.0 * 100;

    double distance = sqrt(pow(senderX - receiverX, 2) + pow(senderY - receiverY, 2));

    double prob;
    double rval;
    bool shouldSend;

    // Look for the right distance in the table
    uint8_t table_index;
    for (table_index = 0; table_index < TABLE_SIZE; table_index++) {
      if (distance <= table[table_index][DISTANCE]) {
        break;
      }
    }
    if (table_index == TABLE_SIZE) {
      table_index--;
    }

    // Generate values for the LQI and RSSI.
    // TODO generate random values
    *lqi = table[table_index][LQI_MEAN];
    *rssi = table[table_index][RSSI_MEAN];

    prob = table[table_index][RECV_MEAN];
    rval = (rand()*1.0) / (RAND_MAX*1.0);
    shouldSend = rval <= prob;

    pp("canSend(to=%d): senderX = %d, senderY = %d, receiverX = %d, receiverY = %d, "
        "distance = %f, recv = %f, rval = %f, lqi = %f, rssi = %f, %s",
        receiver, senderX, senderY, receiverX, receiverY, distance, prob, rval,
        *lqi, *rssi, shouldSend ? "should send" : "should NOT send");

    return shouldSend;
  }

  // Update the neighbors list.
  void updateNeighbors() {
    uint16_t moteId;
    double lqi = 0;
    double rssi = 0;
    for (moteId = 0; moteId < tos_state.num_nodes; moteId++) {
      bool result = canSend(moteId, &lqi, &rssi);
      setNeighbor(moteId, result, lqi, rssi);
    }
  }

  // Converts the specified energy level (in dB) to its encoding in the packet.
  // The RSSI is going to be something between -5 dB and -90 dB.
  // Adding 45 centers this about 0 (from 40 to -45).
  int8_t getEncodedRssi(double rssi) {
    double value = rssi + 45;
    assert(value >= INT8_MIN && value <= INT8_MAX);
    return (int8_t) value;
  }

  // Converts the specified LQI value to its encoding in the packet.
  // The encoded range is from 106 to 65
  // This is actually a 7-bit value.
  int8_t getEncodedLqi(double lqi) {
    double value = (110 - 65) * lqi + 65;
    assert(value >= 0 && value < (UINT8_MAX >> 1));
    return (uint8_t) value;
  }

  // Converts the RSSI from its packet-encoded representation to dBm.
  double getDecodedRssi(int8_t rssi) {
    double value = rssi - 45;
    return value;
  }

//  //
//  // Finish-receive events.
//  //
//
//  // Finish-receive data.
//  typedef struct FinishReceiveEventData {
//    uint16_t src;
//    TOS_MsgPtr msg;
//  } FinishReceiveEventData;
//
//  // Handles finish-receive events by firing the appropriate pins, writing to
//  // the queue, and sending an ack.
//  void handleFinishReceiveEvent(event_t* ev, struct TOS_state* state) {
//    FinishReceiveEventData* data = (FinishReceiveEventData*) ev->data;
//    TOS_MsgPtr msg = data->msg;
//    uint8_t* arr = (uint8_t*) msg;
//    uint8_t length = msg->length + 1 + 2;
//    bool overflow = FALSE;
//
//    p("enter handleFinishReceiveEvent()");
//
//    if (DEBUG_SENDING) {
//      int i;
//      pp("in dump: [ ");
//      for (i = 0; i < length; i++) {
//        pp("%d ", (int) arr[i]);
//      }
//      pp("]");
//
//      {
//        int8_t rssi = ((int8_t*) arr)[length - 2]; // TODO is the casting good?
//        uint8_t lqi = arr[length - 1] & 0x7F; // remove CRC
//        pp("got rssi = %d, lqi = %d", (int) rssi, (int) lqi);
//      }
//
//      pp("mdmctrl0 = %d or %02x", getRegister(CC2420_MDMCTRL0), getRegister(CC2420_MDMCTRL0));
//      pp("arr[-1] = %d or %02x", arr[msg->length - 1], arr[msg->length - 1]);
//    }
//
//    if (getRegisterBit(CC2420_MDMCTRL0, CC2420_MDMCTRL0_AUTOCRC)) {
//      //arr[length - 1] |= (arr[length - 2] == 0 && arr[length - 1] == 0) << 7;
//      if (DEBUG_SENDING) {
//        pp("fcs = [ %d %d or %02x %02x ]",
//            arr[msg->length], arr[msg->length + 1],
//            arr[msg->length], arr[msg->length + 1]);
//        pp("arr[-1] = %d or %02x", arr[msg->length - 1], arr[msg->length - 1]);
//      }
//    }
//
//    // Note that nothing gets to happen between the SFD/CCA changes!
//    {
//      clearCca();
//      setSfd();
//
//      // Write to the RX FIFO.
//      if (rxQueueEnd + length > QUEUE_SIZE) {
//        clearFifo();
//        setFifop();
//        overflow = TRUE;
//      } else {
//        memcpy(rxQueue + rxQueueEnd, msg, length);
//        rxQueueEnd += length;
//      }
//
//      clearSfd();
//      setCca();
//    }
//
//    // Send an ack.
//    if (!overflow) {
//      // TODO is this right? it seems from figure 12 that i should be setting
//      // FIFOP instead of clearing it, but the stack never expects that.
//      clearFifop();
//
//      if (DEBUG_SENDING) {
//        pp("ack conditions: %d %d %d", (msg->fcfhi & CC2420_DEF_FCF_HI_ACK) != 0,
//            msg->addr == NODE_NUM,
//            ((arr[length - 1] >> 7) & 1) == 1);
//      }
//
//      if ((msg->fcfhi & CC2420_DEF_FCF_HI_ACK) != 0 &&
//          msg->addr == NODE_NUM &&
//          ((arr[length - 1] >> 7) & 1) == 1) {
//        // TODO don't send if there's a concurrent tranmission (would that be the right behavior? the docs don't say anything about what happens in this case)
//        // TODO i should really be sending this 12 symbols after the end of incoming frame...
//        if (getStatusReg(CC2420_TX_ACTIVE) == 0) {
//          sendAck(data->src, msg->dsn);
//        }
//      }
//    }
//
//    event_cleanup(ev);
//  }
//
//  // Cleans up finish-receive events.
//  void cleanupFinishReceiveEvent(event_t* ev) {
//    FinishReceiveEventData* data = (FinishReceiveEventData*) ev->data;
//    free(data->msg);
//    free(data);
//    free(ev);
//  }
//
//  // Creates finish-receive events.
//  void createFinishReceiveEvent(uint16_t addr, double lqi, double rssi) {
//    uint8_t length = 0;
//    event_t* ev = (event_t*) malloc(sizeof(event_t));
//    FinishReceiveEventData* data = (FinishReceiveEventData*) malloc(sizeof(FinishReceiveEventData));
//
//    pp("enter createFinishReceiveEvent(%d)", addr);
//
//    if (isSendingAck) {
//      TOS_MsgPtr msg = NULL;
//
//      length = ACK_LENGTH + 1;
//      msg = (TOS_MsgPtr) malloc(length);
//      data->msg = msg;
//
//      msg->length = ACK_LENGTH;
//      msg->fcfhi = CC2420_DEF_FCF_TYPE_ACK;
//      msg->fcflo = CC2420_DEF_FCF_LO; // TODO why is the bit in Reserved set?
//      msg->dsn = ackDsn;
//    } else {
//      uint8_t* arr = NULL;
//      uint8_t origLength = txQueue[0] + 1;
//      length = origLength;
//
//      // TODO but change this to the auto-lqi/rssi stuff
//      if (getRegisterBit(CC2420_MDMCTRL0, CC2420_MDMCTRL0_AUTOCRC)) {
//        length += 2;
//      }
//
//      // Note that in broadcasts, we're copying the data for each mote.
//      data->msg = (TOS_MsgPtr) malloc(length);
//      memcpy(data->msg, txQueue, origLength - MSG_FOOTER_SIZE);
//      arr = (uint8_t*) data->msg;
//
//      // Set FCS values.
//      {
//        int8_t rssiValue = rssi + 45;
//        uint8_t lqiValue = (110 - 65) * lqi + 65;
//        (int8_t) arr[length - 2] = rssiValue; // TODO is the casting good?
//        arr[length - 1] = (1 << 7) | lqiValue;
//
//        if (DEBUG_SENDING) {
//          int i;
//          pp("sending rssi = %d, lqi = %d", (int) rssiValue, (int) lqiValue);
//          pp("out dump: [ ");
//          for (i = 0; i < length; i++) {
//            pp("%d ", (int) arr[i]);
//          }
//          pp("]");
//        }
//      }
//    }
//
//    {
//      // TODO how do I calculate the actual time needed to transmit? (If I should?)
//      //uint16_t transmitTime = (preambleLength + length) * byteTransmitTime;
//
//      uint16_t transmitTime = secondsToTicks(TRANSMIT_LATENCY);
//      char buf[128];
//      printTime(buf, 128);
//      pp("  %s, tos_state.tos_time = %d, transmitTime = %d",
//          buf, (int) tos_state.tos_time, (int) transmitTime);
//      data->src = NODE_NUM;
//      ev->data = data;
//      ev->mote = addr;
//      ev->time = tos_state.tos_time + transmitTime;
//      ev->handle = handleFinishReceiveEvent;
//      ev->cleanup = cleanupFinishReceiveEvent;
//      ev->pause = 0;
//      TOS_queue_insert_event(ev);
//    }
//  }
//
//  //
//  // Finish-send events.
//  //
//
//  // Handles finish-send events.
//  void handleFinishSendEvent(event_t* ev, struct TOS_state* state) {
//    RadioMsgSentEvent radioEvent;
//    TOS_MsgPtr msg = (TOS_MsgPtr) txQueue;
//    double lqi, rssi;
//
//    p("enter handleFinishSendEvent()");
//
//    // Note that we are copying some garbage here.
//    memcpy(&radioEvent.message, msg, sizeof(radioEvent.message));
//
//    if (DEBUG_SENDING) {
//      // Dump the packet contents.
//      uint8_t i;
//      for (i = 0; i < sizeof(radioEvent.message); i++) {
//        printf("%02x ", ((uint8_t*) &radioEvent)[i]);
//      }
//    }
//
//    // TOSSIM-related tools expect CRC in {0,1}, not an actual CRC value.
//    radioEvent.message.crc = 1;
//
//    // Determine whether the packet should be dropped - if not, then "send" it.
//    if (isSendingAck) {
//      if (canSend(NODE_NUM, ackDest, ACK_LENGTH, &lqi, &rssi)) {
//        createFinishReceiveEvent(ackDest, lqi, rssi);
//        sendTossimEvent(NODE_NUM, AM_RADIOMSGSENTEVENT, tos_state.tos_time, &radioEvent);
//      }
//    } else {
//      // actually send out the packets to each of the motes via events
//      if (msg->addr != TOS_BCAST_ADDR) {
//        // TODO why add 7?
//        if (canSend(NODE_NUM, msg->addr, msg->length + 7, &lqi, &rssi)) {
//          createFinishReceiveEvent(msg->addr, lqi, rssi);
//          sendTossimEvent(NODE_NUM, AM_RADIOMSGSENTEVENT, tos_state.tos_time, &radioEvent);
//        }
//      } else {
//        uint16_t destAddr;
//        for (destAddr = 0; destAddr < tos_state.num_nodes; destAddr++) {
//          if (canSend(NODE_NUM, destAddr, msg->length + 7, &lqi, &rssi)) {
//            createFinishReceiveEvent(destAddr, lqi, rssi);
//            sendTossimEvent(NODE_NUM, AM_RADIOMSGSENTEVENT, tos_state.tos_time, &radioEvent);
//          }
//        }
//      }
//    }
//
//    // Set some state (and signal that they've changed).
//    setStatusReg(CC2420_TX_ACTIVE, FALSE);
//    clearSfd();
//    setCca();
//
//    event_cleanup(ev);
//  }
//
//  // Cleans up finish-send events.
//  void cleanupFinishSendEvent(event_t* ev) {
//    free(ev);
//  }
//
//  // Creates finish-send events.
//  void createFinishSendEvent() {
//    event_t* ev = (event_t*) malloc(sizeof(event_t));
//    p("enter createFinishSendEvent()");
//    ev->mote = NODE_NUM;
//    ev->data = NULL;
//    ev->time = tos_state.tos_time + TRANSMIT_LOCAL_LATENCY;
//    ev->handle = handleFinishSendEvent;
//    ev->cleanup = cleanupFinishSendEvent;
//    ev->pause = 0;
//    TOS_queue_insert_event(ev);
//  }

  //
  // Frame-received event.
  //

  // Handles frame-received events.
  void handleFrameReceivedEvent(event_t* ev, struct TOS_state* state) {
    bool isOverflow = FALSE;
    SourceData* data;
    TOS_MsgPtr msg;
    uint8_t length;
    uint8_t* frame;
    bool crcOk;

    data = (SourceData*) ev->data;
    pp("enter handleFrameReceivedEvent(from=%hd, rssi=%f)",
        data->sourceId, data->rssi);

    // This is necessary to keep all forced events safe.
    checkInitialized();

    // Check that we're actually receiving this packet correctly,
    // and that this event is for the right packet being received.
    if (receivingFrame != NULL &&
        data->sourceId == receivingFrame->sourceId) {
      // Check that the destination address was correct and
      // that the length was not corrupted by interference.
      if (receivingFrame->isDestAddrCorrect &&
          !receivingFrame->wasLengthCorrupt &&
          getState() == STATE_RX_FRAME) {
        //assert(!isReceivingInterference);

        msg = (TOS_MsgPtr) receivingFrame->frame;
        frame = receivingFrame->frame;
        // + 1 for the length field.
        length = msg->length + 1;

        // Make sure that the RSSI value for this packet is the same.
        assert(receivingFrame->rssi == data->rssi);

        if (!isReceivingInterference) {
          if (getRegisterBit(CC2420_MDMCTRL0, CC2420_MDMCTRL0_AUTOCRC)) {
            // In receive mode, auto-ack automatically verifies the two CRC bytes, and
            // then replaces those two bytes with the RSSI, the CRC correctness bit, and
            // the LQI.

            // The packet should always have two CRC bytes, according to the 802.15.4
            // standard. Verify the CRC.
            // TODO actually check the CRC
            crcOk = (frame[length - 2] == 0 && frame[length - 1] == 0);

            // Now replace the two CRC bytes with the RSSI and LQI values.
            (int8_t) frame[length - 2] = getEncodedRssi(receivingFrame->rssi);
            frame[length - 1] = (crcOk << 7) | getEncodedLqi(receivingFrame->lqi);
          }

          // Write to the RX FIFO (if we're not the ones sending this packet).
          if (receivingFrame->sourceId != NODE_NUM) {
            assert(!getStatusReg(CC2420_TX_ACTIVE));
            if (rxQueueEnd + length > QUEUE_SIZE) {
              // TODO this is so not right, because it is followed immediately by the
              // normal procedure. also, was FIFOP supposed to be already set earlier by something? (According to the datasheet, overflow is setting FIFO to low *while* FIFOP is high.)
              fail("not implemented!");
              setFifop();
              clearFifo();
              isOverflow = TRUE;
            } else {
              RadioMsgSentEvent radioEvent;

              // Send the radio event to TinyViz.
              memcpy(&radioEvent.message, msg, sizeof(radioEvent.message));
              // TOSSIM-related tools expect CRC in {0,1}, not an actual CRC value.
              radioEvent.message.crc = 1;
              sendTossimEvent(data->sourceId, AM_RADIOMSGSENTEVENT, tos_state.tos_time, &radioEvent);
//              {
//                char str[STR_LENGTH];
//                char* pstr = str;
//                uint8_t i;
//                uint8_t* arr = (uint8_t*) &radioEvent.message;
//                for (i = 0; i < arr[0] + 1; i++) {
//                  assert(pstr - str < STR_LENGTH);
//                  pstr += snprintf(pstr, STR_LENGTH, "%02x ", arr[i]);
//                }
//                pp("sendTossimEvent(length=%d [ %s ])", arr[0]+1, str);
//              }

              memcpy(rxQueue + rxQueueEnd, frame, length);
              rxQueueEnd += length;
            }
          }
        }

        // The signal has ended.
        removeChannelSource(receivingFrame->rssi, data->sourceId);

        // If we heard this packet fine (no interference) and we're not
        // the ones sending this packet.
        if (!isReceivingInterference &&
            receivingFrame->sourceId != NODE_NUM) {
          assert(!getStatusReg(CC2420_TX_ACTIVE));
          // FIFOP is set once we've finished receiving a packet and/or we've exceeded
          // the RXFIFO threshold.
          // TODO is fifop supposed to be set even when we're still hearing an
          // interfering packet? i'm guessing that it works because we're comparing
          // the length with the length given in the length field. BUT what if the length
          // field was also interfered?
          // TODO should I add another event for packets that make the rxfifo length
          // exceed the threshold? the event would set FIFOP.
          if (isFifopInverted()) {
            clearFifop();
          } else {
            setFifop();
          }

          // Start sending an ack if auto-ack is enabled and an ack was requested.
          if (getRegisterBit(CC2420_MDMCTRL0, CC2420_MDMCTRL0_AUTOACK) &&
              (msg->fcfhi & CC2420_DEF_FCF_HI_ACK) != 0 && crcOk) {
            // Save the DSN of this packet (so that when we create the ACK later,
            // we'll know what DSN to acknowledge).
            ackDsn = msg->dsn;

            setState(STATE_TX_ACK_CALIBRATE);
            createTxCalibratedEvent();
          } else {
            // TODO what happens in RX_WAIT, exactly?
            setState(STATE_RX_WAIT);
            setState(STATE_RX_SFD_SEARCH);
          }
        }
      } else {
        // TODO there is duplicate code here (same from above case)!
        // The signal has ended.
        removeChannelSource(receivingFrame->rssi, data->sourceId);

        // If we're not in a sending state.
        if (receivingFrame->sourceId != NODE_NUM &&
            getState() == STATE_RX_FRAME) {
          // TODO what happens in RX_WAIT, exactly?
          setState(STATE_RX_WAIT);
          setState(STATE_RX_SFD_SEARCH);
        }
      }

      // Free this because the event is for receivingFrame.
      free(receivingFrame->frame);
      free(receivingFrame);
      receivingFrame = NULL;
//    } else if (receivingFrame != NULL) {
//      // TODO there is duplicate code here (same from above case)!
//      // The signal has ended.
//      removeChannelSource(receivingFrame->rssi);
//      free(receivingFrame->frame);
//      free(receivingFrame);
//      receivingFrame = NULL;
    } else {
      removeChannelSource(data->rssi, data->sourceId);
    }

    event_cleanup(ev);
  }

  // Cleans up frame-received events.
  void cleanupFrameReceivedEvent(event_t* ev) {
    p("enter cleanupFrameReceivedEvent()");
    free(ev->data);
    free(ev);
  }

  // Creates frame-received events.
  // Preconditions: called at the frame has been completely received.
  void createFrameReceivedEvent(uint16_t moteId) {
    event_t* ev;

    p("enter createFrameReceivedEvent()");

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = moteId;
    ev->force = TRUE;
    // Freed in cleanupFrameReceivedEvent()
    ev->data = createSourceData(moteId);
    ev->time = tos_state.tos_time;
    ev->handle = handleFrameReceivedEvent;
    ev->cleanup = cleanupFrameReceivedEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // Address-received events.
  //

  // Handles address-received events.
  void handleAddressReceivedEvent(event_t* ev, struct TOS_state* state) {
    SourceData* data;

    data = (SourceData*) ev->data;
    pp("enter handleAddressReceivedEvent(from=%hd, rssi=%f)",
        data->sourceId, data->rssi);

    // This is necessary to keep all forced events safe.
    checkInitialized();

    // Check whether this is for the right packet, and whether there has
    // been any interference.
    if (receivingFrame != NULL &&
        data->sourceId == receivingFrame->sourceId &&
        !receivingFrame->wasLengthCorrupt &&
        !isReceivingInterference) {
      TOS_MsgPtr msg = (TOS_MsgPtr) receivingFrame->frame;

      // Perform address recognition.
      receivingFrame->isDestAddrCorrect = isAddressCorrect(msg);

      // Clear the pins if this address is incorrect and we're not the ones
      // sending this packet.
      if (!receivingFrame->isDestAddrCorrect &&
          receivingFrame->sourceId != NODE_NUM) {
        assert(!getStatusReg(CC2420_TX_ACTIVE));
        clearSfd();
        clearFifo();
      }
    }

    event_cleanup(ev);
  }

  // Cleans up address-received events.
  void cleanupAddressReceivedEvent(event_t* ev) {
    p("enter cleanupAddressReceivedEvent()");
    free(ev->data);
    free(ev);
  }

  // Creates address-received events.
  // Preconditions: this must be called at the timepoint when we're just starting
  // to send the frame, so that the time until the address field is received
  // (the address transmit latency) makes sense.
  void createAddressReceivedEvent(uint16_t moteId) {
    event_t* ev;

    p("enter createAddressReceivedEvent()");

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = moteId;
    ev->force = TRUE;
    // Freed in cleanupAddressReceivedEvent()
    ev->data = createSourceData(moteId);
    ev->time = tos_state.tos_time + secondsToTicks(ADDRESS_TRANSMIT_LATENCY);
    ev->handle = handleAddressReceivedEvent;
    ev->cleanup = cleanupAddressReceivedEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // Frame-receiving event.
  //

  // Handles frame-receiving events.
  // Preconditions: if there was interference before this time point,
  // then isReceivingInterference is set.
  // Postconditions: receivingFrame is set to the packet currently being
  // received.
  void handleFrameReceivingEvent(event_t* ev, struct TOS_state* state) {
    // Save all the data about this packet.
    FrameData* data = (FrameData*) ev->data;

    pp("enter handleFrameReceivingEvent(from=%hd, rssi=%f)",
        data->sourceId, data->rssi);

    // This is necessary to keep all forced events safe.
    checkInitialized();

    if (receivingFrame == NULL) {
      receivingFrame = data;

      // TODO note that this implementation means that
      // if we have mote A start sending while mote B is just about to finish,
      // then the preamble/SFD will be corrupt (interfered),
      // but not the frame. And this if statement is really just checking
      // to see if the current frame is corrupted (and neglecting the
      // preamble/sfd)!
      if (!isReceivingInterference && getState() == STATE_RX_SFD_SEARCH) {
        // We can hear the length correctly (we're assuming that the next byte
        // will be received without interference).
        receivingFrame->wasLengthCorrupt = FALSE;

        // Set the pins and state if we're not the ones sending this packet.
        if (receivingFrame->sourceId != NODE_NUM) {
          assert(!getStatusReg(CC2420_TX_ACTIVE));
          // For transmission, the SFD is set in handleFrameSentEvent() and
          // handlePreambleSentEvent(), not here.
          setSfd();
          setFifo();
          setState(STATE_RX_FRAME);
        }
      } else {
        receivingFrame->wasLengthCorrupt = TRUE;
      }
    } else {
      free(data->frame);
      free(data);
    }

    event_cleanup(ev);
  }

  // Cleans up frame-receiving events.
  // Don't clean up the event data, because it contains the frame that will be
  // received.
  void cleanupFrameReceivingEvent(event_t* ev) {
    p("enter cleanupFrameReceivingEvent()");
    free(ev);
  }

  // Creates frame-receiving events.
  void createFrameReceivingEvent(uint16_t moteId, FrameData* data) {
    event_t* ev;

    pp("enter createFrameReceivingEvent(%d)", moteId);

    ev = (event_t*) alloc(sizeof(event_t));
    ev->data = data;
    ev->force = TRUE;
    ev->mote = moteId;
    ev->time = tos_state.tos_time;
    ev->handle = handleFrameReceivingEvent;
    ev->cleanup = cleanupFrameReceivingEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // Preamble-receiving event.
  //

  // Handles preamble-receiving events.
  void handlePreambleReceivingEvent(event_t* ev, struct TOS_state* state) {
    SourceData* data;

    data = (SourceData*) ev->data;
    pp("enter handlePreambleReceivingEvent(from=%hd, rssi=%f)",
        data->sourceId, data->rssi);

    // This is necessary to keep all forced events safe.
    checkInitialized();

    // Adjust the CCA with an energy level.
    // TODO is there any other situation in which the channel data would be invalid?
    addChannelSource(data->rssi, data->sourceId);

    event_cleanup(ev);
  }

  // Cleans up preamble-receiving events.
  void cleanupPreambleReceivingEvent(event_t* ev) {
    p("enter cleanupPreambleReceivingEvent()");
    free(ev->data);
    free(ev);
  }

  // Creates preamble-receiving events.
  void createPreambleReceivingEvent(uint16_t moteId) {
    event_t* ev;

    pp("enter createPreambleReceivingEvent(%d)", moteId);

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = moteId;
    ev->force = TRUE;
    // Freed in cleanupPreambleReceivingEvent()
    ev->data = createSourceData(moteId);
    ev->time = tos_state.tos_time;
    ev->handle = handlePreambleReceivingEvent;
    ev->cleanup = cleanupPreambleReceivingEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // RX-calibrated events.
  //

  // Handles RX-calibrated events.
  void handleRxCalibratedEvent(event_t* ev, struct TOS_state* state) {
    p("enter handleRxCalibratedEvent()");

    // Start listening for SFDs.
    setState(STATE_RX_SFD_SEARCH);

    event_cleanup(ev);
  }

  // Cleans up RX-calibrated events.
  void cleanupRxCalibratedEvent(event_t* ev) {
    p("enter cleanupRxCalibratedEvent()");
    free(ev);
  }

  // Creates RX-calibrated events.
  void createRxCalibratedEvent() {
    event_t* ev;

    p("enter createRxCalibratedEvent()");

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = NODE_NUM;
    ev->data = NULL;
    ev->time = tos_state.tos_time + symbolsToTicks(RX_CALIBRATION_LATENCY);
    ev->handle = handleRxCalibratedEvent;
    ev->cleanup = cleanupRxCalibratedEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // Frame-sent events.
  //

  // Handles frame-sent events.
  void handleFrameSentEvent(event_t* ev, struct TOS_state* state) {
    uint16_t moteId;
    uint16_t expectedLength;

    p("enter handleFrameSentEvent()");

    // Transmission completed, so go back to listening mode.
    setState(STATE_RX_CALIBRATE);
    createRxCalibratedEvent();

    // Was there an underflow?
    // TODO right now i'm determining if there's an underflow beforehand.
    // but is it possible to push more bytes into TXFIFO while transmitting,
    // and thus avoiding underflow?
    expectedLength = txQueue[0];
    if (getRegisterBit(CC2420_MDMCTRL0, CC2420_MDMCTRL0_AUTOCRC)) {
      expectedLength -= 2;
    }
    if (txQueueEnd <= expectedLength) {
      setStatusReg(CC2420_TX_UNDERFLOW, FALSE);
    }

    // Let neighbors know that they have finished receiving the packet.
    for (moteId = 0; moteId < tos_state.num_nodes; moteId++) {
      if (getNeighbor(moteId)->isNeighbor) {
        DBGSTATE(moteId, FALSE, getNeighbor(moteId)->rssi);
        createFrameReceivedEvent(moteId);
      }
    }

    // Set pins to signal the end of the transmission.
    setStatusReg(CC2420_TX_ACTIVE, FALSE);
    clearSfd();

    free(transmittingFrame->frame);
    free(transmittingFrame);
    transmittingFrame = NULL;
    event_cleanup(ev);
  }

  // Cleans up frame-sent events.
  void cleanupFrameSentEvent(event_t* ev) {
    p("enter cleanupFrameSentEvent()");
    free(ev);
  }

  // Creates frame-sent events.
  void createFrameSentEvent() {
    uint64_t latency;
    event_t* ev;

    p("enter createFrameSentEvent()");

    // + 1 for the length field.
    latency = secondsToTicks(calculateTransmitTime(1 + transmittingFrame->length));

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = NODE_NUM;
    ev->data = NULL;
    ev->time = tos_state.tos_time + latency;
    ev->handle = handleFrameSentEvent;
    ev->cleanup = cleanupFrameSentEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // Preamble-sent events. This event actually spans both the preamble and the
  // SFD.
  //

  // Handles preamble-sent events.
  void handlePreambleSentEvent(event_t* ev, struct TOS_state* state) {
    uint16_t moteId;

    p("enter handlePreambleSentEvent()");

    // Transition appropriately.
    if (getState() == STATE_TX_PREAMBLE) {
      setState(STATE_TX_FRAME);
    } else {
      assert(getState() == STATE_TX_ACK_PREAMBLE);
      setState(STATE_TX_ACK);
    }

    // Prepare a local copy of the full frame.
    transmittingFrame = createFrame(NODE_NUM);

    // Start transmitting the frame, making all neighbors hear it.
    for (moteId = 0; moteId < tos_state.num_nodes; moteId++) {
      if (getNeighbor(moteId)->isNeighbor) {
        createFrameReceivingEvent(moteId, createFrame(moteId));
        // TODO assuming that the buffer doesn't change while transmitting
        if (txQueueEnd >= 8) {
          createAddressReceivedEvent(moteId);
        }
      }
    }
    createFrameSentEvent();

    // Set the SFD pin to signal that transmission of the actual packet has started.
    setSfd();

    event_cleanup(ev);
  }

  // Cleans up preamble-sent events.
  void cleanupPreambleSentEvent(event_t* ev) {
    p("enter cleanupPreambleSentEvent()");
    free(ev);
  }

  // Creates preamble-sent events.
  void createPreambleSentEvent() {
    event_t* ev;

    p("enter createPreambleSentEvent()");

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = NODE_NUM;
    ev->data = NULL;
    ev->time = tos_state.tos_time + secondsToTicks(PREAMBLE_SFD_TRANSMIT_LATENCY);
    ev->handle = handlePreambleSentEvent;
    ev->cleanup = cleanupPreambleSentEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // TX-calibrated events.
  //

  // Handles TX-calibrated events.
  void handleTxCalibratedEvent(event_t* ev, struct TOS_state* state) {
    uint16_t moteId;

    p("enter handleTxCalibratedEvent()");

    // Determine which other motes can hear the packet we're about to send.
    updateNeighbors();

    // Transition to the appropriate next state. These series of functions are
    // shared for both data packets and ack packets.
    if (getState() == STATE_TX_CALIBRATE) {
      setState(STATE_TX_PREAMBLE);
    } else {
      assert(getState() == STATE_TX_ACK_CALIBRATE);
      setState(STATE_TX_ACK_PREAMBLE);
    }

    // Start transmitting the preamble.
    for (moteId = 0; moteId < tos_state.num_nodes; moteId++) {
      if (getNeighbor(moteId)->isNeighbor) {
        DBGSTATE(moteId, TRUE, getNeighbor(moteId)->rssi);
        createPreambleReceivingEvent(moteId);
      }
    }
    createPreambleSentEvent();

    event_cleanup(ev);
  }

  // Cleans up TX-calibrated events.
  void cleanupTxCalibratedEvent(event_t* ev) {
    p("enter cleanupTxCalibratedEvent()");
    free(ev);
  }

  // Creates TX-calibrated events.
  void createTxCalibratedEvent() {
    event_t* ev;
    bool txTurnaroundBit;
    uint8_t txTurnaroundSymbols;

    p("enter createTxCalibratedEvent()");

    // Get the turnaround time (in symbols).
    if (getState() == STATE_TX_CALIBRATE) {
      txTurnaroundBit = getRegisterBit(CC2420_TXCTRL, CC2420_TXCTRL_TURNARND);
      txTurnaroundSymbols = txTurnaroundBit == 0 ? 8 : 12;
    } else {
      assert(getState() == STATE_TX_ACK_CALIBRATE);
      txTurnaroundSymbols = TX_ACK_CALIBRATE_LATENCY;
    }

    // Create the event.
    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = NODE_NUM;
    ev->data = NULL;
    ev->time = tos_state.tos_time + symbolsToTicks(txTurnaroundSymbols);
    ev->handle = handleTxCalibratedEvent;
    ev->cleanup = cleanupTxCalibratedEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // Oscillator-on events.
  //

  // Handles oscillator-on events.
  void handleOscillatorOnEvent(event_t* ev, struct TOS_state* state) {
    uint8_t ccaMux;

    p("enter handleOscillatorOn()");

    setState(STATE_XOSC_ON);

    ccaMux = getRegisterBits(CC2420_IOCFG1,
        CC2420_IOCFG1_CCAMUX_START, CC2420_IOCFG1_CCAMUX_END);
    if (ccaMux == 24) {
      setCca();
    }

    setStatusReg(CC2420_XOSC16M_STABLE, 1);

    // TODO this is part of the temporary workaround
    if (ev != NULL) {
      event_cleanup(ev);
    }
  }

  // Cleans up oscillator-on events.
  void cleanupOscillatorOnEvent(event_t* ev) {
    free(ev);
  }

  // Creates oscillator-on events.
  void createOscillatorOnEvent() {
    event_t* ev;

    p("enter createOscillatorOnEvent()");

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = NODE_NUM;
    ev->data = NULL;
    ev->time = tos_state.tos_time + secondsToTicks(OSCILLATOR_ON_LATENCY);
    ev->handle = handleOscillatorOnEvent;
    ev->cleanup = cleanupOscillatorOnEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // VREG-on events.
  //

  // Handles VREG-on events.
  void handleVregOnEvent(event_t* ev, struct TOS_state* state) {
    p("enter handleVregOnEvent()");
    setState(STATE_IDLE);
    if (ev != NULL) {
      event_cleanup(ev);
    }
  }

  // Cleans up VREG-on events.
  void cleanupVregOnEvent(event_t* ev) {
    p("enter cleanupVregOnEvent()");
    free(ev);
  }

  // Creates VREG-on events.
  void createVregOnEvent() {
    event_t* ev;

    p("enter createVregOnEvent()");

    ev = (event_t*) alloc(sizeof(event_t));
    ev->mote = NODE_NUM;
    ev->data = NULL;
    ev->time = tos_state.tos_time + secondsToTicks(VREG_ON_LATENCY);
    ev->handle = handleVregOnEvent;
    ev->cleanup = cleanupVregOnEvent;
    ev->pause = 0;

    TOS_queue_insert_event(ev);
  }

  //
  // Sending packets.
  //

  // Create a SourceData struct.
  // These are always allocated as event data, so they are freed in the
  // cleanup functions.
  // Precondition: we have already run updateNeighbors for the current
  // transmission.
  SourceData* createSourceData(uint8_t moteId) {
    SourceData* data = (SourceData*) alloc(sizeof(SourceData));
    data->sourceId = NODE_NUM;
    data->rssi = getNeighbor(moteId)->rssi;
    return data;
  }

  // Creates a frame to be transmitted, based on what we have in TXFIFO.
  FrameData* createFrame(uint16_t moteId) {
    uint8_t length;
    // Freed by the transmitter and the receiver after the packet has been
    // completely sent, in handleFrameSentEvent() and handleFrameReceivedEvent().
    FrameData* data = (FrameData*) alloc(sizeof(FrameData));

    if (getState() == STATE_TX_ACK) {
      TOS_MsgPtr msg = NULL;

      length = ACK_LENGTH + 1;
      // Freed by the transmitter and the receiver after the packet has been
      // completely sent, in handleFrameSentEvent() and handleFrameReceivedEvent().
      msg = (TOS_MsgPtr) alloc(length * sizeof(uint8_t));
      data->frame = (uint8_t*) msg;

      msg->length = ACK_LENGTH;
      msg->fcfhi = CC2420_DEF_FCF_TYPE_ACK;
      msg->fcflo = CC2420_DEF_FCF_LO;
      msg->dsn = ackDsn;
    } else {
      uint8_t* frame = NULL;
      uint8_t origLength;

      assert(getState() == STATE_TX_FRAME);

//      // XXX begin temporary test!
//#define TESTLENGTH 20
//      frame = alloc(TESTLENGTH);
//      frame[0] = TESTLENGTH - 1;
//      for (origLength = 1; origLength < TESTLENGTH; origLength++) {
//        frame[origLength] = 0;
//      }
//      frame[4] = 0xFF;
//      frame[5] = 0xFF;
//      frame[6] = 0x00;
//      frame[7] = 0x00;
//      data->frame = frame;
//      // XXX end temporary test!

      // The length field includes the header, payload, and footer,
      // but not the length field itself.
      origLength = txQueue[0] + 1; // + 1 to include the length field
      length = origLength;

      // Allocate space for the frame.
      // Freed by the transmitter and the receiver after the packet has been
      // completely sent, in handleFrameSentEvent() and handleFrameReceivedEvent().
      frame = (uint8_t*) alloc(length);
      data->frame = frame;

      // If auto-ack isn't set, the packet should already include the CRC.
      // Otherwise, the radio is responsible for generating and appending it.
      // TODO implement true CRC generation
      if (getRegisterBit(CC2420_MDMCTRL0, CC2420_MDMCTRL0_AUTOCRC)) {
        frame[length - 2] = 0;
        frame[length - 1] = 0;
      }

      assert(origLength <= sizeof(TOS_Msg));

      // The amount of data actually in the TXFIFO does not include the message
      // footer, since the radio is supposed to generate it.
      memcpy(frame, txQueue, origLength - MSG_FOOTER_SIZE);
    }

    data->length = length;
    data->sourceId = NODE_NUM;
    data->rssi = getNeighbor(moteId)->rssi;
    data->lqi = getNeighbor(moteId)->lqi;
    return data;
  }

  // Start transmission by setting the appropriate pins and starting
  // calibration.
  void startTransmission() {
    // Transition to calibration state.
    setStatusReg(CC2420_TX_ACTIVE, TRUE);
    setState(STATE_TX_CALIBRATE);

    // Start the calibration (8-12 symbols).
    createTxCalibratedEvent();

    // Start TX in-line encryption if SPI_SEC_MODE != 0.
    // TODO implement
  }

  //
  // HPLCC2420 registers.
  //

  // Send a command strobe, returning the radio's status byte.
  // TODO complete implementation.
  async command uint8_t HPLCC2420.cmd(uint8_t addr) {
    char* cmdstr;
    switch (addr) {
      case CC2420_SNOP:
        cmdstr = "CC2420_SNOP";
        break;
      case CC2420_SXOSCON:
        cmdstr = "CC2420_SXOSCON";
        break;
      case CC2420_STXCAL:
        cmdstr = "CC2420_STXCAL";
        break;
      case CC2420_SRXON:
        cmdstr = "CC2420_SRXON";
        break;
      case CC2420_STXON:
        cmdstr = "CC2420_STXON";
        break;
      case CC2420_STXONCCA:
        cmdstr = "CC2420_STXONCCA";
        break;
      case CC2420_SRFOFF:
        cmdstr = "CC2420_SRFOFF";
        break;
      case CC2420_SXOSCOFF:
        cmdstr = "CC2420_SXOSCOFF";
        break;
      case CC2420_SFLUSHRX:
        cmdstr = "CC2420_SFLUSHRX";
        break;
      case CC2420_SFLUSHTX:
        cmdstr = "CC2420_SFLUSHTX";
        break;
      case CC2420_SACK:
        cmdstr = "CC2420_SACK";
        break;
      case CC2420_SACKPEND:
        cmdstr = "CC2420_SACKPEND";
        break;
      case CC2420_SRXDEC:
        cmdstr = "CC2420_SRXDEC";
        break;
      case CC2420_STXENC:
        cmdstr = "CC2420_STXENC";
        break;
      case CC2420_SAES:
        cmdstr = "CC2420_SAES";
        break;
      default:
        fail("not a valid register");
        break;
    }
    pp("enter HPLCC2420.cmd(%s): status = %x", cmdstr, statusReg);

    // Don't accept commands if the oscillator isn't on.
    if ((getState() != STATE_VREG_OFF &&
          getState() != STATE_VREG_POWERUP &&
          getState() != STATE_IDLE &&
          getState() != STATE_XOSC_POWERUP) ||
        addr == CC2420_SXOSCON) {
      switch (addr) {
        case CC2420_SNOP:
          // No op (other than reading out status-bits).
          break;
        case CC2420_SXOSCON:
          // Transition into the oscillator powerup state.
          setState(STATE_XOSC_POWERUP);

          // Start turning on the oscillator.
          // TODO note that TOSH_wait doesn't actually do anything!
          // so this timeout mechanism *will not* work
          //createOscillatorOnEvent();
          // TODO this is a temporary workaround
          handleOscillatorOnEvent(NULL, NULL);

          break;
        case CC2420_STXCAL:
          // TODO implement
          break;
        case CC2420_SRXON:
          // Enable RX.
          // Start the calibration.
          // TODO so apparently, we can accept multiple (quick) calls to SRXON, right?
          // (see TuneManual, followed by RxMode, in lib)
          setState(STATE_RX_CALIBRATE);
          createRxCalibratedEvent();
          break;
        case CC2420_STXON:
          // Enable TX.
          // TODO this is incomplete! I have never tested this.
          startTransmission();
          break;
        case CC2420_STXONCCA:
          // Enable TX if channel is clear.
          if (TOSH_READ_RADIO_CCA_PIN()) {
            startTransmission();
          }
          break;
        case CC2420_SRFOFF:
          // TODO implement
          break;
        case CC2420_SXOSCOFF:
          // Turn off the crystal oscillator and RF.
          setStatusReg(CC2420_XOSC16M_STABLE, 0);
          // Modify xosc16m_pd/bias_pd/rf?
          // TODO implement
          break;
        case CC2420_SFLUSHRX:
          // Flush the RX FIFO buffer and reset the demodulator.
          // Note: you must read at least one byte from the RXFIFO before issuing
          // this command.
          clearFifo();
          // Reset the demodulator.
          // TODO implement
          break;
        case CC2420_SFLUSHTX:
          // Clear the underflow status bit.
          setStatusReg(CC2420_TX_UNDERFLOW, 0);
          // Flush the TX FIFO buffer.
          txQueueEnd = 0;
          break;
        case CC2420_SACK:
          break;
        case CC2420_SACKPEND:
          break;
        case CC2420_SRXDEC:
          break;
        case CC2420_STXENC:
          break;
        case CC2420_SAES:
          break;
        default:
          fail("not a valid register");
          break;
      }
    } else {
      pp("  still in state %d", getState());
    }

    pp("exit HPLCC2420.cmd(): status = %#x", statusReg);
    return statusReg;
  }

  // Transmits 16-bit data, returning the radio's status byte.
  // TODO complete implementation
  async command uint8_t HPLCC2420.write(uint8_t addr, uint16_t data) {
    pp("enter HPLCC2420.write(addr = %d, data = %d or %#x)", addr, data, data);
    setRegister(addr, data);
    return statusReg;
  }

  // Reads 16-bit data.
  async command uint16_t HPLCC2420.read(uint8_t addr) {
    pp("enter HPLCC2420.read(addr = %d)", addr);
    return getRegister(addr);
  }

  //
  // HPLCC2420M RAM.
  //

  // Signals that a RAM read operation has finished.
  task void signalRAMRd() {
    signal HPLCC2420RAM.readDone(rxramaddr, rxramlen, rxrambuf);
  }

  // Reads some data from the RAM.
  async command result_t HPLCC2420RAM.read(uint16_t addr, uint8_t length, uint8_t* buffer) {
    p("enter HPLCC2420RAM.read()");
    assert(addr + length <= RAM_SIZE);

    // Write the data into the given buffer.
    memcpy(buffer, ram + addr, length);

    // Prepare the states to be returned.
    rxramaddr = addr;
    rxramlen = length;
    rxrambuf = buffer;

    return post signalRAMRd();
  }

  // Signals that a RAM write operation has finished.
  task void signalRAMWr() {
    signal HPLCC2420RAM.writeDone(ramaddr, ramlen, rambuf);
  }

  // Writes some data to the RAM.
  async command result_t HPLCC2420RAM.write(uint16_t addr, uint8_t length, uint8_t* buffer) {
    pp("enter HPLCC2420RAM.write(addr = %d, length = %d)", addr, length);
    assert(addr + length <= RAM_SIZE);

    // Write the data to the RAM address.
    memcpy(ram + addr, buffer, length);

    // Prepare the states to be returned.
    ramaddr = addr;
    ramlen = length;
    rambuf = buffer;

    return post signalRAMWr();
  }

  //
  // HPLCC2420M FIFO queues.
  //

  // Signals that we have finished a read operation on the RXFIFO.
  task void signalRXFIFO() {
    signal HPLCC2420FIFO.RXFIFODone(rxlen, rxbuf);
  }

  // Read from the RX FIFO queue.  Will read bytes from the queue
  // until the length is reached (determined by the first byte read).
  // RXFIFODone() is signalled when all bytes have been read or the
  // end of the packet has been reached.
  //
  // @param length number of bytes requested from the FIFO
  // @param data buffer bytes should be placed into
  //
  // @return SUCCESS if the bus is free to read from the FIFO
  async command result_t HPLCC2420FIFO.readRXFIFO(uint8_t length, uint8_t *data) {
    TOS_MsgPtr rxMsg = (TOS_MsgPtr) rxQueue;
    uint8_t msgLen;

    p("enter HPLCC2420FIFO.read()");

    // Include the length field.
    msgLen = rxMsg->length + 1;

    // Check for sanity.
    assert(rxQueueEnd > 0);
    assert(msgLen <= length); // TODO what to do if not enough space in buffer?

    // Copy data from queue into provided buffer.
    memcpy(data, rxQueue, msgLen);
    // Shift the data over.
    rxQueueEnd -= msgLen;
    memmove(rxQueue, rxQueue + msgLen, rxQueueEnd);

    // Clear the FIFOP pin once at least one byte has been read.
    // TODO it was not clear from the datasheet whether this is the only condition for
    // the FIFOP pin to drop.
    if (length > 0) {
      if (isFifopInverted()) {
        setFifop();
      } else {
        clearFifop();
      }
    }

    // Save this as state so that it can be returned via the signal.
    rxbuf = data;
    rxlen = msgLen;

    // Debugging output.
    {
      char str[STR_LENGTH];
      char* pstr = str;
      uint8_t i;
      for (i = 0; i < rxlen; i++) {
        assert(pstr - str < STR_LENGTH);
        pstr += snprintf(pstr, STR_LENGTH, "%02x ", data[i]);
      }
      pp("msg.length=%d, length=%d, bytes=[ %s]", rxlen, length, str);
    }

    return post signalRXFIFO();
  }

  // Signals that we have finished a write operation on the RXFIFO.
  task void signalTXFIFO() {
    signal HPLCC2420FIFO.TXFIFODone(txlen, txbuf);
  }

  // Writes a series of bytes to the transmit FIFO.
  //
  // @param length length of data to be written
  // This includes the message header - everything before the payload, including
  // the length field - and the payload.
  // This is the actual length of the data parameter, since data does not include
  // the message footer (which the radio is responsible for generating).
  // This is in contrast with the length field's value, which is the size of the
  // entire packet - header, payload, and footer - EXCEPT for the length field.
  // @param data the first byte of data
  //
  // @return SUCCESS if the bus is free to write to the FIFO
  async command result_t HPLCC2420FIFO.writeTXFIFO(uint8_t length, uint8_t *data) {
    p("enter HPLCC2420FIFO.write()");
    // Check that the length is correct and that the message fits
    // The first byte should always be the length field.
    assert(data[0] - MSG_FOOTER_SIZE + 1 == length);
    if (length >= QUEUE_SIZE) {
      fail("overflowed TXFIFO");
    }

    // copy the data into the TXFIFO
    memcpy(txQueue + txQueueEnd, data, length);
    txQueueEnd += length;

    // signal that the TXFIFO is done
    return post signalTXFIFO();
  }

  // Default event handlers.

  default async event result_t HPLCC2420FIFO.RXFIFODone(uint8_t length, uint8_t *data) { return SUCCESS; }

  default async event result_t HPLCC2420FIFO.TXFIFODone(uint8_t length, uint8_t *data) { return SUCCESS; }

  default async event result_t HPLCC2420RAM.readDone(uint16_t addr, uint8_t length, uint8_t *data) { return SUCCESS; }

  default async event result_t HPLCC2420RAM.writeDone(uint16_t addr, uint8_t length, uint8_t *data) { return SUCCESS; }

  //
  // FIFOP Interrupt handlers and dispatch.
  // The FIFOP pin is set when we have started receiving data.
  //

  // Signals that the FIFOP pin has been fired.
  task void signalFifopFired() {
    result_t result = signal FIFOP.fired();
    fifopEnabled = result == SUCCESS;
  }

  // Set the FIFOP pin.
  void setFifop() {
    if (TOSH_READ_CC_FIFOP_PIN() == 0) {
      TOSH_SET_CC_FIFOP_PIN();
      if (fifopEnabled && fifopLowToHigh) {
        p("FIFOP set high");
        post signalFifopFired();
      } else {
        p("FIFOP set high, not firing");
      }
    } else {
      p("FIFOP set high, already high");
    }
  }

  // Clear the FIFOP pin.
  void clearFifop() {
    if (TOSH_READ_CC_FIFOP_PIN() == 1) {
      TOSH_CLR_CC_FIFOP_PIN();
      if (fifopEnabled && !fifopLowToHigh) {
        p("FIFOP set low");
        post signalFifopFired();
      } else {
        p("FIFOP set low, not firing");
      }
    } else {
      p("FIFOP set low, already low");
    }
  }

  // Determines the polarity of the FIFOP pin.
  bool isFifopInverted() {
    return getRegisterBit(CC2420_IOCFG0, CC2420_IOCFG0_FIFOPPOL);
  }

  // Enables an edge interrupt on the FIFOP pin.
  async command result_t FIFOP.startWait(bool low_to_high) {
    pp("enter FIFOP.startWait(%s)", low_to_high ? "low to high" : "high to low");
    fifopEnabled = TRUE;
    fifopLowToHigh = low_to_high;
    return SUCCESS;
  }

  // Disables FIFOP interrupts.
  async command result_t FIFOP.disable() {
    p("enter FIFOP.disable()");
    fifopEnabled = FALSE;
    return SUCCESS;
  }

  // Default event handler.
  default async event result_t FIFOP.fired() {
    return FAIL;
  }

  //
  // FIFO Interrupt handlers and dispatch.
  //

  // Signals that the FIFO pin has been fired
  task void signalFifoFired() {
    result_t result = signal FIFO.fired();
    fifoEnabled = result == SUCCESS;
  }

  // Set the FIFO pin.
  void setFifo() {
    if (TOSH_READ_CC_FIFO_PIN() == 0) {
      TOSH_SET_CC_FIFO_PIN();
      if (fifoEnabled && fifoLowToHigh) {
        p("FIFO set high");
        post signalFifoFired();
      } else {
        p("FIFO set high, not firing");
      }
    } else {
      p("FIFO set high, already high");
    }
  }

  // Clear the FIFO pin.
  void clearFifo() {
    if (TOSH_READ_CC_FIFO_PIN() == 1) {
      TOSH_CLR_CC_FIFO_PIN();
      if (fifoEnabled && !fifoLowToHigh) {
        p("FIFO set low");
        post signalFifoFired();
      } else {
        p("FIFO set low, not firing");
      }
    } else {
      p("FIFO set low, already low");
    }
  }

  // Enable an edge interrupt on the FIFO pin.
  async command result_t FIFO.startWait(bool low_to_high) {
    pp("enter FIFO.startWait(%s)", low_to_high ? "low to high" : "high to low");
    fifoEnabled = TRUE;
    fifoLowToHigh = low_to_high;
    return SUCCESS;
  }

  // Disables FIFO interrupts.
  async command result_t FIFO.disable() {
    p("enter FIFO.disable()");
    fifoEnabled = FALSE;
    return SUCCESS;
  }

  // Default event handler.
  default async event result_t FIFO.fired() {
    return FAIL;
  }

  //
  // CCA Interrupt handlers and dispatch.
  //

  // Signals that the FIFO pin has been fired.
  task void signalCcaFired() {
    result_t result = signal CCA.fired();
    ccaEnabled = result == SUCCESS;
  }

  // Set the CCA pin.
  void setCca() {
    if (TOSH_READ_RADIO_CCA_PIN() == 0) {
      TOSH_SET_RADIO_CCA_PIN();
      if (ccaEnabled && ccaLowToHigh) {
        p("CCA set high");
        post signalCcaFired();
      } else {
        p("CCA set high, not firing");
      }
    } else {
      p("CCA set high, already high");
    }
  }

  // Clear the CCA pin.
  void clearCca() {
    if (TOSH_READ_RADIO_CCA_PIN() == 1) {
      TOSH_CLR_RADIO_CCA_PIN();
      if (ccaEnabled && !ccaLowToHigh) {
        p("CCA set low");
        post signalCcaFired();
      } else {
        p("CCA set low, not firing");
      }
    } else {
      p("CCA set low, already low");
    }
  }

  // Disables CCA interrupts.
  async command result_t CCA.disable() {
    p("enter CCA.disable()");
    ccaEnabled = FALSE;
    return SUCCESS;
  }

//  // Handles CCA events.
//  void handleCcaEvent(event_t* ev, struct TOS_state* state) {
//    signal CCA.fired();
//    event_cleanup(ev);
//  }
//
//  // Cleans up CCA events.
//  void cleanupCcaEvent(event_t* ev) {
//    free(ev);
//  }
//
//  // Creates CCA events.
//  void createCcaEvent() {
//    event_t* ev = (event_t*) alloc(sizeof(event_t));
//    ev->mote = NODE_NUM;
//    ev->data = NULL;
//    ev->time = tos_state.tos_time; // TODO is this a reasonable delay?
//    ev->handle = handleCcaEvent;
//    ev->cleanup = cleanupCcaEvent; // free everything afterward
//    ev->pause = 0; // TODO what's this?
//    TOS_queue_insert_event(ev);
//  }

  // Enable an edge interrupt on the CCA pin.
  async command result_t CCA.startWait(bool low_to_high) {
    pp("enter CCA.startWait(%s)", low_to_high ? "low to high" : "high to low");
    ccaEnabled = TRUE;
    ccaLowToHigh = low_to_high;
    return SUCCESS;
  }

  // Default event handler.
  default async event result_t CCA.fired() {
    return FAIL;
  }

  //
  // SFD Interrupt handlers and dispatch
  // SFD = Start of Frame Delimiter
  // This detects the beginning of a packet.
  //

  // Signals that the SFD pin has been fired.
  task void signalSfdCaptured() {
    // TODO the time being passed is zero; this seems to be OK....
    result_t result = signal SFD.captured(0);
    sfdEnabled = result == SUCCESS;
  }

  // Sets the SFD pin.
  void setSfd() {
    if (TOSH_READ_CC_SFD_PIN() == 0) {
      TOSH_SET_CC_SFD_PIN();
      if (sfdEnabled && sfdLowToHigh) {
        p("SFD set high");
        post signalSfdCaptured();
      } else {
        p("SFD set high, not firing");
      }
    } else {
      p("SFD set high, already high");
    }
  }

  // Clears the SFD pin.
  void clearSfd() {
    if (TOSH_READ_CC_SFD_PIN() == 1) {
      TOSH_CLR_CC_SFD_PIN();
      if (sfdEnabled && !sfdLowToHigh) {
        p("SFD set low");
        post signalSfdCaptured();
      } else {
        p("SFD set low, not firing");
      }
    } else {
      p("SFD set low, already low");
    }
  }

  // Enables an edge interrupt on the SFD pin.
  async command result_t SFD.enableCapture(bool low_to_high) {
    pp("enter SFD.enableCapture(%s)", low_to_high ? "low to high" : "high to low");
    sfdEnabled = TRUE;
    sfdLowToHigh = low_to_high;
    return SUCCESS;
  }

  // Disables SFD interrupts.
  async command result_t SFD.disable() {
    p("enter SFD.disable()");
    sfdEnabled = FALSE;
    return SUCCESS;
  }

  default async event result_t SFD.captured(uint16_t val) { return FAIL; }

}


function addDataToWatchSurface(h, moteID, data)
%addDataToWatchSurface(h, moteID, data)
%
%This function takes the handle of a plot window and an array of data and adds the data to the plot.
%This is a surface plot, which is presumed to be the plot of multiple motes and a single point in time.
%The data parameter should be a 1*3 array: [x y z].  That data is assigned to the moteID indicated.

%     "Copyright (c) 2000 and The Regents of the University of California.  All rights reserved.
% 
%     Permission to use, copy, modify, and distribute this software and its documentation for any purpose, without fee, and without written agreement 
%     is hereby granted, provided that the above copyright notice and the following two paragraphs appear in all copies of this software.
%     
%     IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING 
%     OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
%     THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
%     FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF CALIFORNIA HAS NO OBLIGATION TO
%     PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS."
%     
%     Authors:  Kamin Whitehouse <kamin@cs.berkeley.edu>
%     Date:     May 10, 2002 

%disp('entered addDataToWatch')
watchParams = get(h,'UserData');

if (length(watchParams.moteIndexMap)<moteID) | (watchParams.moteIndexMap(moteID)==0)
    watchParams.moteIndexMap(moteID)=length(watchParams.x)+1;
    moteIndex = length(watchParams.x)+1;
else
    moteIndex = watchParams.moteIndexMap(moteID);
end

% if moteID=3
%     disp('heard from node 3')
% end

watchParams.x(moteIndex) = data(1);
watchParams.y(moteIndex) = data(2);
watchParams.z(moteIndex) = data(3);

%The linspace function provides a convenient way to create uniformly spaced data with the desired number of elements. The following
%statements produce vectors over the range of the random data with the same resolution as that generated by the -8:.5:8 statement in the
%previous sinc example.
xlin = linspace(min(watchParams.x),max(watchParams.x),watchParams.resolution);
ylin = linspace(min(watchParams.y),max(watchParams.y),watchParams.resolution);

%Now use these points to generate a uniformly spaced grid.
[X,Y] = meshgrid(xlin,ylin);

%The key to this process is to use griddata to interpolate the values of the function at the uniformly spaced points, based on the values
%of the function at the original data points (which are random in this example). This statement uses a triangle-based cubic interpolation to
%generate the new data.
if length(watchParams.x)>3
	Z = griddata(watchParams.x,watchParams.y,watchParams.z,X,Y,'cubic');
	
	%Plotting the interpolated and the nonuniform data produces
	set(h,'XData',X,'YData',Y,'ZData',Z,'CData',Z)
	%mesh(X,Y,Z) %interpolated
    
	if watchParams.drawPoints ==1
        if ishold
            set(watchParams.traces, 'XData',watchParams.x,'YData', watchParams.y,'ZData', watchParams.z) %nonuniform
        else
            hold on
            set(watchParams.traces, 'XData',watchParams.x,'YData', watchParams.y,'ZData', watchParams.z) %nonuniform
            hold off
        end
  	end
	
	set(h, 'UserData', watchParams);
end

set(h,'UserData',watchParams);
%disp('left addDataToWatch')

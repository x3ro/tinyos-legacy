\documentclass[11pt]{article}
\usepackage{html}
\usepackage{psfig}
\usepackage{makeidx}
\usepackage{nomencl}
\oddsidemargin  -0.1in   %  Note that \oddsidemargin = \evensidemargin
\evensidemargin -0.1in

%\topmargin -55pt         %    Nominal distance from top of page to top
%                         %    of box containing running head.
\headheight 12pt         %    Height of box containing running head.
%\headsep 25pt            %    Space between running head and text.
%\footskip 60pt           %    Distance from baseline of box containing


\textheight 9.125in        % Height of text (including footnotes and
                         % figures, excluding running head and foot).
\textwidth 6.75in         % Width of text line.
                         % For two-column mode:

\textheight 9.125in        % Height of text (including footnotes and
                         % figures, excluding running head and foot).
\textwidth 6.75in         % Width of text line.
                         % For two-column mode:
\renewcommand{\baselinestretch}{1.2}
\renewcommand{\nomname}{Glossary}
\makeindex\makeglossary


\newcommand{\docroot}{broken/dev}	
\newcommand{\java}{broken/dev/tools/java}

\begin{latexonly}
\title{\vspace{2.5in} TinyDB:  In-Network Query Processing in TinyOS}
\end{latexonly}
\begin{htmlonly}
\title{TinyDB:  In-Network Query Processing in TinyOS}
\end{htmlonly}
\author{Sam Madden, Joe Hellerstein, and Wei Hong \\
	\{madden,jmh\}@cs.berkeley.edu, whong@intel-research.net}
\date{}

\begin{document}
\pagenumbering{arabic}
%\pagestyle{myheadings}
\markright{{\bf TinyDB\index{TinyDB} Documentation. }}

\maketitle
\begin{latexonly}
\vspace{2in}
\end{latexonly}
\begin{center}
Version 0.1 \\
August 15, 2002
\end{center}


\thispagestyle{empty}
\begin{latexonly}\newpage\end{latexonly}
\tableofcontents
\begin{latexonly}\newpage\end{latexonly}
\section{Introduction}

TinyDB\index{TinyDB} is a query processing system for extracting
information from a network of
\htmladdnormallink{TinyOS}{http://webs.cs.berkeley.edu/tos}
sensors.\index{TinyOS}\index{sensor} Unlike existing
solutions for data processing in TinyOS\index{TinyOS},
TinyDB\index{TinyDB} does not require you to write embedded C\index{C}
code for sensors\index{sensor}\index{embedded}.
Instead, TinyDB\index{TinyDB} provides a
simple, SQL\index{SQL}-like interface to specify the data you want to
extract, along with additional parameters, like the rate at which data
should be refreshed -- much as you would pose queries against a
traditional database.  
Given a query specifying your data interests,
TinyDB\index{TinyDB} collects that data from motes\index{mote} in the
environment, filter\index{filter}s it, aggregates\index{aggregate} it together, and routes\index{routing} it out to
a PC.  TinyDB\index{TinyDB} does this via power-efficient in-network\index{in-network}
processing algorithms.

To use TinyDB\index{TinyDB}, you install its TinyOS\index{TinyOS} components\index{component} onto
each mote\index{mote} in your sensor\index{sensor} network. 
%(TinyDB\index{TinyDB}'s components\index{component} can co-exist
%with other components\index{component}, although they can place extensive demands on
%the memory and radio resources of the mote\index{mote}.)  
TinyDB\index{TinyDB} provides a simple
Java\index{Java} API\index{API} for writing PC applications that query and extract data from
the network; it also comes with a simple graphical query-builder and
result display that uses the API\index{API}.

The primary goal of TinyDB\index{TinyDB} is to make your life as a programmer
significantly easier, and allow data-driven applications to be
developed and deployed {\em much} more quickly than what is currently
possible.  TinyDB\index{TinyDB} frees you from the burden of writing low-level code
for sensor\index{sensor} devices, including the (very tricky) sensor network\index{sensor network}
interfaces.  Some of the features of TinyDB\index{TinyDB} include:

\begin{itemize}
\item {\it Metadata Management\index{catalog}}: TinyDB provides a metadata catalog to describe the kinds of 
sensor readings that are available in the sensor network.
\item {\it High Level Queries}: TinyDB uses a {\em
  declarative}\index{declarative} query language that lets you
  describe the data you want, without requiring you to say how to get
  it.  This makes it easier for you to write applications, and
  helps guarantee that your applications continue to run efficiently
  as the sensor network changes.
\item {\it Network Topology\index{topology}}: TinyDB\index{TinyDB} manages the underlying radio network by tracking
neighbors\index{neighbor}, maintaining routing\index{routing} tables, and ensuring that every mote\index{mote} in the
network can efficiently and (relatively) reliably deliver its data to the user.
\item {\it Multiple Queries}: TinyDB\index{TinyDB} allows multiple queries to be run on the same
set of motes\index{mote} at the same time.  Queries can have different sample\index{sample} rates and
access different sensor\index{sensor} types, and TinyDB\index{TinyDB} efficiently shares work between
queries when possible.
\item {\it Incremental Deployment via Query Sharing}: To expand your
TinyDB\index{TinyDB} sensor network\index{sensor network}, you simply download\index{download} the standard TinyDB\index{TinyDB} code to
new motes\index{mote}, and TinyDB\index{TinyDB} does the rest.  TinyDB\index{TinyDB} motes\index{mote} share queries with
each other: when a mote\index{mote} hears a network message for a query that it is
not yet running, it automatically asks the sender of that data for a
copy of the query, and begins running it.  No programming or
configuration of the new motes\index{mote} is required beyond installing TinyDB\index{TinyDB}.
\end{itemize}

This document serves a number of purposes.  The first sections are
targeted at the sensor\index{sensor} application programmer, and include a basic
overview of the TinyDB\index{TinyDB} system architecture, and a QuickStart guide to
using the TinyDB\index{TinyDB} system, its query language and APIs\index{API}.  The remaining
sections are targeted at readers who want to extend the TinyDB\index{TinyDB} system
itself.
%%  We never added this stuff.
%   They describe the TinyDB\index{TinyDB} software components\index{component}, highlighting
% places where the system could be profitably extended.

\subsection{System Overview}

This section provides a high level overview of the architecture of the TinyDB\index{TinyDB} software.  It
is designed to be accessible to users of the TinyDB\index{TinyDB} system who are not interested in
the technical details of the system's implementation.  A detailed
description of the TinyDB\index{TinyDB} software design
is reserved for Sections~\ref{sec:devel} and~\ref{sec:inside}.  

We begin with a short description of a typical use-case for TinyDB\index{TinyDB}.  Imagine that Mary
wishes to locate an unused conference room in her sensor\index{sensor}-equipped building, and
that an application to perform this task has not already been built.
The motes\index{mote} in Mary's
building have a sensor board\index{sensor board} with light sensors\index{sensor} and microphones and have been programmed with
a room number.  Mary decides that her application
should declare a room {\it in-use} when the average light reading of all the sensors\index{sensor} in a room
are above $l$ and when the average volume is above $v$.  Mary wants her application to 
refresh this occupancy information every 5 minutes.  Without TinyDB\index{TinyDB}, Mary
would have to write several hundred lines of custom embedded C\index{C}
code~\index{embedded} to collect information
from all the motes\index{mote} in a room, coordinate the communication of readings
across sensors\index{sensor},
aggregate\index{aggregate} these readings together to compute the average light
and volume, and then forward that information from within the sensor network\index{sensor network} to the PC where
the application is running.  She would then have to download\index{download} her compiled\index{compile}
program to each of the motes\index{mote} in the room.  Instead, if the motes\index{mote} in Mary's building are running TinyDB\index{TinyDB},
she can simply pose the following SQL\index{SQL}
query to identify the rooms that are currently in-use:

\noindent{\tt \hspace{.5in}SELECT\index{Select} roomno, AVERAGE(light), AVERAGE(volume) \\
\hspace*{.5in}FROM\index{From} sensors\index{sensor} \\
\hspace*{.5in}GROUP BY\index{Group By}\index{group} roomno \\
\hspace*{.5in}HAVING\index{Having} AVERAGE(light) > $l$ AND AVERAGE(volume) > $v$ \\
\hspace*{.5in}EPOCH DURATION\index{Epoch Duration} 5min
}

\noindent TinyDB\index{TinyDB} translates this query into an efficient
execution plan\index{query plan} which
delivers the set of occupied rooms every 5 minutes\index{epoch}.  Mary simply inputs this query
into a GUI\index{GUI} -- she writes no C\index{C} code and is freed from 
concerns about how to install her code, how to propagate results across
multiple network hops\index{hop}\index{multi-hop} to the root\index{root} of the network, how to power down sensors\index{sensor} 
during the time when they are not collecting and reporting data, and many other
difficulties associated with sensor-network\index{sensor network} programming.

We discuss the inner workings of TinyDB\index{TinyDB} on such queries in
Sections~\ref{sec:devel} and~\ref{sec:inside} below.  In the remainder of this section, we
present a high-level overview of the components\index{component} of TinyDB\index{TinyDB}.  The system
can be broadly classified into two subsystems:

\begin{enumerate}
\item \underline{Sensor Network\index{sensor network} Software:}  This is the heart of TinyDB\index{TinyDB}, although most users of
the system should never have to modify this code.  It runs on each
mote\index{mote} in the network, and consists of several major pieces:
\begin{itemize}
\item {\it Sensor\index{sensor} Catalog\index{catalog} and Schema\index{schema} Manager}:  The catalog\index{catalog} is responsible for tracking the
set of {\it attributes\index{attribute}}, or types of readings
(e.g.\ light, sound, voltage) and
properties (e.g.\ network parent\index{parent}, node\index{node} ID\index{ID}) available
on each sensor\index{sensor}.  In general, this list is not identical for each sensor\index{sensor}:  networks may consist
of heterogeneous collections of devices, and may be able to report
different properties.  (See
Section~\ref{sec:catalog} for details.)

\item {\it Query Processor\index{query processor}}:  The main component\index{component} of TinyDB\index{TinyDB} consists of a small query processor\index{query processor}.  
The query processor\index{query processor} uses the catalog\index{catalog} the fetch the values of local attributes\index{attribute}, receives sensor\index{sensor}
readings from neighboring\index{neighbor} nodes\index{node} over the radio, combines and aggregates\index{aggregate} these values together,
filters\index{filter} out undesired data, and outputs values to
parent\index{parent}s.  (See Section~\ref{sec:qp} for details.)

\item {\it Memory Manager}:  TinyDB\index{TinyDB} extends TinyOS\index{TinyOS} with a small, handle-based\index{handle}
  dynamic memory manager.  (See Section~\ref{sec:tinyalloc} for details.)

\item {\it Network Topology\index{topology} Manager}: TinyDB\index{TinyDB} manages the connectivity
  of motes\index{mote} in the network, to efficiently
  route\index{routing} data and query 
  sub-results through the network.  (See Section~\ref{sec:tinydbnetwork}
  for details.)
\end{itemize}
\item \underline{Java\index{Java}-based Client\index{client} Interface:}
A network of TinyDB\index{TinyDB} motes\index{mote} is accessed from a connected PC through the
{\em TinyDB\index{TinyDB} client\index{client} interface}, which consists
of a set of Java\index{Java} classes and applications.  These classes are all stored in the {\tt {\java}/tinyos/tinydb} 
package in the source tree.  The specific classes are described in Section \ref{sec:devel};  major
classes include:
\begin{itemize}
\item A network interface class that allows applications to inject queries and listen for results (Section~\ref{sec:tinydbnet}) 
\item Classes to build and transmit queries (Sections~\ref{sec:tinydbquery}, \ref{sec:tinydbaggop}, \ref{sec:tinydbselop})
\item A class to receive and parse query results (Section~\ref{sec:tinydbqueryresult})
\item A class to extract information about the attributes\index{attribute} and capabilities of devices (Section~\ref{sec:tinydbcatalog})
\item A GUI\index{GUI} to construct queries (Sections~\ref{sec:queryframe}, \ref{sec:queryfield})
\item A graph and table GUI\index{GUI} to display individual sensor\index{sensor} results (Sections~\ref{sec:resultframe}, \ref{sec:resultgraph}, \ref{sec:plot})
\item A GUI\index{GUI} to visualize dynamic network topologies (Section~\ref{sec:topology})
\item An application that uses queries as an interface on top of a network of sensors (Section~\ref{sec:app})\index{sensor}
\end{itemize}
\end{enumerate}

\section{Quick Start:  Running Queries with TinyDB\index{TinyDB}} \label{sec:runningqueries}

In this section, you will learn how to install TinyDB software, set up a network of TinyDB\index{TinyDB} motes\index{mote}, inject a query
into the network, and collect the results of the query.  

\subsection{Installation and Requirements}
TinyDB\index{TinyDB} requires a basic TinyOS\index{TinyOS} installation, with a working Java\index{Java}
installation (and javax.comm library).  
%For installation instructions
%on TinyOS\index{TinyOS}, see the \htmladdnormallink{TinyOS\index{TinyOS} web
%page}{http://webs.cs.berkeley.edu/tos}.
It is currently designed to work with the nesC compiler (next generation C-like language for TinyOS) 
and avr-gcc 3.1 \index{avr-gcc}\index{gcc} (not 3.0.1 as released with TinyOS 0.61).  To obtain these tools, download the 
nesC \index{nesC} alpha release from \htmladdnormallink{http://berkeley.intel-research.net/dgay/nesc/nesc-alpha.tar.gz}{http://berkeley.intel-research.net/dgay/nesc/nesc-alpha.tar.gz}, untar the file, and follow the instructions in alpha/README and alpha/INSTALL.

Although TinyDB is included with the nesC compiler, we recommend checking the latest 
version out from CVS;
%TinyDB\index{TinyDB} is not currently a part of an official TinyOS\index{TinyOS} release.  To obtain
%the code, you will need to check out a recent version of TinyOS from CVS;  
see the
\htmladdnormallink{TinyOS\index{TinyOS} CVS Page}{http://sf.net/cvs/?group_id=28656}
for instructions on using CVS.
In addition to the standard TinyOS\index{TinyOS} distribution, TinyDB includes a number of
additional files detailed in Appendix~\ref{app:files} of this document. The following table summarizes the software requirements of TinyDB: 

\par
\tiny
\begin{tabular}{|l|l|}
\hline
Required Software & Notes \\
\hline\hline
avr-gcc \index{avr-gcc}\index{gcc} & Version 3.1 or later \\ 
Java SDK \index{Java} & Version 1.3 or later \\
nesC compiler \index{nesC} & From the TinyOS alpha release \\
javax.comm tools & Version 1.3 or later, from IBM \\
TinyOS & From SourceForge CVS \\
\hline
\end{tabular}
\normalsize
\\

\noindent To verify that your installation is working properly, do the following:

\begin{enumerate}
\item Compile\index{compile} and install TinyDB\index{TinyDB} on the mote\index{mote}.  To do this, connect the mote\index{mote} to
the programming board\index{programming board}, then type the following:
\begin{itemize}
\item {\tt cd \docroot/apps/TinyDBApp/}
\item {\tt make mica}
\item {\tt make mica install}
\end{itemize}
If this fails, verify that your installation works (see the instructions on the web
site), and that you have all of the TinyDB\index{TinyDB} files listed above.

\item Compile\index{compile} and run the TinyDB\index{TinyDB}Main java\index{Java} classes.  To do this, type the following:
\begin{itemize}
\item {\tt cd {\java}/net/tinyos/tinydb}
\item {\tt make}
\item {\tt cd {\java}}
\item {\tt java net.tinyos.tinydb.TinyDBMain}
\end{itemize}

You'll need to make sure you have the following jar files in your classpath (they should all be available in {\tt {\java}/jars}):
\begin{itemize}
\item {\tt JLex.jar}
\item {\tt cup.jar}
\item {\tt plot.jar}
\end{itemize}

If you wish to take advantage of TinyDB's compatibility with the PostgreSQL\index{PostgreSQL} 
database system, you'll need 
to install and configure Postgres (see Section \ref{postgres}) 
 and include the {\tt pgjdbc2.jar} file in your classpath.

Your {\tt CLASSPATH} should now look something like this:

{\tt
.:{\it /path/to/java}/jre/lib/rt.jar:{\it /path/to/java}/lib/dt.jar:\\
{\it /path/to/java/}lib/tools.jar:/opt/IBMJava2-13/jre/lib/ext/comm.jar:\\
{\java}/jars/plot.jar:{\java}/jars/cup.jar:\\
{\java}/jars/JLex.jar
}

\end{enumerate}


\noindent You may see warnings about ``deprecated classes'' when {\tt
javac}\index{javac} runs.  These are OK, and you can ignore them.  After running
the java\index{Java} command, you should see the TinyDB\index{TinyDB} control
panel and query interface appear.

Once you have a working installation of these files, continue on to the next section
to learn how to run queries with TinyDB\index{TinyDB}.

\subsection{Setting up a Network of TinyDB\index{TinyDB} motes\index{mote}}

The first step is to program a number
of motes\index{mote} with the TinyDB\index{TinyDB} software.  Each of these motes\index{mote} must have a unique ID\index{ID};  recall that,
in TinyOS\index{TinyOS}, you can set the ID of a mote\index{mote} when running {\tt make install} by appending {\tt .node\index{node}id}
-- for example, to program a TinyDB\index{TinyDB} mote\index{mote} at ID 2, you would type:

\begin{itemize}
\item {\tt cd \docroot/apps/TinyDBApp/}
\item {\tt make mica install.2}
\end{itemize}

\noindent To run TinyDB\index{TinyDB}, you will need at least two
motes\index{mote}: one to act as the basestation
mote\index{basestation}, and one or more to distribute and run queries
over.  You may want to place a sticker on your chosen basestation
mote, since you will need to identify it visually. All
motes\index{mote}, including the basestation\index{basestation}, run
the same {\tt TinyDBApp} application, however, {\it the
basestation\index{basestation} mote\index{mote} must be set to ID\index{ID} 0.}

After programming your motes\index{mote}, connect the programming
board\index{programming board} to your computer via the serial
port\index{serial}, and place the basestation\index{basestation} mote\index{mote} in the programming
board\index{programming board}.  Turn on all of the motes\index{mote}.

Figure \ref{fig:setup} illustrates the basic setup of motes and PC.  

\begin{figure}[h]
\centering\leavevmode\psfig{figure=setup.eps,width=3in}
\caption{Two TinyDB motes set up to run a query.}
\label{fig:setup}
\end{figure}


\subsection{Running the TinyDB\index{TinyDB}Main GUI\index{GUI}}
\label{sec:GUI}
The TinyDB\index{TinyDB}Main Java\index{Java} application provides a graphical interface for distributing queries 
over motes\index{mote} and collecting data from them.  To run this application, type:

\begin{itemize}
\item {\tt cd {\java}/net/tinyos/tinydb}
\item {\tt make}
\item {\tt cd {\java}}
\item {\tt java net.tinyos.tinydb.TinyDBMain}
\end{itemize}

Two windows should appear; one, the {\it command}\index{command} window (Figure
\ref{fig:command}), allows you to send a variety of control commands
to the motes\index{mote}.  The other, the {\it query} window (Figure
\ref{fig:query}), allows you to build and send queries into the
network.  We will be focusing on the operation of the query window in
the next section; the command window is fairly self-explanatory.

The query window contains a {\bf Display Topology} button to show the
network topology. This button actually generates a particular query
that is executed by the motes, with results displayed in a special
visualization.  It is a good idea to display you network topology and
make sure that all your motes are alive and communicating.

Once you see that your network of motes is operational, you can
proceed to constructing queries.  

\vspace{.1in}
\renewcommand{\baselinestretch}{1.0}\rm
\fbox{\parbox{.9\columnwidth}{
{\bf TIP:} If you have difficulty sending queries
into the network, verify that your AM group ID is set the same in
TinyOS and in the TinyDB Java client.  In TinyOS, the AM group
is set in {\tt \docroot/tos/system/AM.h} in the variable {\tt
TOS\_AM\_GROUP}.  In TinyDB, the AM group is set via the config file
variable {\tt am-group-id} which is stored in {\tt \java/tinydb.conf};
see Section \ref{sec:configfile} for more information.}}
\renewcommand{\baselinestretch}{1.2}\rm

\begin{figure}
\begin{minipage}{4in}
\begin{center}
\leavevmode
{\psfig{figure=querywin.eps,width=3in}}
\end{center}
\caption{Query Window}
\label{fig:query}

\end{minipage}
\hspace{.5in}
\begin{minipage}{2in}
\begin{center}
\leavevmode
{\psfig{figure=commandwin.eps,width=1.5in}}
\end{center}
\caption{Command Window}
\label{fig:command}
\end{minipage}
\end{figure}

\section{Using TinyDB\index{TinyDB}}
\label{sec:queries}
TinyDB provides a high-level, {\em declarative}\index{declarative}
language for specifying queries.  In a declarative language you
describe {\em what} you want, but not {\em how} to get it.
Declarative languages are advantageous for two reasons.  First, they
are relatively easy to learn, with queries that are easy to read and
understand.  Second, they allow the underlying system to change how it
runs a query, without requiring the query itself to be changed.  This
is important in a volatile context like sensor networks, where the
best underlying implementation may need to change frequently --
e.g. when motes move, join or leave the network, or experience
shifting radio interference.  In TinyDB, the execution strategy for a
user query can change each time the query is run, or even {\em while}
the query runs, without any need for re-typing the query or
recompiling an application that embeds the query.

Before describing TinyDB's query facilities, a few words on
TinyDB's data model are in order.  TinyDB implicitly queries one
single, infinitely-long logical table\index{table} called {\tt sensors}.  This
table has one column for each attribute in the catalog\index{catalog}, including
sensor attributes, nodeIDs\index{ID}, and some additional ``introspective''\index{introspection}
attributes (properties) that describe a mote's state.  This table conceptually
contains one row for each reading generated by any mote, and hence the
table can be thought of streaming infinitely over time.  A given mote
may not be able to generate all the attributes, e.g., if it does not
have the sensor that generates the attribute.  In that case, the mote
will always generate a NULL value for that attribute.

TinyDB's query language is based on SQL\index{SQL}, and we will refer
to it as TinySQL\index{TinySQL}.  As in SQL, queries in
TinySQL\index{TinySQL} consist of a set of
attributes\index{attribute} to select (e.g. light, temperature), a set
of {\it aggregation\index{aggregation} expressions\index{expression}}
for forming aggregate result columns, a set of {\it
selection\index{selection} predicates\index{predicate}} for filtering\index{filter}
rows, and optionally a grouping\index{group} expression for
partitioning the data before aggregation.  Aggregation
is commonly used in the sensor environment.  

Currently, TinySQL\index{TinySQL} results are very similar to SQL\index{SQL}, in that they
are based on snapshots\index{snapshot} in time -- that is, they are
posed over rows generated by multiple sensors\index{sensor} at one
point in time.  {\it Temporal}\index{temporal} queries that combine
readings over several time periods are not supported in the current
release.  Instead, TinySQL runs each query repeatedly, once per
time-period or ``epoch''\index{epoch}.  The duration of an epoch can be specified
as part of a TinySQL query; the longer the duration, the less
frequent the results, and the less drain on the mote\index{mote} batteries\index{battery}.


\subsection{The Query Window}
\label{sec:querywindow}
The query window provides a graphical interface for building queries.
As you use the widgets in the window, query text is dynamically
constructed in the text box in the middle of the screen.  This box is
also used for error messages.

\vspace{.1in}
\renewcommand{\baselinestretch}{1.0}\rm
\fbox{\parbox{.9\columnwidth}{
{\bf TIP:}The current query text can
always be refreshed by clicking on a column in the {\bf Available
Attributes} list.}}
\renewcommand{\baselinestretch}{1.2}\rm
\vspace{.1in}

The topmost widget in the window is the {\bf Epoch
  Duration}\index{Epoch Duration}\index{epoch} widget,
which specifies the interval at which the query is re-evaluated.
% Motes periodically take sensor readings from the environment, called
% {\em samples}\index{sample}, in order to generate rows in the {\tt
% sensors} table.  
We recommend that the epoch duration be set as large as possible to
minimize power drain on the motes\index{mote}.

To specify the query to run each epoch\index{epoch}, you first choose the
attributes and/or aggregate expressions\index{expression} to appear in the output.
Attributes are specified by choosing them in the {\bf Available
Attributes} list, and pressing the ``$>>>$'' button so that they
appear in the {\bf Projected Attributes} list.  Optionally, attributes
may be placed in simple {\em aggregate}\index{aggregate} {\em
expressions}\index{expression} by choosing an aggregate from the
pull-down menu in the middle of the screen (default: {\bf None}).  At
this stage, the Projected Attributes list must
contain either all aggregate expressions, or all attributes; a mixture
will result in an error message unless there is a GROUP BY\index{Group By}\index{group}
clause.  We will return to this point shortly.

To select only some of the rows to be considered in the query, you can
specify predicates\index{predicate} to filter\index{filter} the data,
via the {\bf New Predicate} button at the bottom of the screen.  All
the predicates you select will be implicitly ``AND''ed together.  ``OR'' is
not yet supported.

If you used aggregate expressions\index{expression} in your {\bf Projected
Attributes} list, you can also specify a GROUP BY\index{Group By}\index{group} column by
clicking on the {\bf GROUP BY} checkbox and selecting from the
pulldown menu.  The pulldown menu to the right of the GROUP BY column
is for right-shifting the (binary) value of the column before
grouping; each shift divides the value of the GROUP BY column by 2.
This has the effect of reducing the number of possible groups: the
more times you divide by 2, the fewer possible groups there can be.

After adding a GROUP BY\index{Group By}\index{group} column, you can now add it (unaggregated!) to
the {\bf Projected Attributes} by selecting it from the {\bf Available
Attributes} list and pressing the ``$>>>$'' button.  This is the only
way to mix aggregates and attributes in your query
output\footnote{Note that this restriction also exists in SQL\index{SQL}, and is
implicit in the meaning of aggregation.  The only non-aggregated
attributes that are meaningful in the SELECT list are attributes that
appear in the GROUP BY list.  As an example, consider a query
with {\em no} GROUP BY attributes.  It can only produce one output row
per epoch\index{epoch}, which contains aggregate values computed from all the
input rows.  It is not meaningful to ask for a raw attribute in the
output of such a query -- there can be multiple values for each
attribute in the input, so there is no well-specified unique value to
place in the single output column.  The same restriction applies in a
GROUP BY query, with the exception of the columns in the GROUP BY
expression\index{expression} -- these columns are guaranteed to have a
single unique value per group, and hence can appear alongside aggregate
expressions.}.

\subsubsection{Triggers}\label{sec:triggers}\index{triggers}

TinyDB includes a facility for simple {\it triggers}\index{triggers}, or queries
that execute some command when a result is produced.  Currently, triggers can be
executed only in response to some local sensor reading that satisfies the conditions
specified in the {\tt WHERE} clause of the query.  {\it Aggregate queries cannot
have triggers associated with them.}  Whenever a query result satisfies the
{\tt WHERE} clause of a query, the {\it trigger action}\index{trigger action} is executed.  This
action is a named command stored in the schema of the mote (see Section \ref{sec:schema}
for more information.)  

The current TinyDB interface includes simple trigger actions\index{trigger action} for blinking LEDs and
sounding the sounder \index{sounder} (the small speaker on the Mica sensor board.)  A trigger
action can be specified via the GUI by clicking the {\tt TRIGGER ACTION} checkbox and selecting the appropriate
action.  Other actions can be specified via the textual interface (see the next section) and the schema
API (described in Section \ref{sec:schema}.)  

As an example of what triggers can be used for, consider an application where the user wants to sound
an alarm whenever the temperature near a sensor goes above some threshold.  This can be accomplished
via the simple trigger query:

\noindent{\tt \hspace{.5in}SELECT temp\\
\hspace*{.5in}FROM sensors \\
\hspace*{.5in}WHERE temp > {\it thresh}\\
\hspace*{.5in}TRIGGER ACTION SetSnd(512) \\
\hspace*{.5in}EPOCH DURATION 512
}

\noindent The {\tt SetSnd} command sounds the sounder, and the value of 512 specfies a sound duration of
512 ms.



\subsection{Composing Your Own TinyDB Queries}
\label{sec:tinydbsqlsyntax}
When using TinyDB, it is also possible to write queries by
hand, either by using the ``Text Interface'' pane of the the GUI\index{GUI}
(which can be brought up by default by using the command-line \index{command-line} argument ``-text''), 
or via the {\tt SensorQueryer.translateQuery} API\index{API} call.  We assume here that
the reader has a familiarity with the basics of SQL\index{SQL}.  A number of
books and websites provide simple SQL tutorials.  No deep knowledge of
SQL is required to use TinyDB; the basics will do.  The simplest way
to learn TinySQL\index{TinySQL} is to use the graphical query
builder described in Section~\ref{sec:querywindow}.  However, we also
provide a simple, informal description of the syntax here.

TinyDB provides an SQL\index{SQL}-like query language, which is simplified in a
number of ways, but which also provides some new sensor-specific syntax.
TinySQL\index{TinySQL} queries all have the form:

\noindent{\tt \hspace{.5in}SELECT {\em select-list}\\
\hspace*{.5in}[FROM sensors] \\
\hspace*{.5in}WHERE {\em where-clause}\\
\hspace*{.5in}[GROUP BY {\em gb-list} \\
\hspace*{.5in}[HAVING {\em having-list}]]\\
\hspace*{.5in}[TRIGGER ACTION {\em command-name}[({\em param})]] \\
\hspace*{.5in}[EPOCH DURATION {\em integer}]

}
 
The {\tt SELECT}\index{Select}, {\tt WHERE}\index{Where}, {\tt GROUP
  BY}\index{Group By}\index{group} and {\tt HAVING}\index{Having} clauses
are very similar to the functionality of SQL\index{SQL}.
Arithmetic\index{arithmetic} expressions\index{expression} are
supported in each of these clauses.  As in standard SQL, the {\tt
GROUP BY}\index{Group By} clause is optional, and if {\tt GROUP BY} is
included the {\tt HAVING}\index{Having} clause may also be used optionally.

\subsection{TinySQL\index{TinySQL} vs. Standard SQL\index{SQL}}

\noindent
{\bf Limitations}
\begin{itemize}
\item The {\tt FROM}\index{From} clause must always list exactly one table\index{table},
entitled {\tt sensors}.  The {\tt FROM}\index{Having} clause is also optional.
\item In the current version the {\tt WHERE}\index{Where} and {\tt HAVING}\index{Having} clauses
can contain only simple conjunctions over arithmetic\index{arithmetic} comparison
operators.  There is no support for the Boolean operators {\tt OR}\index{Or} and
{\tt NOT}\index{Not}, or string matching\index{string matching} comparisons
(SQL's\index{SQL} {\tt LIKE}\index{Like} and {\tt SIMILAR}\index{Similar}
constructs).
\item  There is currently no support for sub-{\tt SELECT}s\index{Select} (subqueries)\index{subquery}.
\item There is currently no support for column renaming (SQL's\index{SQL} {\tt
  AS}\index{As} construct) in the {\em gb-list}.
\item Arithmetic\index{arithmetic} expressions\index{expression} are currently limited to the form {\em
  column op constant}, where {\em op} is one of \{$+, -, *, /$\}.
\end{itemize}

\noindent
{\bf Sensor-Specific Features}\\

The {\tt TRIGGER ACTION} clause specifies an (optional) trigger action\index{trigger action} that
should be executed whenever a query result is produced.  See Section \ref{sec:triggers}
for more information about triggers.  The command name must be a command registered with the
{\tt COMMAND} \index{command} component (see Section \ref{sec:schema}.)  An optional integer
parameter may be passed to the command.

The time between epochs\index{epoch} is specified in the query via the {\tt EPOCH
DURATION}\index{Epoch Duration} clause.  The units for this duration are specified in
milliseconds.  If no epoch duration is specified, a value of 1024 ms is used
by default.

\subsection{The Command Line}\label{sec:commandline}
TinyDB provides a few simple command line \index{command line} options, as follows:

\begin{itemize}
\item {\tt -text}: Start the GUI in the text panel.\index{GUI}
\item {\tt -gui}: Start the GUI in the graphical query input window (default.)
\item {\tt -cmdwindow}: Display the command window (overrides the config file (see Section \ref{sec:configfile}) setting.)
\item {\tt -configfile {\it filename}}: Loads the config file from {\it filename}.\index{configuration}
\item {\tt -run ``{\it query}'' }: Executes the specified query in text-mode (see Section \ref{sec:textmode}.)\index{text mode}
\item {\tt -debug}: Enable debugging messages (causes lots of messages to be printed on the command line.
\end{itemize}

\subsection{The Config File}\label{sec:configfile}

TinyDB uses a configuration file\index{configuration} to configure some of its settings;  
this file is called ``tinydb.conf''\index{tinydb.conf} in the {\tt \java/tinyos/tinydb}
directory.  This file consists of colon (``:'') delimited pairs of settings and values.
Blank lines and comments beginning with ``\%'' are also allowed.  Table \ref{tab:config}
summarizes the major configuration file options.  The configuration file
is read once when the TinyDB application starts.

Settings in the configuration file are available to TinyDB java components via static
methods in the {\tt Config.java} class.  {\tt Config.init(...)} is called when {\tt TinyDBMain}
is instantiated.  Components can call {\tt Config.getParam(...)} to retrieve the value
of a setting;  if the setting has no value, {\tt null} is returned.

\begin{table*}[tb]
\noindent
\tiny
\begin{tabular}{|c|l|l|l|}
\hline
Option & Description & Possible Values & Default \\
\hline\hline
show-command-window & Should the command window (see Figure \ref{fig:command}) be shown? & true, false & true \\
am-group-id & The AM group with which TinyDB motes have been programmed & 0-255 & 125 \\
default-query & The default query to show in the TinyDB text command window & Any string & none \\
postgres-user & The name of the Postgres user (see Section \ref{postgres} below) & Any string & none \\
postgres-passwd & The password (if any) for the specified user  & Any string & none \\
postgres-db & The name of database where TinyDB results should be logged  & Any string & none \\
postgres-host & The IP-address or hostname of a TCP-enabled Postgres server & A valid IP address & none \\
start-sf & Should TinyDB automatically start a serial forwarder? & true, false & true \\
sf-host & The hostname of the serial forwarder to contact (if start-sf is false) & A valid IP address & localhost\\
sf-port & The port the serial forwarder is running on & 1-65535 & 9000 \\
\hline

\end{tabular}
\caption{Config file options and default values}\label{tab:config}
\normalsize
\end{table*}

\subsection{Text Mode}\label{sec:textmode}

TinyDB provides a very simple text mode \index{text mode} for running queries (when using the {\tt -run} command line option.)
Query results are printed out to the console \index{console};  motes are reset each time a new query is posed (no interface
to stop a currently running query or run multiple queries is currently available via this interface.)

\noindent For example, posing the command (in a single mote network):
\\
\\
{\tt java net.tinyos.tinydb.TinyDBMain -run ``select nodeid,light epoch duration 1024''}\\
\\
produces output resembling:
\\
\noindent
\begin{verbatim}
|    Epoch   |  nodeid  |    light  |
-------------------------------------
      3      |    12    |    860    |
      4      |    12    |    860    |
      5      |    12    |    861    |
      8      |    12    |    860    |
      9      |    12    |    879    |
      11     |    12    |    860    |
      12     |    12    |    860    |
...

\end{verbatim}

\subsection{The LEDS}\index{LEDS}

The LEDS\index{LEDS} on TinyDB motes are used to indicate the current status of the device;  each LED is used
to communicate one of several pieces of information, depending on the current status of the
mote.  A simple selection query should cause the mote to blink its yellow LED once per epoch, and its
red LED once per data value forwarded up the tree. The following table summarizes other
LED actions by mote status:

\vspace{.1in}
\tiny
\noindent
\begin{tabular}{|l|l|l|}
\hline
Mote Status & LED Response & Notes \\
\hline\hline
Sent Message & Red Toggle & \\
Received Aggregate From Child & Green Toggle & \\
End of Epoch & Yellow Toggle & Once per query \\
Aborted Query & All LEDS On & \\
Reset Mote & All LEDS Flash & \\
\hline
\end{tabular}
\normalsize
\\

\section{Developing For TinyDB\index{TinyDB}: Java\index{Java} API\index{API}}
\label{sec:devel}
Up to this point, we have described how to use TinyDB from the
provided GUI.  However, developers will want to embed TinySQL\index{TinySQL}
queries and fetch TinyDB result rows from within application programs.
TinyDB\index{TinyDB} provides a Java\index{Java} API\index{API} for
building such programs, which we describe here.  The provided
GUI\index{GUI} application is a good example of the use of the API,
so we describe it here as well.

We begin with an overview of the API\index{API}, and go on to an
overview of the GUI\index{GUI} program, which exercises the
API\index{API}.  The discussion here is fairly high level, and is
intended to accompany some investigation of the code itself.

\subsection{The TinyDB\index{TinyDB} Java\index{Java} API\index{API}}
The API\index{API} contains a number of objects encapsulating the
TinyDB network, the TinyDB catalog\index{catalog}, the construction of TinyDB
queries, and the manner in which the application listens for and
interprets query results.  These objects appear in the corresponding
{\tt .java} files in {\tt \java/tinyos/tinydb}.

\subsubsection{\tt TinyDB\index{TinyDB}Network} 
\label{sec:tinydbnet}
This object is the main interface to a
  network of motes\index{mote}.  It is responsible for injecting new queries into
  the network ({\tt sendQuery()}), for cancelling queries ({\tt
  abortQuery()}), and for providing results from the network to
  multiple query ``listeners''\index{listener}.  Only one instance\index{instance} of the {\tt
  TinyDB\index{TinyDB}Network} object needs to be allocated for a network; that
  instance can manage multiple ongoing queries, and multiple
  listeners.  Each query's output can be sent to multiple listeners,
  and each listener can listen either to a single query, or to all
  queries.
  
  Internally, the object maintains a list of live queries, and three
  sets of listeners\index{listener}:
  \begin{enumerate}
	\item {\tt processedListeners} are signed up for a specific query
    ID\index{ID}, and get a stream of final (``processed''\index{processed}) answer tuples\index{tuple} for
    that query.
	\item {\tt qidListeners} are signed up for a specific query ID\index{ID},
    and get copies of all messages that arrive for that query.  These
    messages may not be final query answers.  They may be individual
    attributes\index{attribute} from an answer tuple\index{tuple}, or unaggregated\index{aggregate} sub-result
    tuples\index{tuple}.
	\item  {\tt listeners} are signed up to receive a copy of all
    unprocessed\index{processed} messages for {\em all} queries.  
  \end{enumerate}
  The various listeners\index{listener} can be added or deleted to the object on the
  fly via {\tt addResultListener()} and {\tt removeResultListener()}
  -- note that different arguments to the {\tt addResultListener}
  method result in one of the 3 different kinds of listeners above.

  The {\tt TinyDB\index{TinyDB}Network} object handles all incoming
  AM\index{Active Messages (AM)}\glossary{AM} messages from the
  serial port\index{serial}, and dispatches copies of them to the {\tt listeners}\index{listener}
  and {\tt qidListeners} accordingly.  It also processes the messages
  to generate result tuples\index{tuple} (via {\tt QueryResult.MergeQueryResult()})
  and sends them to {\tt processedListeners}\index{processed} accordingly.  As part of
  processing results, it maintains info on epochs\index{epoch} to make sure that
  the epoch\index{epoch} semantics\index{semantics} of the results are correct.

  Internally, the {\tt TinyDB\index{TinyDB}Network} object also has a background thread
  that participates in the sensor network's\index{sensor network} routing\index{routing} algorithms.  It
  periodically sends information down the routing\index{routing} tree, so that
  children know to choose the root\index{root} as a parent\index{parent}, and so that children
  can decide how to share the timeslots\index{timeslot} in an
  epoch\index{epoch}.  
% {\bf Note dependency here: programmers wanting to hack the
% topology\index{topology} code need to hack here too.}

\subsubsection{\tt SensorQueryer}
This class appears in the {\tt parser} subdirectory.  It represents a
simple parser for TinySQL\index{TinySQL}.  The main method of interest is {\tt
translateQuery}, which takes an SQL\index{SQL} string and returns a corresponding
{\tt TinyDBQuery} object, which we proceed to describe next.

\subsubsection{\tt TinyDB\index{TinyDB}Query} 
\label{sec:tinydbquery}
This is a Java\index{Java} data structure representing a
    query running (or to be run) on a set of motes\index{mote}.
    
    Queries consist of:
    \begin{itemize}
    \item a list of attributes\index{attribute} to select
    \item a list of expressions\index{expression} over those attributes, where an expression\index{expression}
    is
      \begin{itemize}
      \item a filter\index{filter} that discards values that do not match a
      boolean expression\index{expression}
      \item an aggregate\index{aggregate} that combines local values
        with values from
        neighbors\index{neighbor}, and optionally includes a GROUP
        BY\index{Group By}\index{group} column.  
% {\bf
%         (Hack: GROUP BY\index{Group By} columns can optionally be bit-shifted before
%         the grouping\index{group} happens, to make for fewer groups\index{group} (buckets) on a
%         dense domain.  This is called ``attenuation\index{attenuation}'' in the API\index{API}.)}
%         {\bf (Limitation: GROUP BY\index{Group By} can currently only be done on a
%        single attribute\index{attribute}, and not on multiple
%        attribute and/or expressions\index{expression}.)} 
      \end{itemize}
    \item an SQL\index{SQL} string that should correspond to the expressions\index{expression}
    listed above.

    \end{itemize}

   In addition to allowing a query to be built, this class includes
   handy methods to generate specific radio messages for the query,
   which {\tt TinyDB\index{TinyDB}Network} can use to distribute the query over the
   network, or to abort the query.

   It also includes a support routine for printing the query result
   schema\index{schema}.

\subsubsection{\tt QueryResult}
\label{sec:tinydbqueryresult}
This object accepts a query result in the
    form of an array of bytes read off the network, parses the results
    based on a query specification, and provides a number of utility
    routines to read the values back.  It also provides the {\tt
    mergeQueryResult} functionality for {\tt processedListeners}\index{processed}\index{listener}.
    This does concatenation of multiple aggs as separate attributes of
    a single result tuple, and finalizes aggregates\index{aggregate}, by
    combining data from multiple sensors\index{sensor}.

\subsubsection{\tt AggOp} 
\label{sec:tinydbaggop}
This provides the code for the aggregation\index{aggregation}
  operators SUM, MIN, MAX, and AVERAGE.  It includes representation
  issues (internal network codes for the various ops, and code for
  pretty-printing), and also the logic for performing final merges for
  each aggregate\index{aggregate} as part of {\tt QueryResult:MergeQueryResult()}.
%  {\bf This is another place you need to touch if you want to add your
%  own aggs.}

\subsubsection{\tt SelOp}  
\label{sec:tinydbselop}
This provides the logic for selection\index{selection} predicates\index{predicate}.
  Currently this includes representations for simple arithmetic\index{arithmetic}
  comparisons (internal network codes for the arithmetic comparators,
  and pretty-printing.)

\subsubsection{\tt Catalog\index{catalog}}  
\label{sec:tinydbcatalog}
This object provides a very (very!) simple parser
  for a catalog\index{catalog} file -- it reads in the file, and after parsing it
  provides a list of attributes\index{attribute}.

\subsubsection{\tt CommandMsgs} This is a class with static functions to
    generate message arrays that can be used to invoke commands on TinyDB
    motes\index{mote}.

\subsection{The TinyDB\index{TinyDB} Demo Application}
\label{sec:app}
The TinyDB\index{TinyDB} application allows users to interactively specify queries
and see results.  It also serves as an example of an application that
uses the TinyDB\index{TinyDB} API\index{API}.  As with traditional database systems, it is
expected that many programmers will want to embed queries within more
specialized application code.  Such programmers can look at the TinyDB\index{TinyDB}
application for an example of how this is done.

The TinyDB\index{TinyDB} application consists of only a few objects:
\subsubsection{\tt TinyDB\index{TinyDB}Main}
\label{sec:tinydbmain}
This is the main loop for the application.  It
  opens an {\em Active Message (AM)}\index{Active Messages (AM)} connection to
  the Serial Port\index{serial} (``COM1''\index{COM1}), and uses it to initialize a {\tt
  TinyDB\index{TinyDB}Network} object.  It
  allocates the GUI\index{GUI} objects {\tt CmdFrame} and {\tt QueryFrame} for
  the application, which issue queries and in turn generate visualizations
  of results.  There are also some simple wrapper routines for
  the {\tt TinyDBNetwork} methods to add and remove queries from listeners\index{listener}.


\subsubsection{\tt CmdFrame}\
This is a simple GUI\index{GUI} for sending TinyDB\index{TinyDB} commands
  (from the {\tt CommandMsgs} API\index{API} object) into the network.  See Figure~\ref{fig:command}.

\subsubsection{\tt MainFrame}\label{sec:cmdframe}\label{sec:queryframe}
This is the main GUI\index{GUI} for building queries with TinyDB, as shown in Figure \ref{fig:query}.  
It provides a simple API for generating new query ID's and processing keyboard input.  The buttons along
the right send either send the current query being built (``Send Query'') into the network for
execution, or execute a predefined query, as follow:

 \begin{enumerate}
  \item {\bf Display Topology}: A visualization of the network topology\index{topology}, which is extracted
  from the network via a standard TinyDB\index{TinyDB} query.

  \item {\bf Mag.\ Demo}\index{magnetometer}: A visualization of magnetometers laid out in a fixed $x \times
  y$ grid. This is an example of simple demo application that can run on
  TinyDB:  in this case, TinyDB is used to identify sensors with 
  magnetometer readings greather than some threshold to detect metallic
  objects moving through a grid of motes\index{mote}. 
  \end{enumerate}

The major portion of the GUI contains a tabbed pane that provides
two different interfaces for inputting queries:

\begin{enumerate}
\item{\bf {\tt GuiPanel}}: A graphical query builder to construct a valid
{\tt TinyDB\index{TinyDB}Query} object and send it into the network via {\tt
TinyDB\index{TinyDB}Network.sendQuery()} (Figure~\ref{fig:query}.)  In addition to
allowing users to specify ad hoc queries\index{ad hoc}, it provides a button to
send off two pre-prepared queries that have special visualizations:
\item{\bf {\tt TextPanel}}:A textual query editor that allows queries to be input
in TinySQL\index{TinySQL} language.  See \ref{sec:tinydbsqlsyntax} for more information.
\end{enumerate}
  
\subsubsection{\tt QueryField}
\label{sec:queryfield}
Simple support routines for handling
attributes\index{attribute} in the query builder.

\subsubsection{\tt ResultFrame}
\label{sec:resultframe}
ResultFrame displays a scrolling list with
    results from queries in it, side-by-side with a graph of query
    results when such results are available.  For each query, it adds
    a {\tt processedListener}\index{processed}\index{listener} to the {\tt TinyDB\index{TinyDB}Network} in order to
    receive the results, which it plots via {\tt ResultGraph}.

\subsubsection{\tt ResultGraph} 
\label{sec:resultgraph}
A simple wrapper for the {\tt plot} package, to
  interactively graph query results.

\subsubsection{\tt plot}
\label{sec:plot}
A graph-plotting package from the Ptolemy project\index{Ptolemy}.  More information about the Ptolemy is available on the \htmladdnormallink{Ptolemy home page}{http://ptolemy.eecs.berkeley.edu/java/ptplot/}.

\subsubsection{\tt topology\index{topology}}
\label{sec:topology}
A set of classes for constructing the TinyDB\index{TinyDB}
  network-topology\index{topology}-extraction query, and for displaying the results as
  a (dynamic) topology\index{topology} graph.

\subsubsection{\tt MagnetFrame}
\label{sec:magnetframe}
MagnetFrame is a simple visualization to
    display an $x \times y$ array that represent a grid of sensors\index{sensor} and
    to darken circles representing sensors\index{sensor} whose magnetometer readings
    go above some threshold.  This was used for a demo that tracked
    the movement of a magnet mounted on a matchbox car.
    
    MagnetFrame runs a simple query of the form
    
    {\tt SELECT nodeid, mag\_x FROM sensors WHERE mag\_x $> m$
    EPOCH DURATION 256}\index{epoch}\index{Epoch Duration}


\section{Inside TinyDB\index{TinyDB}} \label{sec:inside}
The prior discussion was been directed to TinyDB administrators,
users, and application developers.  This section is targeted at
readers who are interested in extending or modifying the internals of
the TinyDB\index{TinyDB} code that runs on the motes\index{mote}.

We assume that the reader of this section is familiar with code
development for the Berkeley motes\index{mote} in the
TinyOS\index{TinyOS} framework.  For documentation and tutorials on
TinyOS, please see the \htmladdnormallink{TinyOS\index{TinyOS} web
page}{http://webs.cs.berkeley.edu/tos}.

In this section we discuss the TinyOS components\index{component} that
make up TinyDB.  The component\index{component} diagram for TinyDB --
including the TinyOS components it references -- is shown in
Figure~\ref{fig:components}.

\begin{figure}[ht]
\psfig{file=circuit.eps,width=6in}
\caption{Component\index{component} diagram.  TinyDB\index{TinyDB}-specific components\index{component} are in the
  bold font.}
\label{fig:components}
\end{figure}

\subsection {The TinyDB\index{TinyDB} Sensor\index{sensor} Catalog\index{catalog} and Schema\index{schema} Manager}
\label{sec:catalog}

A {\em schema\index{schema}} describes the capabilities of the motes\index{mote} in the system as a
single virtual, database ``table\index{table}''.  This table\index{table} can contain any number
of typed {\em attributes\index{attribute}}.  It can also contain handles to a set of
{\em commands} that can be run within the query executor, much like ``methods'' in the Object-Relational\index{Object-Relational}
extensions to SQL\index{SQL}.

During query processing, sensor\index{sensor} readings from each mote\index{mote} are placed
into {\em tuples\index{tuple}}, which may be passed between motes\index{mote} for multi-hop\index{hop}\index{multi-hop}
routing\index{routing} and/or aggregation\index{aggregation}, or which may be passed out the serial port\index{serial}
at the top of the network to the front-end\index{front-end} code.

\subsubsection{\tt Attr and Command\index{schema}\index{Command}\index{Attr}}
\label{sec:schema}
The {\tt Attr\index{Attr}} and {\tt Command\index{Command}} components\index{component} contain the code 
to manage the schema \index{schema} of the mote\index{mote}. The schema consists
of tables\index{table} of
typed attributes\index{attribute} and commands, and associated routines to
update and query these tables.

The {\tt Attr.td} component implements the {\tt AttrRegister.ti} and {\tt AttrUse.ti} interfaces
for getting and setting the values of attributes.  

Schema\index{schema} commands\index{command} can be invoked locally via ({\tt
CommandUse.invoke}), and to send a message to invoke schema\index{schema}
commands on other nodes\index{node} ({\tt CommandUse.invokeMsg}), both of
which are implemented by the {\tt Command.td} module.

See the {\em TinySchema} document for complete details on how to manage
attributes and commands for TinyDB.

\subsubsection {\tt TinyDBAttr}
\label{sec:attr}
This simple component\index{component} is the hub for all the
builtin attributes of TinyDB.  It wires all the components that
implement the builtin attributes together.  This component
must be updated if you add a new component that implements
new attributes for TinyDB.

\subsubsection {\tt TinyDBCommand}
\label{sec:attr}
This simple component\index{component} is the hub for all the
builtin commands of TinyDB.  It wires all the components that
implement the builtin commands together.  This component
must be updated if you add a new component that implements
new commands for TinyDB.

% {\bf TIP ON EXTENSIONS:}
% If additional attribute\index{attribute} components\index{component} are added to the system, they
% should be added to the initialization code here to make it into the
% schema\index{schema}.

\subsubsection{\tt Tuple\index{tuple}}
This component\index{component} provides fairly straightforward utilities to manage the
{\tt Tuple\index{tuple}} data structure, as defined in {\tt TinyDB.h}.

\subsubsection {\tt QueryResult}
This component\index{component} converts between {\tt Tuple}s\index{tuple}, {\tt QueryResult}s,
and byte-strings.  These data structures are all defined in {\tt
\docroot/tos/lib/TinyDB/TinyDB\index{TinyDB}.h}.  Briefly, a {\tt Tuple}\index{tuple} is a typed vector
of values, as in SQL\index{SQL}; a {\tt QueryResult} holds a tuple\index{tuple} and some
metadata, including the query ID\index{ID}, an index into the result set, and an
epoch\index{epoch} number.

%\subsubsection {\tt MAGNET}
%This component\index{component} is basically a temporary hack to access readings from
%the magnetometers on the Rene motes\index{mote}.  In general, device-specific code
%is to be provided by the general-purpose TinyOS\index{TinyOS} libraries.
%(Section~\ref{sec:devices}).


\subsection{TinyDB\index{TinyDB} Query Processing Operators}
\label{sec:qp}
% \subsubsection {\tt TUPLE\_READER}
\subsubsection {\tt TupleRouter}
This deceptively-named component\index{component} provides the main query processing
functionality on a mote\index{mote}.  As Figure~\ref{fig:components} makes clear,
{\tt TupleRouter} is at the heart of the TinyDB\index{TinyDB} system.  It is called
a tuple\index{tuple} ``router'' because it routes tuples\index{tuple} through a variety of {\em
local} query processing components\index{component}.
% in the spirit of {\em eddies}~\cite{eddies}.  
{\em This component\index{component} does not do network
routing\index{routing}!}  For information on network routing\index{routing} in TinyDB\index{TinyDB}, see the
component\index{component} {\tt NetworkC.td} (Section~\ref{sec:tinydbnetwork}).

The {\tt TupleRouter} component\index{component} contains three main execution
paths:
\begin{itemize}
\item Handling of new query messages
\item Result computation and propagation (each time a clock event goes off)
\item Subtree result message handling
\end{itemize}
We discuss these in turn.

\vspace{1em}
\noindent{\bf Handling New Queries}\\
New queries arrive in {\tt TupleRouter} via the {\tt Network.queryMsg} event.  Each query
  is assumed to be identified by a globally unique ID\index{ID}, which must be
  generated by the Java\index{Java} front-end\index{front-end} APIs\index{API}.  Query
  messages contain a part of a query: either a single field (attribute\index{attribute}) to
  retrieve, a single selection\index{selection} predicate\index{predicate} to apply, or a single
  aggregation\index{aggregation} function to apply.  All the {\tt QueryMessage}s describing a
  single query must arrive before the router will begin routing tuples\index{tuple}
  for that query.

Once all the {\tt QueryMessage}s have arrived, the router calls
  {\tt parseQuery()} to generate a compact representation of the query in
  which field names have been replaced with field IDs\index{ID} that can be used
  as offsets into the sensors\index{sensor} local catalog\index{catalog} ({\tt Schema}\index{schema}).
  
Given a {\tt parsedQuery}, the tuple router allocates space at the end
  of the query to hold a single, ``in-flight'' tuple\index{tuple} for that query --
  this tuple\index{tuple} will be filled in with the appropriate data fields as the
  query executes.
  
{\tt TupleRouter} then calls {\tt setSampleRate()}\index{sample} to start (or restart) the
  mote\index{mote}'s 32khz clock to fire at the appropriate data-delivery rate for
  all of the queries currently in the system.  If there is only one
  query, it will fire once per ``epoch\index{epoch}'' -- if there are multiple queries,
  it will fire at the greatest common divisor of the delivery intervals of all the queries.

\vspace{1em}
\noindent{\bf Tuple\index{tuple} Delivery}\\
Whenever a clock event occurs in {\tt TupleRouter} ({\tt Timer.fired}), the
  router must perform four actions:
\begin{enumerate}

\item Deliver tuples\index{tuple} that were completed on the previous clock event
  ({\tt deliverTuplesTask}).  If the query contains an aggregate\index{aggregate},
  deliver the aggregate\index{aggregate} data from the aggregate\index{aggregate} operator;  if not,
  deliver the tuple\index{tuple} that was filled out during the last
  iteration. Reset the counters that  indicate when these queries
  should be fired again.
  
\item Decrement the counters for all queries.  Any queries whose
  counters reach 0 need to have data delivered.  Reset the
  expression\index{expression}-specific state for these queries (this is specific
  to the expressions\index{expression} in the queries -- {\tt MAX} aggregates\index{aggregate}, for instance,
  will want to reset the current maximum aggregate\index{aggregate} to some large
  negative number.)

\item Fetch data fields for each query firing this epoch\index{epoch}.  Loop
  through all fields of all queries, fetch them (using the {\tt Schema\index{schema}}
  interface), and fill in the appropriate values in the tuples\index{tuple}
  on the appropriate queries.  
  
\item Route\index{routing} filled-in tuples\index{tuple} to query operators.  First route to
  selections\index{selection}, then the aggregate\index{aggregate} (if it exists).  If any selection\index{selection}
  rejects a tuple\index{tuple}, discard it.

\end{enumerate}

\vspace{1em}
\noindent{\bf Neighbor\index{neighbor} Result Arrival}\\
  When a result arrives from a neighbor\index{neighbor}, the {\tt TupleRouter} receives a {\tt Network.dataMsg} event.
  This result needs to be integrated into the aggregate\index{aggregate} values being computed
  locally.  If the result corresponds to an aggregate\index{aggregate} query, that result
  is forwarded into the {\tt AggOperator} component\index{component}, otherwise it is 
  simply forwarded up the routing\index{routing} tree towards the root\index{root}.

\subsubsection {\tt SelOperator}
The {\tt SelOperator} is responsible for relational\index{relational} {\em
selection\index{selection}}: testing whether tuples\index{tuple} match predicates\index{predicate} (in task {\tt
doFilter\index{filter}}). Currently, the only expressions\index{expression} supported are standard
arithmetic\index{arithmetic} comparisons of attributes\index{attribute} with constants.

\subsubsection {\tt AggOperator}
This component\index{component} performs two SQL\index{SQL} features: {\tt GROUP BY}\index{Group By}\index{group} and
aggregation\index{aggregation}.

The optional {\tt GROUP BY}\index{Group By}\index{group} feature partitions the data by the value
of a (set of) attribute\index{attribute}(s).  Aggregate\index{aggregate} functions are computed for each
partition, over any attributes\index{attribute} {\em not} in the {\tt GROUP BY}\index{Group By} clause.  In
the absence of a {\tt GROUP BY}\index{Group By} expression\index{expression}, the aggregate\index{aggregate} is computed
over all tuples\index{tuple}.  As described in Section~\ref{sec:queries}, aggregate\index{aggregate}
results are updated once per ``epoch\index{epoch}''.

The code in this component\index{component} needs to (a) take readings from the current
node\index{node} ({\tt Operator.processTuple}), (b) merge those readings
with sub-aggregates\index{aggregate} from the subtree ({\tt
Operator.processPartialResult}), and (c) return this node's\index{node}
sub-aggregate\index{aggregate} results up the tree ({\tt Operator.nextResult}).
It also manages allocating aggregation\index{aggregation} state for each group\index{group} using the
{\tt TinyAlloc} component\index{component} (Section~\ref{sec:tinyalloc}), and
provides a utility to reset the running aggregation\index{aggregation} state ({\tt
Operator.resetExprState}).

\subsection {{\tt TinyAlloc}: The TinyDB\index{TinyDB} Memory Manager}
\label{sec:tinyalloc}
This component\index{component}, being very general-purpose, is located in {\tt
\docroot/tos/shared/TinyAlloc.\{c,comp\}} for use by other applications.

TinyAlloc is a simple, handle-based\index{handle} compacting memory manager.  It
allocates bytes from a fixed size frame and returns handles (pointers
to pointers) into that frame.  Because it uses handles, TinyAlloc can
move memory around in the frame without changing all the external
references.  Moving memory is a good thing because it allows frame
compacting and tends to reduce wasted space.  Handles can be accessed
via a double dereference (**), and a single dereference can be used
wherever a pointer is needed, but if a single dereference is to be
stored, the handle must be locked first (via {\tt MemAlloc.lock(h)}),
as otherwise TinyAlloc may move the handle and make the reference
invalid.  

\vspace{.1in}
\renewcommand{\baselinestretch}{1.0}\rm
\fbox{\parbox{.9\columnwidth}{
{\bf BEWARE:} Passing around dereferenced handles without locking
is a common source of bugs, as are problems that result from
memory not being unlocked.
}}
\renewcommand{\baselinestretch}{1.2}\rm
\vspace{.1in}

   Like all good TinyOS\index{TinyOS} programs, TinyAlloc is
   split-phase\index{split phase} with
respect to allocation and compaction.  Allocation/reallocation
completion is signalled via a {\tt MemAlloc.allocComplete()} signal and
compaction via a {\tt MemAlloc.compactComplete()} signal.  All other
operations complete and return in a single phase. Note that compaction
may be triggered automatically from allocation; in this case a
{\tt compactComplete}  event is not generated.

Handles\index{handle} are laid out in the frame as follows:
\begin{verbatim}
   [LOCKED][SIZE][user data] 

Where: 
    LOCKED     : a single bit indicating if the handle is locked 
    SIZE       : 7 bits representing the size of the handle 
    user data  : user-requested number of bytes (**h) points to
                 [user data], not [LOCKED].
\end{verbatim}
   Calling {\tt MemAlloc.size(h)} returns the size of {\tt [user
data]} (note that the internal function {\tt size()} returns the size of the
entire handle, including the header byte.)

\subsection{TinyDB\index{TinyDB} Network Topology\index{topology} Manager}
\label{sec:tinydbnetwork}
The {\tt Network} component\index{component} handles all the mote-to-mote\index{mote} and mote-to-serial-port\index{serial}
communication for TinyDB\index{TinyDB}, routing\index{routing} {\em query} and {\em data} messages.
In doing so, it also participates in a distributed algorithm for
network topology\index{topology} layout.  Messages are all of type {\tt TOS\_Msg},
and begin with a {\tt DBMsgHdr} structure (see {\tt
\docroot/tos/include/TinyDB\index{TinyDB}.h}), followed by a payload.

\vspace{1em}
\noindent {\bf Topology\index{topology} Maintenance}\\ Most of the code in this
component\index{component} manages the network topology\index{topology}.  The network topology\index{topology} is
maintained as a routing\index{routing} {\em tree}, with Mote\index{mote} \#0 at the root\index{root}.  As a
rule, query messages flood down the tree in a straightforward fashion.
Data messages flow back up the tree, participating in more complex
query processing algorithms.  Mote\index{mote} \#0 passes result data to the
front-end\index{front-end} code via its serial\index{serial} interface.  The only exception to
``query-down/data-up'' rule is that the root\index{root} itself sends out periodic
(empty) data messages as a ``heartbeat''\index{heartbeat}, so that its communication
abilities can continue to be measured while a query runs.

By default, a simple tree-maintenance algorithm is used.  This
algorithm has each mote\index{mote} keep track of a list of other motes\index{mote} from which
it receives messages ({\em neighbors\index{neighbor}}).  Among these neighbors\index{neighbor}, it
chooses the best one as its {\em parent\index{parent}} in the tree.  Alternatively
(for testing purposes) the network can be forced to choose a static
topology\index{topology} based on the numbering of the nodes\index{node}.  This is done via the
{\tt forceTopology()} command.

\vspace{1em}
\noindent{\bf Message Handling}\\
Upon receiving a message on the network, this component\index{component} invokes the
internal routine {\tt processHeader}, which examines the header of
each packet received on the radio.  This code drives much of the logic
in the component\index{component}.  It first updates statistics that are maintained for
the parent-choice logic, and updates its choice of parent\index{parent} if
necessary.  Then, if the message is a data message destined for
another node\index{node}, it drops the message.  Otherwise, it handles the message
accordingly.

\subsection{TinyOS\index{TinyOS} Service Components\index{component}}
We describe these TinyOS\index{TinyOS} services only briefly.  For more detail see
TinyOS\index{TinyOS}.
\begin{itemize}
\item {\tt Clock}: Provides a system clock, and clock interrupts.
\item {\tt GenericComm}: A generic communications layer, supporting
  radio and serial\index{serial} communication.
\item {\tt Leds}: Control of the LED indicators on the motes\index{mote}.
\item {\tt Main}: A shell to initialize subordinate modules, and start
  them up.
\item {\tt Pot}: Get and set the level of the potentiometer
  (transmission-power controller) on the radio.
\item {\tt RandomLFSR}: A psuedo-random number generator, based on a
  16-bit Linear Feedback Shift Register.
\item {\tt Reset}:  Reset a mote\index{mote} (equivalent to toggling the 
power switch.)
\item {\tt Timer}: A service for setting (multiple) timers to generate
  subsequent interrupts.
\end{itemize}

\subsection{Attributes\index{attribute}: Sensor\index{sensor} Components\index{component} and Introspection\index{introspection}}
\label{sec:devices}
We describe these TinyOS\index{TinyOS} services only briefly.  For more detail see
TinyOS\index{TinyOS}.
\begin{itemize}
\item {\tt Accel}: Accelerometer: measures movement in two dimensions
  (X and Y).
\item {\tt Mag}: Magnetometer: measures magnetic field.
\item {\tt Photo}: Light sensor\index{sensor}.
\item {\tt Temp}: Thermometer: measures temperature.
\item {\tt Voltage}: Measures remaining voltage in the battery\index{battery}.
\end{itemize}
%\section{Background}
%\subsection{Related Reading}
%\subsection{In-Network Processing\index{in-network}}
%\subsection{Declarative Query Processing}

\section{Using TinyDB with PostgreSQL}\label{postgres}\index{PostgreSQL}

TinyDB includes a simple facility to log results of queries to a PostgreSQL\index{PostgresQL} database.  Postgres
is an open-source, widely used DBMS available on a wide-variety of platforms ( 
See \htmladdnormallink{{\tt www.us.postgresql.org}}{http://www.us.postgresql.org} for more information.)   To enable logging
to a Postgres database, set up Postgres according to the directions in the next section, and then
enable the ``Log to Database'' option when inputting a query via the query GUI (see Figure \ref{fig:query}.) Note that it
is not neccessary to configure Postgres {\it unless you wish to use the logging facilities}.
The results of the query will be written to a table named ``query$n$'', where $n$ is the number of the query
that appears in the title bar of the result window that appears after the ``Send query'' button is
clicked.  Note that if a previous query with the same id has been logged to the database, the old
queries results will be lost.  The resulting table will contain a timestamped entry for each result
returned by the query.  For example, if query ID 2 is {\it select light,temp from sensors}, the resulting
Postgres table {\tt query2} will have the schema:

\begin{tabular}{|c|c|c|c|}
\hline
{\tt result\_time:timestamp} & {\tt epoch:integer}&{\tt light:integer}&{\tt temp:integer} \\
\hline
\end{tabular}

\noindent In this way, TinyDB query results can be accessed offline and joined with results from other static, offline data sources.

\subsection{Configuring PostgreSQL}\label{sec:postgres-config}

The following is a simple guide for installing and configuring Postgres \index{Postgres} to support logging of TinyDB queries.
We have successfully used TinyDB with Redhat Linux 7.2 and 7.3  and Cygwin;  other Linux distributions should
be straightforward to configure.

\begin{enumerate}
\item{\bf Download and Install PostgreSQL} {\it Note that Cygwin comes with a default installation of Postgres, so this step
is not neccessary under Cygwin.}

Download Postgres for your distribution from \\
\htmladdnormallink{http://www.ca.postgresql.org/ftpsite/binary/v7.2.1/RPMS/}{http://www.ca.postgresql.org/ftpsite/binary/v7.2.1/RPMS/}.  
You'll need at least the following packages:

{\tt
postgresql-libs \\
postgresql \\
postgresql-server \\
postgresql-jdbc \\
}

Install the packages in the above order, and then start the Postgres service.  Under Redhat, the command to do this is:
{\tt /etc/rc.d/init.d/postgresql start}

\item{\bf Enable Remote Connections}

You'll need to modify your Postgres installation to allow connections over TCP/IP sockets.  With the Redhat RPMS, Postgres
is configured to store its data files in {\tt /var/lib/pgsql/data};  you'll need to substitute appropriately in the
commands below if your Postgres files are in a different location:

\begin{itemize}

\item {\tt cd /var/lib/pgsql/data}
\item Edit {\tt postgresql.conf} by
replacing the line (at the end of the comments section) that reads: \\
{\tt \#tcpip\_socket = false} \\
with \\
{\tt tcp\_socket = true} \\
\item Restart the postgresql server (under Redhat, type {\tt /etc/rc.d/init.d/postgresql restart})
\end{itemize}

\item{\bf Install the PostgreSQL JDBC driver}

Next, you'll need to make sure the Postgres JDBC driver (included in the TinyOS distribution) is in your classpath.  The
jar is located at \java/jars/pgjdbc2.jar;  under bash, you would type:

{\tt export CLASSPATH=\$CLASSPATH:\java/jars/pgjdbc2.jar}

\item{\bf Create the TinyDB User and Database}

The TinyDB config file (see \ref{sec:configfile}) above specifies a database and user name to use when accessing 
Postgres.  Both need to be created before TinyDB will work;  to do this under Redhat, type:

{\tt
su
postgres
createdb tinydb
createuser tele
}

\item{\bf Create the Queries Table}

TinyDB logs all of the queries that are logged to a table ``queries'', which contains the time
the query was posed as well as the text of the query.  You must create this table before TinyDB;
to do so under Redhat, do the following:

\begin{itemize}
\item {\tt su; su postgres}
\item Get a Postgres command prompt by typing: {\tt psql tinydb}
\item Create the table by typing: {\tt create table queries (qid integer, query\_time timestamp, query\_string varchar(500)	 );}
\end{itemize}
\end{enumerate}


\section{Version History and Author Information}

This document was written by Joe Hellerstein, Sam Madden, and Wei Hong.  This
is Version 0.1, last updated August 19, 2002 by Joe Hellerstein.

%\section{The TinyDB\index{TinyDB} License}

\appendix

\section{TinyDB Source Files}
\label{app:files}
The following files in the TinyOS CVS tree are a
part of the TinyDB\index{TinyDB} distribution:

\renewcommand{\baselinestretch}{.9}\rm
\begin{itemize}
\item {\tt \docroot/tos/lib/TinyDB}
\begin{itemize}
\item {\tt /AggOperator.rd}
\item {\tt /DBBufferC.td}
\item {\tt /DBBuffer.ti}
\item {\tt /DBBuffer.h}
\item {\tt /ExprEvalC.td}
\item {\tt /ExprEval.ti}
\item {\tt /NetworkC.td}
\item {\tt /Network.ti}
\item {\tt /Operator.ti}
\item {\tt /ParsedQueryIntf.ti}
\item {\tt /ParsedQuery.td}
\item {\tt /QueryIntf.ti}
\item {\tt /Query.td}
\item {\tt /RadioQueue.ti}
\item {\tt /SelOperator.td}
\item {\tt /TinyDBAttr.td}
\item {\tt /TinyDBCommand.td}
\item {\tt /TinyDB.h}
\item {\tt /TupleIntf.ti}
\item {\tt /TupleRouter.td}
\item {\tt /TupleRouterM.td}
\item {\tt /Tuple.td}
\end{itemize}
\item {\tt \docroot/tos/interfaces}
\begin{itemize}
\item {\tt /Attr.h}
\item {\tt /AttrRegisterConst.ti}
\item {\tt /AttrRegister.ti}
\item {\tt /AttrUse.ti}
\item {\tt /Command.h}
\item {\tt /CommandRegister.ti}
\item {\tt /CommnadUse.ti}
\item {\tt /MemAlloc.ti}
\item {\tt /SchemaType.h}
\end{itemize}
\item {\tt \docroot/tos/lib}
\begin{itemize}
\item {\tt /Command.td}
\item {\tt /Attr.td}
\item {\tt /TinyAlloc.td}
\end{itemize}
\item {\tt {\java}/net/tinyos/tinydb}
\begin{itemize}
\item {\tt AggExpr.java}
\item {\tt AggOp.java}
\item {\tt Catalog.java}
\item {\tt CmdFrame.java}
\item {\tt CommandMsgs.java}
\item {\tt MagnetFrame.java}
\item {\tt QueryExpr.java}
\item {\tt QueryField.java}
\item {\tt QueryListener.java}
\item {\tt QueryResult.java}
\item {\tt ResultFrame.java}
\item {\tt ResultGraph.java}
\item {\tt ResultListener.java}
\item {\tt SelExpr.java}
\item {\tt SelOp.java}
\item {\tt TinyDBCmd.java}
\item {\tt TinyDBMain.java}
\item {\tt TinyDBNetwork.java}
\item {\tt TinyDBQuery.java}
\item {\tt Makefile}
\item {\tt parser/}
\begin{itemize}
\item {\tt Makefile}
\item {\tt senseParser.\{cup,lex\}}
\end{itemize}
\end{itemize}
\item {\tt {\docroot}/apps/TinyDBApp}
\begin{itemize}
\item {\tt Makefile}
\item {\tt TinyDBApp.td}
\end{itemize}
\end{itemize}
\renewcommand{\baselinestretch}{1.2}\rm

\begin{latexonly}
% Glossary entries
\nomenclature{\bf Active Messages (AM)}{A networking protocol developed at
  UC Berkeley, used for very-low-latency dispatch of incoming
  messages.  It provides an asynchronous (sometimes called
  ``split-phase'') programming model.\\}
\nomenclature{\bf Aggregation}{Aggregation is the process of
  bringing together multiple data objects.  In SQL, it typically
  denotes the summarization of multiple numeric values with a single
  summary statistic, like COUNT, AVERAGE, MAX or MIN.\\}
\nomenclature{\bf API}{Application Programming Interface.  A set of
  interfaces provided by a subsystem that enable programmers to use
  the subsystem in their own applications.\\ }
\nomenclature{\bf Attribute}{In traditional databases, a row in a table,
  consisting of a name and a data type.  In TinyDB, an attribute often
  corresponds to a physical sensor reading like light, temperature,
  etc.  However, the system can support attributes provided in
  software as well, like NodeID\index{ID}, network parent\index{parent}, and so on.}
\nomenclature{\bf Catalog}{A set of metadata describing a database,
  including the schema, and whatever other metadata the system
  provides.}
\nomenclature{\bf Client}{In the TinyDB context, a piece of code running
  on a PC that invokes the TinyDB Java API.  Synonym for Front-End.}
\nomenclature{\bf Column}{See Attribute.}
\nomenclature{\bf COM1}{The name of the standard serial port on a PC.}
\nomenclature{\bf Component}{A basic building block in a TinyOS
  program. See the TinyOS documentation for details on the TinyOS
  programming model.}
\nomenclature{\bf Declarative Language}{A language in which you
  express what you desire, without detail on how to achieve it.
  Declarative languages are popular in database systems; SQL is
  (largely) declarative.  Declarative languages are useful for providing a
  very deep level of indirection between application requests and
  system implementation of the requests -- this is especially important if the
  system's optimal implementation could change frequently (as in a
  sensor network, which is quite unpredictable).}
\nomenclature{\bf Download}{In the context of TinyOS/TinyDB, this is the
  process of transfering a compiled code image onto a mote.}
\nomenclature{\bf Embedded C}{A program written in C that runs
  autonomously on a small device like a mote.} 
\nomenclature{\bf Epoch}{A discrete window of time.  In TinyDB's SQL, new
  answers to a query are produced every epoch, and the duration of an
  epoch can be specified in the query.}
\nomenclature{\bf Expression}{A simple interpretable clause in a query,
  like an arithmetic comparison (e.g.\ {\tt light $>$ 80}), or an
  aggregate function (e.g.\ {\tt AVERAGE(temp)})}.
\nomenclature{\bf Filter}{A predicate that may remove some readings from
  the query.  Synonym for Selection.}
\nomenclature{\bf Front-End}{In the TinyDB context, a piece of code running
  on a PC that invokes the TinyDB Java API.  Synonym for Client.}
\nomenclature{\bf Group By}{In SQL, an expression that partitions the set of
  tuples that satisfy a query, to prepare for computation of an
  aggregate per partition.  Typically the Group By expression is
  simply an attribute name, e.g.\ {\tt GROUP BY temp}; tuples are
  partitioned by the value of the attribute.}
\nomenclature{\bf GUI}{Graphical User Interface.}
\nomenclature{\bf Handle}{A pointer to a pointer to an object.  The
  double level of indirection allows the objects to be relocated
  without informing the code that manipulates the handles.}
\nomenclature{\bf Heartbeat}{A periodic network message that simply
  indicates that the sender is active and connected.}
\nomenclature{\bf In-Network}{A description for algorithms that run in
  intermediate network devices in a multi-hop network, rather than the
  hosts at the endpoints.}
\nomenclature{\bf Listener}{A Java object that responds to certain
  kinds of events.}
\nomenclature{\bf Mote (Berkeley Mote)}{A wireless sensor network
  node, developed at UC Berkeley.  A mote is a device combining a small
  microprocessor, one or more sensors, and a radio.  The name ``mote''
  comes from the ``Smart Dust'' metaphor introduced by sci-fi author Neal Stephenson.}
\nomenclature{\bf Multi-Hop}{A scenario in which network messages
  visit multiple routers between source and destination.}
\nomenclature{\bf Neighbor}{Two network nodes are neighbors if they
  can communicate directly, without involving any intermediate routing.}
\nomenclature{\bf Node}{In this context, a compute device in a
  network; typically a mote in a sensor network.}
\nomenclature{\bf Object-Relational}{A database model developed in the
  Postgres project at UC Berkeley, which extends the
  relational model with object-oriented features like extensible
  abstract data types, including OO methods that are executed by the
  database engine (rather than at a client).}
\nomenclature{\bf Parent}{In a TinyDB routing tree, the parent of node
  $n$ is the node that listens to $n$'s data messages.}
\nomenclature{\bf Predicate}{A boolean expression.}
\nomenclature{\bf Processed}{In the TinyDB API, a result tuple is considered
  ``processed'' when all the attributes have been concatenated
  together with fully aggregated values.}
\nomenclature{\bf
  Ptolemy}{\htmladdnormallink{Ptolemy}{http://ptolemy.eecs.berkeley.edu}
  is a simulation project at UC Berkeley.  The TinyDB application
  borrows a small piece of code from 
  Ptolemy for plotting results.} 
\nomenclature{\bf Query Plan}{An interpretable description for
  executing a query, typically consisting of a few high-level
  operators connected in a dataflow tree.}
\nomenclature{\bf Query Processor}{A system for executing queries.}
\nomenclature{\bf Relational Model, Relational Languages}{Invented by
  Turing Award-Winner Ted Codd, the
  relational data model is the most prevalent representation for data
  today.  It is extremely simple, representing all information as
  relations (``tables'') consisting of tuples (``rows'') made up of
  well-typed attributes (``columns'').  A relational query language is
  one that can express a subset of 1st-order logic over relations.
  The standard relational query language is SQL.}
\nomenclature{\bf Root}{In TinyDB, this refers to the root of the
  routing tree, which is a sensor that is connected to the serial port
  of the PC running the front-end code.}
\nomenclature{\bf Routing}{The process of moving data through a
  multi-hop network from source to destination.  In TinyDB, the
  dataflow involved in routing interacts significantly with the
  dataflow involved in query processing.}
\nomenclature{\bf Row}{See Tuple.}
\nomenclature{\bf Sample}{In the sensor context, this often refers to
  a single discrete reading taken by a sensor.  It is called a sample to highlight
  the approximate nature of representing a continuous, real-world
  process as a stream of discrete digital readings.}
\nomenclature{\bf Schema}{A metadata description of a relation or set of
  relations.  A simple schema includes the name of the relation(s), the
  names and data types of the attributes in the relation, and the
  default order of the attributes.  Note that the schema describes
  what data {\em can} exist in the relation, not what {\em currently}
  exists.}
\nomenclature{\bf Selection}{In relational languages, the operation of
  choosing those tuples in a relation that match some predicate.  See Filter.}
\nomenclature{\bf Semantics}{The meaning of a construct.}
\nomenclature{\bf Sensor}{A device for converting physical phenomena into
     electronic signals.  In this document we sometimes use the word sensor
     interchangeably with the word mote: the combination of a sensor, a
     processor, and a radio.}  
\nomenclature{\bf Sensor Network}{A network -- often a wireless
  network -- in which the nodes are devices like motes that combine
  sensors with processing and commmunication.}
\nomenclature{\bf Serial Port}{An I/O port present on most PCs.}
\nomenclature{\bf SQL}{The Structured Query Language, a standard
	  language used for specifying queries to relational databases.}
\nomenclature{\bf Table}{See Relation.}
\nomenclature{\bf Timeslot}{An assigned range of time.  In order to
  avoid network congestion, some protocols explicitly allocate timeslots across
  potential senders so that their messages do not collide.}
\nomenclature{\bf TinyDB}{A system for declaring and executing queries
  in a wireless sensor network.}
\nomenclature{\bf TinyOS}{A set of C-based low-level libraries for writing
  embedded systems on the Berkeley Motes.  Key features of TinyOS
  include hardware abstractions for the Berkeley motes, an
  Active Messages-based communication layer for both radio and serial
  communication, and a programming model that supports both procedure
  calls and asynchronous event programming.}
\nomenclature{\bf Topology}{In our discussion, the directed graph that
  represents the communication pattern between motes in a wireless network.}
\nomenclature{\bf Tuple}{A list of attribute-value pairs that
  corresponds to the schema of some relation.}
\end{latexonly}
\printindex
\begin{latexonly}
\printglossary
\end{latexonly}
\end{document}

#!/usr/bin/env mzscheme -u
; build - builds the scheme code of a module injection to 
;   statically compile into the SensorScheme runtime

#lang scheme

(require (file "sensor-net.scm") (file "modules.scm") (file "symmap.scm") (file "specialize.scm")
         (only-in srfi/1 lset-union lset-difference append-map append-reverse filter-map take drop)
         (only-in srfi/13 string-drop-right string-contains string-reverse)
         scheme/pretty
         scheme/system)

(provide main)

(define autogen-msg1 "This file is automatically generated by the SensorScheme")
(define autogen-msg2 "build process. Do not edit manually.")
(define c-autogen-msg (format "/* ~a~n * ~a~n */~n" autogen-msg1 autogen-msg2))
(define scheme-autogen-msg (format "; ~a~n; ~a~n~n" autogen-msg1 autogen-msg2))
(define make-autogen-msg (format "# ~a~n# ~a~n~n" autogen-msg1 autogen-msg2))

; variables tht hold the command line parameter switches and the setter function
(define *node-id* #f)
(define (set-node-id! n) (set! *node-id* n))


(define *verbose* #f)
(define (set-verbose! v) (set! *verbose* v))


(define *appdir* (current-directory))
(define (set-appdir! v) 
  (when (not (directory-exists? v))
    (make-directory v))
  (set! *appdir* v))

(define (make-initmessage-h string)
  (define (byte-const byte)
    (string-append "0x" 
                   (let ((s (number->string byte 16)))
                     (if (= (string-length s) 1) (string-append "0" s) s)) 
                   ", "))
  (define (bytes-split byte-list n)
    (if (> (length byte-list) n) 
        (cons (take byte-list n) (bytes-split (drop byte-list n) n))
        (list byte-list)))
  
  (string-append 
   "#ifndef INITMESSAGE_H\n#define INITMESSAGE_H\n\nconst uint16_t initSize = "
   (number->string (length string))
   ";\nconst uint8_t  initMessage[] = {\n"
   (string-drop-right (apply string-append (map (lambda (s) (string-append "        " (apply string-append (map byte-const s)) "\n")) 
                                                (bytes-split string 8))) 3) "};\n\n#endif\n"))

; generates the contents of the primitives.h file from deduced primitives 
; and updates symbols file if needed
(define (make-primitives-h prims recvs dir)
  (let ([symmap (read-symmap-file dir)])
    (define (filter-kind sym)
      (filter-map (lambda (el) (if (eq? (caadr el) sym)
                                   (cons (car el) (cdadr el)) #f)) prims))
    
    (define (prim-entry el)
      (format "  _(~a, ~s) /* ~s : ~s */ \\~n" (c-ident (car el)) (cadr el) (car el) (symnum symmap (car el))))
    
    (let-values ([(simple eval app sender) (apply values (map (lambda (x) (filter-kind x)) '(simple eval apply sender)))])
      
      (begin0 
        (format "~n~n/* builtin primitive functions defined here. */
#define SIMPLE_PRIM_LIST(_) \\~n~a
#define EVAL_PRIM_LIST(_) \\~n~a
#define APPLY_PRIM_LIST(_) \\~n~a
#define SEND_PRIM_LIST(_) \\~n~a
#define RECEIVER_LIST(_) \\~n~a~n" 
                (apply string-append (map prim-entry simple))
                (apply string-append (map prim-entry eval))
                (apply string-append (map prim-entry app))
                (apply string-append (map prim-entry sender))
                (apply string-append (map prim-entry recvs)))
        (write-symmap-file symmap dir)))))


(define (main cmdline)
  (define (filter-defs defs sym)
    (filter-map (lambda (el) 
                  (if (eq? (cadr el) sym)
                      (cons (car el) (cddr el)) #f)) defs))
  
  (let*-values 
      ([(program-module make-args)
        (command-line #:argv cmdline
                      #:once-any 
                      [("-a" "--appdir") dir "the directory where the TinyOS application is generated" 
                                         (set-appdir! (string->path dir))]
                      #:once-each 
                      [("-s" "--specialize") node-id "specialize the program for the node with given ID" 
                                             (set-node-id! (string->number node-id))]
                      [("-m" "--macroexand") "print macro-expansion information" 
                                             (set-module-macroexpand! #t)]
                      [("-v" "--verbose") "be verbose" 
                                          (set-module-verbose! #t)
                                          (set-verbose! #t)]
                      #:args (program-module . make-args)
                      (unless (file-exists? program-module) (raise-user-error 'build "~s does not exist" program-module)) 
                      (values program-module make-args))
        ]
       [(src-dir) (build-path *appdir* "src")]
       [(gw-dir) (build-path *appdir* "ssgw")])
    (unless (directory-exists? src-dir) (make-directory src-dir))
    (when (directory-exists? gw-dir) (delete-directory/files gw-dir)) (make-directory gw-dir)
    
    (printf "Generating NesC application for module ~s ...~n" program-module)
    (printf "Target directory is ~a~n" *appdir*)
    
    (let*-values ([(mdls defs inits) (specialize-module program-module *node-id*)]
                  [(defines consts primitives receivers) 
                   (apply values (map (lambda (x) (filter-defs defs x)) '(define const primitive receiver)))]                  
                  [(code) `((%define% ,@(apply append defines) ,@(apply append consts)) ,@inits)])
      (when *verbose* (printf " defs: ~s~n~n  consts ~s~n~n inits: ~s~n~n code: ~s~n~n" defs consts inits code))
      
      (with-output-to-file (build-path src-dir "Primitives.h")
        ; code to compile into binary image
        (lambda () 
          (display c-autogen-msg)
          (display (make-primitives-h primitives receivers gw-dir))) #:exists 'replace)
      
      (let ([bytes (net-encode-mapfile code gw-dir)])
        (printf "Module ~s compiled to size of ~a bytes ~n" program-module (length bytes))
        (with-output-to-file (build-path src-dir "InitMessage.h")
          ; init message
          (lambda () 
            (display c-autogen-msg)
            (display (make-initmessage-h bytes))) #:exists 'replace))
      
      (with-output-to-file (build-path gw-dir "initmessage.scm")
        ; simulation version
        (lambda () 
          (display scheme-autogen-msg)
          (pretty-print code)) #:exists 'replace)
      
      (with-output-to-file (build-path gw-dir "config.ncf") 
        ; save the compiled code
        (lambda () 
          (display scheme-autogen-msg)
          (write-node-conf mdls defs inits)) #:exists 'replace)
      
      (with-output-to-file (build-path src-dir "SensorSchemeAppC.nc") 
        ; build message with injector and code
        (lambda () 
          (display c-autogen-msg)
          (printf "
#include \"Primitives.h\"
#include \"InitMessage.h\"

configuration SensorSchemeAppC {}

#include \"implementation.h\"
")) #:exists 'replace)
      
      (with-output-to-file (build-path src-dir "SensorScheme.include")
        ; makefile include
        (lambda () 
          (display make-autogen-msg)
          (printf "
CFLAGS += -I$(TOSDIR)/lib/SensorScheme \\
          -I$(TOSDIR)/lib/SensorScheme/Interfaces \\
          -I$(TOSDIR)/lib/SensorScheme/Primitives \\
          -I$(TOSDIR)/lib/printf \\
          -I$(TOSDIR)/lib/net \\
          -I$(TOSDIR)/lib/net/le \\
          -I$(TOSDIR)/lib/net/ctp
")) #:exists 'replace))
    
    (printf "copying additional build files... ~n")
    (let ([buildfiles (build-path (getenv "TOSROOT") "support" "sdk" "pltscheme" "buildfiles")])
      (for-each (lambda (f)
                  (with-handlers ([exn:fail:filesystem? (lambda (exp) (printf "could not copy file to applicaiot directory~n"))])
                    (when (file-exists? (build-path buildfiles f)) 
                      (let*-values ([(dest) (build-path *appdir* f)])
                        (unless (file-exists? dest)
                          (printf "    ~a~n" (path->string f))
                          (copy-file (build-path buildfiles f) dest)))))) 
                (directory-list buildfiles)))
    
    (unless (null? make-args)
      (printf "executing \"make ~a\" to build TinyOS application~n" (string-join make-args " "))
      (exit (system (format "make ~a" (string-join make-args " ")))))))

(main (current-command-line-arguments))
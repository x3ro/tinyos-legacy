; build - builds the scheme code of a module injection to 
;   statically compile into the SensorScheme runtime

(require "sensor-net.scm" "modules.scm" "symmap.scm"
         (only (lib "1.ss" "srfi") lset-union lset-difference append-map append-reverse filter-map take drop)
         (only (lib "13.ss" "srfi") string-drop-right string-contains string-reverse)
         (only (lib "26.ss" "srfi") cut)
         (lib "pretty.ss" "mzlib"))
(require (lib "cmdline.ss"))


(define autogen-msg1 "This file is automatically generated by the SensorScheme")
(define autogen-msg2 "build process. Do not edit manually.")
(define c-autogen-msg (format "/* ~a~n * ~a~n */~n" autogen-msg1 autogen-msg2))
(define scheme-autogen-msg (format "; ~a~n; ~a~n~n" autogen-msg1 autogen-msg2))

; vaiables that hold the command line parameter switches.
(define *basedir* #f)
; and the setter function
(define (set-basedir! v) (set! *basedir* v))
; same for the noinit command line parameter
(define *noinit* #f)
(define (set-noinit! v) (set! *noinit* v))

(define (main cmdline)  
  (let*-values 
      ([(base-dir code-module)
        (command-line (car cmdline) (cdr cmdline)
                      (once-each 
                       [("-m" "--macroexand") "print macro-expansion information" 
                                              (set-print-macroexpand! #t)]
                       [("-i" "--no-init") "do not include module initialization statements" 
                                           (set-noinit! #t)])
                      (args (basedir filename) ; expects two command-line arguments
                            (values basedir filename)))]
       [(base name must-be-dir?) (split-path (path->complete-path (string->path code-module)))]
       [(module-name) (string-drop-right (path->string name)  
                                         (+ 1 (string-contains (string-reverse code-module) ".")))])
    (if (not *basedir*) (set-basedir! (path->complete-path (string->path base-dir))))
    (when (not (directory-exists? *basedir*))
      (error "Base application directory ~s does not exist~n" *basedir*))
    
    (printf "Calculating code to prepare from module ~s ...~n" module-name)
    (printf "Base application dir is ~a~n" *basedir*)
    
    (let*-values ([(base-mdls base-inits base-defs) (compile-module code-module)])
      
      (let* ([base-defines (map (lambda (el) (list (car el) (cdr el))) (filter-defs base-defs 'define))]
             [base-prims (filter-defs base-defs 'primitive)]
             [base-recvs (filter-defs base-defs 'receiver)]
             [symbols (cadr (with-input-from-file (build-path *basedir* "config.ncf") read))]
             [symmap (update-symmap (map (cut take <> 2) symbols) (new-symmap))]
             [primitives (filter-map (lambda (el) 
                                       (if (and (pair? (caddr el)) (eq? (car (caddr el)) 'primitive))
                                           (cons (car el) (cdr (caddr el)))
                                           #f)) symbols)]
             [receivers (filter-map (lambda (el) 
                                      (if (and (pair? (caddr el)) (eq? (car (caddr el)) 'receiver))
                                          (cons (car el) (cdr (caddr el)))
                                          #f)) symbols)]
             [defines (filter-map (lambda (el) 
                                    (if (and (pair? (caddr el)) (eq? (car (caddr el)) 'define))
                                        (cons (car el) (cdr (caddr el)))
                                        #f)) symbols)]
             [prim-difs (lset-difference equal? base-prims primitives)]
             [recv-difs (lset-difference equal? base-recvs receivers)]
             [def-difs (lset-difference equal? base-defines defines)]
             [defs (apply append '(%define%) def-difs)]
             [code-msg `(inject-handler ,defs ,@(if *noinit* () base-inits))]
             [encoded-msg (net-encode code-msg symmap)])
        
        (if (not (null? prim-difs))
            (error 'prepare "Cannot load module ~s: some primitives are not available or incorrectly bound: ~a~n"
                   module-name (map car prim-difs)))
        (if (not (null? recv-difs))
            (error 'prepare "Cannot load module ~s: some receivers are not available or incorrectly bound: ~a~n"
                   module-name (map car recv-difs)))
        
        (printf "the generated inject message:~n")
        (pretty-print code-msg)
        
        (with-output-to-file (build-path *basedir* (string-append module-name ".all.bytes")) 
          (lambda () (write-bytes (list->bytes encoded-msg))) 'replace)
        (with-output-to-file (build-path *basedir* "symbols.map") 
          (lambda () (pretty-print (symmap->list symmap))) 'replace)
        ))))


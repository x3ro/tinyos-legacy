<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>



  
  
  
  <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">



  
  
  
  <title>Pytos Development Environment</title>
</head>


<body>






<h2><a class="mozTocH2" name="mozTocId501178"></a> Introduction </h2>




<p>The pytos environment is an interactive environment into which the
user can import a nescApplication, including the variables in each
module, rpc functions, enums, types, and messages. This allows the user
to get/set any variable on the mote and to call any rpc function on the
mote over a multi-hop network. Importing enums, types, and message
definitions directly from the nesc code allows the programmer to define
all structs, values, and message formats only once and have them
automatically update in the pc-side application as they change in the
nesC code. Check out the <a href="Pytos%20Screenshots.html" title="Pytos Screenshots"> Screenshots</a>
</p>


<p><a href="UnitTest.html">Unit Testing Tool</a>
</p>


<p>For the TinyOS 1.x version of this set of pages, please visit <a href="http://nest.cs.berkeley.edu/nestfe/index.php/Pytos_Development_Environment">here</a>.
</p>


<br>


<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Getting_Started_Quickly"></a>
<h2><a class="mozTocH2" name="mozTocId322946"></a>Getting Started Quickly</h2>




<p>1. First, install the python environment for your&nbsp;<a href="Pytos%20Installation%20Instructions.html" class="external text" title="http://today.cs.berkeley.edu/nestfe/index.php/Pytos_Installation_Instructions" rel="nofollow">platform</a>.</p>


<p>2. Next, add the following line to your .bashrc or other script in order to properly set up paths for pytos:</p>



<pre>source $TOSROOT/../tinyos-2.x-contrib/marionette/support/sdk/python/tinyos/marionette/util/pytosProfile</pre>



<p>3.  Then, you must edit the compiler include path and invoke the <span style="font-weight: bold;">marionette.extra</span>
makefile during compilation by adding the following lines to your
~/tinyos-2.x/support/make/Makelocal (alternatively, you could add them to
each application's Makefile individually).
</p>




<pre>GOALS+=marionette<br>CFLAGS += -I$(TOSROOT)/../tinyos-2.x-contrib/marionette/tos/lib/Rpc<br>CFLAGS += -I$(TOSROOT)/../tinyos-2.x-contrib/marionette/tos/lib/RamSymbols<br><br></pre>




<p>4.  Finally, each application must also include the <b>RpcM.nc</b> and <b>RamSymbolsM.nc</b> nesc libraries in your nesc application by adding the following line to a top-level configuration file:
</p>




<pre>components RpcC, RamSymbolsM;<br>[ApplicationC].SplitControl -&gt; RpcC;<br></pre>




<p>The "nescDecls" command above is the minimum requirement for Pytos.
"Rpc" and "RamSymbols" add extra functionality to pytos but are not
required. You can find more information in the individual "Setting Up"
instructions at&nbsp;<a href="Nesc%20Declarations.html" class="external text" title="http://today.cs.berkeley.edu/nestfe/index.php/Nesc_Declarations#Setting_Up" rel="nofollow">Nesc Declarations</a>,&nbsp;<a href="Rpc.html" class="external text" title="http://today.cs.berkeley.edu/nestfe/index.php/Rpc#Setting_Up" rel="nofollow">Rpc</a> and&nbsp;<a href="Ram%20Symbols.html" class="external text" title="http://today.cs.berkeley.edu/nestfe/index.php/Ram_Symbols#Setting_Up" rel="nofollow">Ram Symbols</a>.
</p>



<p>5. Once you have completed this setup, you can simply run a command similar to the one below: 
</p>




<pre> MarionetteShell.py telosb sf@localhost:9001<br></pre>




<p>This should import the entire application from "build/telosb",
connect to the node, and give you a pytos command promt. (If you are
not using a TOSBase, set "tosbase=false" in the script before running).
Type "app" at the python cmd prompt to begin playing around; you can
also call help() on any object. Try some of the following: </p>




<ul>



  <li>type <b>app.types</b>, <b>app.enums</b>, or <b>app.msgs</b> to see more detail.  
  </li>



  <li>type <b>app.ModuleName</b> to see variables and functions for a particular nesc module, eg. app.DrainM
  </li>



  <li>set a module's variables by calling <b>app.module.variable.peek()</b> or <b>app.module.variable.poke(value)</b>.  
  </li>



  <li>The "dereference=True" parameter can be used to dereference a variable if it is a pointer, eg <b>app.mod.var.poke(value,dereference=True)</b>
  </li>



  <li>The "arrayIndex" parameter can be used to index a variable if it is an array, eg <b>app.mod.var.poke(value,arrayIndex=2)</b>
  </li>



  <li>You can call a function on a module eg <b>app.mod.func(val1, val2, etc)</b>
  </li>



</ul>




<p>The following sections expain each feature of the environment in more detail.
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Configuring_NescApp_Parameters"></a>
<h2><a class="mozTocH2" name="mozTocId898497"></a>Configuring NescApp Parameters</h2>




<p>The NescApp imports all functions, variables, types, enums, modules,
etc. from your nesc application into the python environment. In fact,
all the MarionetteShell does is instantiate a NescApp object. This object
takes four parameters:
</p>




<ol>



  <li> The build directory, e.g. "build/telos". NescApp will look in
the build directory for the nescDecls.xml file, which is created at
compile time (as long as you make nescDecls one of the GOALS in your
makefile).
  </li>



  <li> Your MOTECOM string, e.g. sf@localhost:9001 or
serial@/dev/ttyUSB0:telos. NescApp will connect to your nodes using
this motecom string. Note: if you do not pass a motecom string, you
will get a WARNING but you will still be able to access functions and
variables through the resuling NescApp object. This can be useful for
testing.
  </li>



  <li> The tosbase and localCommmOnly parameters, which indicate
what kind of network you have. tosbase should be true if you have a
TosBase node plugged into your machine. localCommOnly should be true if
you do NOT want the nodes to use the DRAIN multihop routing algorithm
to return data to the base station. These are boolean parameters, so
there are four combinations of them:
  </li>



</ol>




<ul>



  <li>  localCommOnly=T, tosbase=T:  all nodes are within one radio hop, and a TOSBase is plugged in
  </li>



  <li>  localCommOnly=T, tosbase=F:  all nodes are plugged directly into a serial port, e.g. you have a wired testbed
  </li>



  <li>  localCommOnly=F, tosbase=T:  some nodes are multiple hops away, and a TOSBase is plugged in
  </li>



  <li>  localCommOnly=F, tosbase=F:  some nodes are multiple hops away, and the root of the tree is plugged into a serial port.
  </li>



</ul>




<p><br>




</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Importing_nesC_Applications_into_Python"></a>
<h2><a class="mozTocH2" name="mozTocId439195"></a>Importing nesC Applications into Python</h2>




<p>The first thing you must do when starting python is to import your
nesc App. To do this, first import the NescApp module and then create a
new NescApp instance. The NescApp object requires a string parameter
indicating where it can find the necsDecls.xml file, which you created
at compile time. This can be
</p>




<ul>



  <li> an absolute path to the correct build directory (eg "/home/kamin/tinyos-2.x/apps/Oscilloscope/build/telosb")
  </li>



  <li> a relative path to the correct build directory  (eg "../apps/Oscilloscope/build/telosb")
  </li>



  <li> either of the above with the actual filename appended (eg. "..../nescDecls.xml")
  </li>



  <li> if you are in the application directory, just the name of the platform (e.g "pc" or "telosb")
  </li>



</ul>




<p>Example:
</p>




<pre>$ cd /opt/tinyos-2.x-contrib/marionette/apps/tests/TestMarionette/<br>kamin@kamin-mobile:/opt/tinyos-2.x-contrib/apps/tests/TestMarionette/<br>$ python<br>Python 2.4.1 (#2, May  5 2005, 11:32:06)<br>[GCC 3.3.5 (Debian 1:3.3.5-12)] on linux2<br>Type "help", "copyright", "credits" or "license" for more information.<br>&gt;&gt;&gt; import pytos.util.NescApp as NescApp<br>&gt;&gt;&gt; app = NescApp.NescApp('telosb', port='sf@localhost:9001')<br></pre>




<p>Now, your "app" object should contain all of the <b>module variables, module rpc functions, enums, types, and messages</b> that are defined in your nesc application.  You can look at an overview with 
</p>




<pre>&gt;&gt;&gt; print app<br><br>               Enums : 296<br>               Types : 93<br>            Messages : 2<br>       Rpc functions : 30<br>         Ram symbols : 28<br>             Modules : HdlcTranslateC<br>                       McuSleepC<br>                       RamSymbolsM<br>                       RpcM<br>                       SchedulerBasicP<br>                       SerialP<br>                       TestMarionetteC<br></pre>




<p>or you can look at them individually through the sub-objects
</p>




<pre>&gt;&gt;&gt; app.enums<br>&gt;&gt;&gt; app.types<br>&gt;&gt;&gt; app.msgs<br>&gt;&gt;&gt; app.rpc<br>&gt;&gt;&gt; app.ramSymbols<br>&gt;&gt;&gt; app.DrainM<br>&gt;&gt;&gt; app.RamSymbolsM<br>&gt;&gt;&gt; app.TestRpcM<br></pre>




<p>Note: if you are using Tossim or if your node is plugged directory
into the serial/USB port, you must use the "tosbase=False" flag to
indicate that your computer is not connected to a TOSBase. For example:
</p>




<pre>&gt;&gt;&gt; app = NescApp.NescApp('telosb', port='sf@localhost:9001', tosbase=False)<br></pre>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Variables_and_Registry_Attributes"></a>
<h3><a class="mozTocH3" name="mozTocId319234"></a> Variables and Registry Attributes </h3>




<p>If you included the RpcM and RamSymbolsM modules in your application, the NescApp object will contain a
field called app.ramSymbols, which lists all the modules in your nesc
application and their variables. The variables are also available
through module shortcuts, eg. app.moduleName.variableName
</p>



<p>You can get and set the values of module variables through the <b>poke</b> and <b>peek</b> commands.  If the variable is an array, it can be indexed into with the <i>arrayIndex</i> option.  If the variable is a pointer, it can be dereferenced with the <i>dereference</i> option.  Arrays of pointers can be indexed and then dereferenced.  For example:
</p>



<p>NOTE: Poke is a fairly dangerous operation because it is
changing the value of a variable without allowing the module to do any
sort of state-checking. </p>




<pre>&gt;&gt;&gt; app.ramSymbols<br>&lt;class 'pytos.tools.RamSymbols.RamSymbols'&gt; object at 0xb1a7074cL:<br><br>             uint8_t : HdlcTranslateC.m_data<br>             uint8_t : HdlcTranslateC.txTemp<br>                bool : McuSleepC.dirty<br>         mcu_power_t : McuSleepC.powerState<br>         ramSymbol_t : RamSymbolsM.symbol<br>            uint16_t : RpcM.cmdStoreLength<br>                bool : RpcM.processingCommand<br>                bool : RpcM.sendingResponse<br>             uint8_t : SchedulerBasicP.m_head<br>          uint8_t[8] : SchedulerBasicP.m_next<br>             uint8_t : SchedulerBasicP.m_tail<br>                bool : SerialP.offPending<br>             uint8_t : SerialP.rxByteCnt<br>            uint16_t : SerialP.rxCRC<br>             uint8_t : SerialP.rxProto<br>             uint8_t : SerialP.rxSeqno<br>             uint8_t : SerialP.rxState<br>             uint8_t : SerialP.txByteCnt<br>            uint16_t : SerialP.txCRC<br>             uint8_t : SerialP.txIndex<br>             uint8_t : SerialP.txPending<br>             uint8_t : SerialP.txProto<br>             uint8_t : SerialP.txSeqno<br>             uint8_t : SerialP.txState<br>       RpcCommandMsg : TestMarionetteC.m_rpcCommandMsg<br>             uint8_t : TestMarionetteC.test<br>         uint8_t[10] : TestMarionetteC.testArray<br>            uint8_t* : TestMarionetteC.testPtr<br></pre>




<pre>&gt;&gt;&gt; app.TestMarionetteC.test.peek()<br>[&lt;class 'pytos.util.nescDecls.TosMsg'&gt; object at 0x86ace2c:<br><br>        TosMsg(am=816) TestMarionetteC.test.peek(),  nodeID=0:<br>                 uint8_t value  : 123<br>]<br>&gt;&gt;&gt; app.TestMarionetteC.test.poke(150)<br>[&lt;class 'pytos.util.nescDecls.TosMsg'&gt; object at 0x86b1e0c:<br><br>        TosMsg(am=816) TestMarionetteC.test.poke(),  nodeID=0:<br>                 error_t value  : 1<br>]<br>&gt;&gt;&gt; app.TestMarionetteC.test.peek()<br>[&lt;class 'pytos.util.nescDecls.TosMsg'&gt; object at 0x86b176c:<br><br>        TosMsg(am=816) TestMarionetteC.test.peek(),  nodeID=0:<br>                 uint8_t value  : 150<br>]<br>&gt;&gt;&gt; app.TestMarionetteC.testArray.peek(arrayIndex=0)<br>[&lt;class 'pytos.util.nescDecls.TosMsg'&gt; object at 0x86b730c:<br><br>        TosMsg(am=572) TestMarionetteC.testArray.peek(),  nodeID=0:<br>                 uint8_t value  : 1<br>]<br>&gt;&gt;&gt; app.TestMarionetteC.testPtr.peek()<br>[&lt;class 'pytos.util.nescDecls.TosMsg'&gt; object at 0x86ac36c:<br><br>        TosMsg(am=568) TestMarionetteC.testPtr.peek(),  nodeID=0:<br>                uint16_t value  : 816<br>]<br>&gt;&gt;&gt; app.TestMarionetteC.testPtr.peek(dereference=True)<br>[&lt;class 'pytos.util.nescDecls.TosMsg'&gt; object at 0x86b764c:<br><br>        TosMsg(am=568) TestMarionetteC.testPtr.peek(),  nodeID=0:<br>                 uint8_t value  : 150<br>]<br></pre>




<br>


<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="RPC_Functions"></a>
<h3><a class="mozTocH3" name="mozTocId117564"></a> RPC Functions </h3>




<p>All functions and interfaces in an application that are declared
"@rpc()" are imported into python and can be used to call functions on
a mote. The rpc functions are available both through the app.rpc object
and through the app.ModuleName shortcuts. To see how to declare a rpc
function in your nesc code, see <a href="Rpc.html" title="Rpc">Rpc</a>.  
</p>



<p>Once the rpc object is imported, it provides all rpc-able
functions available as methods. Modules or interfaces with rpc
functions can also be gotten as member fields. By default, rpc
functions are blocking, wait 1 second, and return a list of all
responses. A period is printed for each response that is received while
the command is blocking.
</p>



<p>To test rpc, you can do the following:
</p>




<pre>&gt;&gt;&gt; print app.rpc<br>          ramSymbol_t RamSymbolsM.peek(  uint16_t memAddress, uint8_t length, bool dereference )<br>             uint16_t RamSymbolsM.poke(  ramSymbol_t symbol )<br>                 void TestMarionetteC.TestInterface1.testCommand1( )<br>              error_t TestMarionetteC.TestInterface1.testCommand3(  uint8_t something )<br>              error_t TestMarionetteC.TestInterface1.testCommand4(  uint8_t something, uint16_t data )<br>        RpcCommandMsg TestMarionetteC.TestInterface1.testCommand5( RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.TestInterface1.testCommand6( RpcCommandMsg data )<br>                 void TestMarionetteC.TestInterface1.testCommand7( RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.TestInterface1.testCommand8( )<br>                 void TestMarionetteC.TestInterface2.testEvent1( )<br>              error_t TestMarionetteC.TestInterface2.testEvent3(  uint8_t something )<br>              error_t TestMarionetteC.TestInterface2.testEvent4(  uint8_t something, uint16_t data )<br>        RpcCommandMsg TestMarionetteC.TestInterface2.testEvent5( RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.TestInterface2.testEvent6( RpcCommandMsg data )<br>                 void TestMarionetteC.TestInterface2.testEvent7( RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.TestInterface2.testEvent8( )<br>                 void TestMarionetteC.testCommand1( )<br>              error_t TestMarionetteC.testCommand3(  uint8_t something )<br>              error_t TestMarionetteC.testCommand4(  uint8_t something, uint16_t data )<br>        RpcCommandMsg TestMarionetteC.testCommand5(  RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.testCommand6(  RpcCommandMsg data )<br>                 void TestMarionetteC.testCommand7(  RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.testCommand8( )<br>                 void TestMarionetteC.testEvent1( )<br>              error_t TestMarionetteC.testEvent3(  uint8_t something )<br>              error_t TestMarionetteC.testEvent4(  uint8_t something, uint16_t data )<br>        RpcCommandMsg TestMarionetteC.testEvent5(  RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.testEvent6(  RpcCommandMsg data )<br>                 void TestMarionetteC.testEvent7(  RpcCommandMsg data )<br>        RpcCommandMsg TestMarionetteC.testEvent8( )<br>&gt;&gt;&gt; interface = app.TestMarionetteC.TestInterface1<br>&gt;&gt;&gt; print interface<br>                 void testCommand1( )<br>              error_t testCommand3(  uint8_t something )<br>              error_t testCommand4(  uint8_t something, uint16_t data )<br>        RpcCommandMsg testCommand5(  RpcCommandMsg data )<br>        RpcCommandMsg testCommand6(  RpcCommandMsg data )<br>                 void testCommand7(  RpcCommandMsg data )<br>        RpcCommandMsg testCommand8( )<br>&gt;&gt;&gt; app.rpc.TestMarionetteC.testCommand1(address=app.enums.AM_BROADCAST_ADDR, returnAddress = app.enums.TOS_AM_ADDRESS)<br><br>[ ...response is printed]<br></pre>




<br>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Function_Parameters"></a>
<h4><a class="mozTocH4" name="mozTocId719555"></a> Function Parameters </h4>




<p>Function parameters all default to 0 values. They can be set simply
by passing them as arguments when the function is called, but they can
also be set as <i>fields</i> on the rpc function.
</p>



<p>In the following example, we send a rpc command to set the value
of a cached value. We send it to the BROADCAST address and have it return
to the local address. </p>



<p>First, pass the function parameter "data" as a call-time
parameter.
</p>




<pre><span style="font-weight: bold;">&gt;&gt;&gt; data = interface.testCommand7.data FIX THIS TO BE DEEPCOPY?</span><br style="font-weight: bold;"><span style="font-weight: bold;">&gt;&gt;&gt; data.transactionID = 101</span><br style="font-weight: bold;"><span style="font-weight: bold;">&gt;&gt;&gt; data.commandID = 250</span><br style="font-weight: bold;"><span style="font-weight: bold;">&gt;&gt;&gt; r = interface.testCommand7(data, address=app.enums.AM_BROADCAST_ADDR, returnAddress=app.enums.TOS_AM_ADDRESS)</span><br style="font-weight: bold;"><span style="font-weight: bold;">&gt;&gt;&gt; print r[0]</span><br style="font-weight: bold;"><span style="font-weight: bold;">TosMsg(am=7) TestMarionetteC.TestInterface1.testCommand7,  nodeID=0:</span><br style="font-weight: bold;"><span style="font-weight: bold;">                    void value  :</span><br style="font-weight: bold;"><br style="font-weight: bold;"><span style="font-weight: bold;">&gt;&gt;&gt; interface.testCommand7.data</span><br style="font-weight: bold;"><span style="font-weight: bold;">&lt;class 'pytos.util.nescDecls.nescStruct'&gt; object at 0xb1877decL:</span><br style="font-weight: bold;"><br style="font-weight: bold;"><span style="font-weight: bold;">        RpcCommandMsg:</span><br style="font-weight: bold;"><span style="font-weight: bold;">         uint8_t transactionID  : 101</span><br style="font-weight: bold;"><span style="font-weight: bold;">             uint8_t commandID  : 250</span><br style="font-weight: bold;"><span style="font-weight: bold;">              uint16_t address  : 0</span><br style="font-weight: bold;"><span style="font-weight: bold;">        uint16_t returnAddress  : 0</span><br style="font-weight: bold;"><span style="font-weight: bold;">       uint8_t responseDesired  : 0</span><br style="font-weight: bold;"><span style="font-weight: bold;">            uint8_t dataLength  : 0</span><br style="font-weight: bold;"><span style="font-weight: bold;">               uint8_t[0] data  :][</span><br></pre>




<p>Now, set the function parameters as fields of the function. Both of
these effect the default parameter values, and these values will be
used
in subsequent calls of the same function as well, unless they are
overridden by new call-time parameters:
</p>




<pre>&gt;&gt;&gt; interface.testCommand7.data.transactionID = 102<br>&gt;&gt;&gt; interface.testCommand7.data.commandID = 251<br>&gt;&gt;&gt; r = interface.testCommand7(address=app.enums.AM_BROADCAST_ADDR, returnAddress=app.enums.TOS_AM_ADDRESS)<br>&gt;&gt;&gt; print r[0]<br>TosMsg(am=7) TestMarionetteC.TestInterface1.testCommand7,  nodeID=0:<br>                    void value  :<br><br>&gt;&gt;&gt; interface.testCommand7.data<br>&lt;class 'pytos.util.nescDecls.nescStruct'&gt; object at 0xb1877decL:<br><br>        RpcCommandMsg:<br>         uint8_t transactionID  : 102<br>             uint8_t commandID  : 251<br>              uint16_t address  : 0<br>        uint16_t returnAddress  : 0<br>       uint8_t responseDesired  : 0<br>            uint8_t dataLength  : 0<br>               uint8_t[0] data  :][<br></pre>




<p>The command we just called sets a cached value on the node. Now,
call testCommand8, which retrieves the cached value and we confirm that
it is the same value we just sent:
</p>




<pre>&gt;&gt;&gt; r = interface.testCommand8(address=app.enums.AM_BROADCAST_ADDR, returnAddress=app.enums.TOS_AM_ADDRESS)<br>&gt;&gt;&gt; print r[0]<br>TosMsg(am=8) TestMarionetteC.TestInterface1.testCommand8,  nodeID=0:<br>         uint8_t transactionID  : 102<br>             uint8_t commandID  : 251<br>              uint16_t address  : 0<br>        uint16_t returnAddress  : 0<br>       uint8_t responseDesired  : 0<br>            uint8_t dataLength  : 0<br>               uint8_t[0] data  :][<br></pre>




<p><br>



HINT: rpc functions are subclasses of TosMsg objects, so you can
check the values being sent with func.getBytes() or
func.createMigMsg(). It also has a func.printCurrentValues() function
for pretty-printing the default function parameters that are set on the
rpc function.
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Call_Parameters"></a>
<h4><a class="mozTocH4" name="mozTocId810175"></a> Call Parameters </h4>




<p>Call parameters are special named parameters to the rpc function that determine <i>how</i> it is called
</p>




<ul>



  <li> the <b>address</b> is the default address that the rpc commands will be addressed to (e.g app.enums.AM_BROADCAST_ADDR)
  </li>



  <li> the <b>returnAddress</b> is the default address that the rpc response will be address to (eg. app.enums.TOS_AM_ADDRESS)
  </li>



  <li> <b>blocking</b> indicates whether or not the functions should block and return the responses
  </li>



  <li> <b>timeout</b> indicates how long the function should block
  </li>



  <li> <b>responseDesired</b> indicates whether or not the node should send a rpc response
  </li>



</ul>




<p>Call parameters can be set in four ways:
</p>




<ol>



  <li> as named parameters when the function is called (it applies only to this call)
  </li>



  <li> by setting the value on the rpc function (it applies only to this function)
  </li>



  <li> by setting the value on the rpc object (it applies to all functions in that object)
  </li>



  <li> as a constructor argument to the Rpc object
  </li>



</ol>




<p>These are listed in order of precendence, ie. call-time arguments
override function attribute values override rpc attribute values
override constructor arguments. An example each of the four is shown
below:
</p>




<pre>&gt;&gt;&gt; rpc.TestMarionetteC.testCommand1(responseDesired = False)<br>&gt;&gt;&gt; rpc.TestMarionetteC.testCommand1.responseDesired = False<br>&gt;&gt;&gt; rpc.responseDesired = False<br>&gt;&gt;&gt; rpc = Rpc.Rpc(app, 'telosb', comm, drain, responseDesired=False)<br></pre>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Enums"></a>
<h3><a class="mozTocH3" name="mozTocId505550"></a> Enums </h3>




<p>You can access enums as fields of the "enums" object
</p>




<pre>&gt;&gt;&gt; addr = app.enums.AM_BROADCAST_ADDR<br>&gt;&gt;&gt; addr<br>65535<br></pre>




<p>If you name your enum in the nescFile, you can access those enums as
a group.</p>


<br>


<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="The_Dynamic_Typing_System"></a>
<h3><a class="mozTocH3" name="mozTocId927333"></a> The Dynamic Typing System </h3>




<p>The nescDecls package includes a dynamic typing system that mirrors
the types in nesC applications. There are four kinds of types:
</p>




<ul>



  <li>nescType: basic types like uint8_t, char, etc
  </li>



  <li>nescArray: arrays of any of the four types
  </li>



  <li>nescPointer: pointers to any of the four types
  </li>



  <li>nescStruct: structs of any of the four types
  </li>



</ul>




<p>All basic types, typedefs, and structs defined in the nesc application are imported through the app.types variable.  
A python variable can be made a certain nesC type simply by assigning a type to the variable.  
</p>




<pre>&gt;&gt;&gt; num = app.types.uint8_t<br>&gt;&gt;&gt; msg = app.types.TOS_Msg<br></pre>




<p>The typing system does import <b>typedefs</b>, ie. typedef names
such as "bool" or "error_t" will be available through "app.types". One
can also typedef a custom struct. However, the system does <i>not</i>
import anonymous structs; if you typedef a struct, make sure the struct
is not anonymous or it will not import. Finally, the system does not
import sets of structs with circular pointers to each other (such types
are not very useful for pc-mote communication anyway). To see the types
that failed to import, call <i>app.types.printSkippedTypes()</i>.
</p>



<p><font color="red">Important Note:</font> Objects in python are
passed by reference, not by value. If you pass a nesc-typed object and
the value of the new reference changes, the value of the original
object will change as well. To solve this problem use the "deepcopy()"
function to create a new copy of the variable. The nescApp object
always returns a deepcopy, ie a new instance for all types and
messages.
</p>



<p>The user can use the typing system to create new nesC types in
python, as described in the next 4 sub-sections. The main reason to use
the nescDecls typing package is that each typed variable has a
getBytes() and setBytes() function, which correctly converts the value
to a byte stream. It also does type-checking to make sure the value is
appropriate for the type. <b>If you are going to only use the types directly import from the nesc app, there is no reason to read the next four sections.</b>
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="nescType"></a>
<h4><a class="mozTocH4" name="mozTocId696168"></a> nescType </h4>




<p>The basic nescType has a field called "value" which should be used
to set it. nescType objects are type-safe, meaning that they give you
an error when you assign a value they cannot take:
</p>




<pre>&gt;&gt;&gt; variable = app.types.uint8_t<br>&gt;&gt;&gt; variable.nescType<br>u'uint8_t'<br>&gt;&gt;&gt; print variable<br>0<br>&gt;&gt;&gt; variable.value = 255<br>&gt;&gt;&gt; print variable<br>255<br>&gt;&gt;&gt; variable.getBytes()<br>'\xff'<br>&gt;&gt;&gt; variable.setBytes('\x0f')<br>''<br>&gt;&gt;&gt; print variable<br>15<br>&gt;&gt;&gt; variable.value = 256<br>Traceback (most recent call last):<br>  File "&lt;stdin&gt;", line 1, in &lt;module&gt;<br>  File "/opt/tinyos-2.x-contrib/marionette/support/sdk/python/tinyos/marionette/pytos/util/nescDecls.py", line 105, in __setattr__<br>    pack(self._conversionString, value)<br>  File "/usr/lib/python2.5/struct.py", line 63, in pack<br>    return o.pack(*args)<br>struct.error: ubyte format requires 0 &lt;= number &lt;= 255<br></pre>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="nescArray"></a>
<h4><a class="mozTocH4" name="mozTocId788070"></a> nescArray </h4>




<p>The nesCArray can be created dynamically from a size and another type, and they can be indexed through a [] operator:
</p>




<pre>&gt;&gt;&gt; array = pytos.util.nescDecls.nescArray(10, variable)<br>&gt;&gt;&gt; array<br>nescArray of type uint8_t[10]:<br> 0: 15<br> 1: 15<br> 2: 15<br> 3: 15<br> 4: 15<br> 5: 15<br> 6: 15<br> 7: 15<br> 8: 15<br> 9: 15<br><br>&gt;&gt;&gt; array.getBytes()<br>'\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f\x0f'<br>&gt;&gt;&gt; array[3] = 0<br>&gt;&gt;&gt; array.getBytes()<br>'\x0f\x0f\x0f\x00\x0f\x0f\x0f\x0f\x0f\x0f'<br></pre>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="nescPointer"></a>
<h4><a class="mozTocH4" name="mozTocId395101"></a> nescPointer </h4>




<p>A nescPointer can be constructed from any other nescTyped object. A
pointer has a "value" field, through which the typed object pointed to
should be set. The only difference between a pointer and the object it
points to is that the pointer getBytes() command will only return 2
bytes.
</p>




<pre>&gt;&gt;&gt; pointer = pytos.util.nescDecls.nescPointer(array)<br>&gt;&gt;&gt; pointer<br>ptr-&gt; nescArray of type uint8_t[10]:<br> 0: 15<br> 1: 15<br> 2: 15<br> 3: 0<br> 4: 15<br> 5: 15<br> 6: 15<br> 7: 15<br> 8: 15<br> 9: 15 <br><br>&gt;&gt;&gt; pointer.value[1] = 101<br>&gt;&gt;&gt; pointer<br>ptr-&gt; nescArray of type uint8_t[10]:<br> 0: 15<br> 1: 101<br> 2: 15<br> 3: 0<br> 4: 15<br> 5: 15<br> 6: 15<br> 7: 15<br> 8: 15<br> 9: 15  <br><br>&gt;&gt;&gt; pointer.getBytes()<br>'\x00\x00'<br>&gt;&gt;&gt; pointer.value.getBytes()<br>'\x0fe\x0f\x00\x0f\x0f\x0f\x0f\x0f\x0f'<br>&gt;&gt;&gt; array.getBytes()<br>'\x0fe\x0f\x00\x0f\x0f\x0f\x0f\x0f\x0f'<br></pre>




<p>Notice that changing the pointer.value also changes the array, which
the pointer is pointing to (the pointer.value field is simply a
reference to the array).
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="nescStruct"></a>
<h4><a class="mozTocH4" name="mozTocId871555"></a> nescStruct </h4>




<p>A nescStruct is a list of nescTyped objects. Those structs imported
directly from the nesc application are packed exactly as they are used
in the nesc application. In other words, if the struct has bit-fields
or if the compiler uses padded bytes to make things byte-aligned, the
getBytes() and setBytes() commands on the corresponding struct objects
will correctly handle these. <font color="red">However, nescStruct objects created manually from within python must be manually packed by the user.</font>
</p>



<p>nescStructs can be manually constructed in two different ways:
</p>




<ol>



  <li> a name followed by a series of (name, type) tupes
  </li>



  <li> another struct
  </li>



</ol>




<pre>&gt;&gt;&gt; structA = pytos.util.nescDecls.nescStruct("myStruct", ("field1", variable), ("field2", array), ("field3", pointer))<br>&gt;&gt;&gt; structA<br>myStruct:<br>                uint8_t field1 &nbsp;: 15<br>            uint8_t[10] field2 &nbsp;: [15, 101, 15, 0, 15, 15, 15, 15, 15, 15]<br>           uint8_t[10]* field3 &nbsp;: ptr-&gt; [15, 101, 15, 0, 15, 15, 15, 15, 15, 15]<br><br>&gt;&gt;&gt; structA.field1 = 169<br>&gt;&gt;&gt; structA.field3.value[9] = 253<br>&gt;&gt;&gt; structA<br>myStruct:<br>                uint8_t field1 &nbsp;: 169<br>            uint8_t[10] field2 &nbsp;: [15, 101, 15, 0, 15, 15, 15, 15, 15, 253]<br>           uint8_t[10]* field3 &nbsp;: ptr-&gt; [15, 101, 15, 0, 15, 15, 15, 15, 15, 253] <br><br>&gt;&gt;&gt; structB = pytos.util.nescDecls.nescStruct(structA)<br>&gt;&gt;&gt; structB<br>myStruct:<br>                uint8_t field1 &nbsp;: 169<br>            uint8_t[10] field2 &nbsp;: [15, 101, 15, 0, 15, 15, 15, 15, 15, 253]<br>           uint8_t[10]* field3 &nbsp;: ptr-&gt; [15, 101, 15, 0, 15, 15, 15, 15, 15, 253]<br></pre>




<p>Again, notice that changing the fields in the struct change the
values of the original variables, because the struct fields are simply
references to the original variables.
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Messages"></a>
<h3><a class="mozTocH3" name="mozTocId776819"></a> Messages </h3>




<p>Any struct of type <i>myName</i> for which there is an enum
AM_MYNAME will be considered a TOS message with amType AM_MYNAME (this
is following the MIG convention that all messages have the amType
declared in such an enum). All such structs are automatically cast as
python TosMsg objects (described below) and made available through the
"msgs" field of nescApp.
</p>




<pre>&gt;&gt;&gt; print app.msgs<br><br>          211 : RpcCommandMsg<br>          212 : RpcResponseMsg<br></pre>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Sending_and_Receiving_Messages"></a>
<h2><a class="mozTocH2" name="mozTocId751391"></a>Sending and Receiving Messages</h2>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="The_Comm_Stack"></a>
<h3><a class="mozTocH3" name="mozTocId196094"></a>The Comm Stack</h3>




<p>Pytos provides a communication stack for sending a receiving
messages to/from the mote network. The comm stack has the following
functions:
</p>




<ul>



  <li> create comm stack instance to communicate w/network.  
  </li>



</ul>




<pre> import pytos.Comm as Comm<br> comm = Comm.Comm()  <br></pre>




<ul>



  <li> "connect or "disconnect" to a serial forwarder. These commands
can take any number of MOTECOM specs. Python will assume any
serialForwarders are already started and running independantly of this
python/TOS program.
  </li>



</ul>




<pre> comm.connect( "sf@localhost:9002") <br> comm.connect( "sf@localhost:9002", "sf@otherhost:9002", ... ) <br><br> comm.disconnect( "sf@localhost:9002") <br> comm.disconnect( "sf@localhost:9002", "sf@otherhost:9002", ... ) <br></pre>




<ul>



  <li> "send", "register" or "unregister" a message "msg." "msg" can
either be a python TosMsg object (described below) or a java class that
subclasses net.tinyos.message.Message classes, eg. a MIG-generated
message. All three commands can take any number of <i>optional</i>
MOTECOM specs to indicate which connections the function should operate
on. Sending no MOTECOM specs indicates that the function should operate
on all existing connections. If the desired MOTECOM specs are not
already connected to, the functions will first connect to them. 
    
    
    
    <ul>



      <li> On send, the parameter "addr" indicates what address should be put in the msg.  
      </li>



      <li> On "register" and "unregister", the parameter "queue" is the Comm.MessageQueue object (Described below)
      </li>



    
    
    
    </ul>




  </li>



</ul>




<pre> comm.send(addr, msg)<br> comm.send(addr, msg, "sf@localhost:9002") <br> comm.send(addr, msg, "sf@localhost:9002", "sf@otherhost:9002", ... )<br><br> comm.register(msg, queue)<br> comm.register(msg, queue, "sf@localhost:9002") <br> comm.register(msg, queue, "sf@localhost:9002", "sf@otherhost:9002", ... )<br><br> comm.unregister(msg, queue)<br> comm.unregister(msg, queue, "sf@localhost:9002") <br> comm.unregister(msg, queue, "sf@localhost:9002", "sf@otherhost:9002", ... )<br></pre>




<p>Each comm stack is a collection of connections, and therefore each
python program should create its own comm stack to avoid interference
with each other, even if they are running in the same python
environment (unless they explicitly want to share the same collection
of connections). A program can also create multiple comm stacks for
itself, if desired. The disavdantage of doing that is that each comm
stack opens a new socket to the running serial forwarder.
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="The_TosMsg_Object"></a>
<h3><a class="mozTocH3" name="mozTocId108865"></a>The TosMsg Object</h3>




<p>The nescDecls.TosMsg class is a subclass of the nescStruct object and has all of the same properties:
</p>




<ol>



  <li> it is correctly "packed" when imported directly from the nesc app
  </li>



  <li> it must be manually packed when created manually
  </li>



  <li> it has fields that hold its values
  </li>



  <li> it can be constructed from either a nescStruct or a name followed by types of field/type pairs 
  </li>



</ol>




<p>The TosMsg also has 2 more properties
</p>




<ol>



  <li> it has an amType, which must always be the first parameter in the constructor
  </li>



  <li> it can be converted to/from java Mig messages with the createMigMsg() and parseMigMsg() functions
  </li>



</ol>




<p>When the parseMigMsg() or setBytes() commands are being called on a
TosMsg and there are not enough bytes, it throws an error just like a
nescStruct would. However, if there are too many bytes and the last
field of the TosMsg is a nescArray of length 0, that array is expanded
to be as large as necessary to hold the extra data. This behavior is
designed to accomodate the TinyOS convention that nested packets are
held within the "data" field of the wrapper header, which is usually an
array of length 0. We will see an example of how this comes in handy in
the next section. <font color="red">Important note:</font> wrapper
headers used as such must be "packed", otherwise nesc may not report
the correct length of the packet and you may have errors.
</p>



<p><br>



The TosMsg is "hierarchical" because it has a parentMsg
field, which is used when TosMsgs are nested. <span style="font-weight: bold;">&nbsp; Note the the following example will not currently work as Drip and Drain are not currently implemented. &nbsp;</span>For example, if MyMsg is
received over the Drain routing layer, mymsg.parentMsg would point to
the original drain message, with the drain headers. If the drain
message were received over another routing layer,
myMsg.parentMsg.parentMsg would point to those headers. Any ancestor
message can be gotten through the myMsg.getParentMsg() function, which
takes either the ancestor message name or amType. The rpc function
response message is a good example of a Hierarcical TosMsg... try the
following on an rpc function response:
</p>




<pre>&gt;&gt;&gt; print r[0].parentMsg<br>TosMsg(am=212) RpcResponseMsg:<br>        uint16_t transactionID &nbsp;: 0<br>            uint16_t commandID &nbsp;: 9<br>        uint16_t sourceAddress &nbsp;: 0<br>            uint16_t errorCode &nbsp;: 0<br>               bool dataLength &nbsp;: 8<br>                  bool[8] data &nbsp;: [102, 0, 251, 0, 0, 0, 0, 0]<br><br>&gt;&gt;&gt; print r[0].parentMsg.parentMsg<br>TosMsg(am=4) DrainMsg:<br>                     bool type &nbsp;: 212<br>                      bool ttl &nbsp;: 15<br>               uint16_t source &nbsp;: 0<br>                 uint16_t dest &nbsp;: 126<br>                 bool[17] data &nbsp;: [0, 0, 9, 0, 0, 0, 0, 0, 8, 102, 0, 251, ...]<br></pre>




<p>We can see that the r[0] message is just a parsing of the
RpcResponseMsg.data bytes based on the commandID=9. The RpcResponseMsg
is just a parsing of the DrainMsg.data bytes based on the type=212.
</p>



<p><br>




The following examples show how to use and, if necessary, create your own TosMsg objects.
</p>




<pre>&gt;&gt;&gt; msgA = app.msgs.DripMsg<br>&gt;&gt;&gt; msgA.amType<br>3<br>&gt;&gt;&gt; msgB = nescDecls.TosMsg(104, structA)<br>&gt;&gt;&gt; msgB<br>TosMsg(am=104) myStruct:<br>                uint8_t field1 &nbsp;: 169<br>            uint8_t[10] field2 &nbsp;: [15, 15, 15, 0, 15, 15, 15, 15, 15, 254]<br>           uint8_t[10]* field3 &nbsp;: ptr-&gt; [15, 101, 15, 0, 15, 15, 15, 15, 15, 253]<br><br>&gt;&gt;&gt; migMsg = msgB.createMigMsg()<br>&gt;&gt;&gt; migMsg<br>Message &lt;BaseTOSMsg&gt;<br>  [addr=0xfa9]<br>  [type=0xf]<br>  [group=0xf]<br>  [length=0x0]<br>  [data=0xf 0xf 0xf 0xf 0xfe 0x0 0x0 0x0<br>&gt;&gt;&gt; msgC = nescDecls.nescStruct("myMsg", ("field1", variable), ("field2", array), ("field3", pointer))<br>&gt;&gt;&gt; msgC<br>myMsg:<br>                uint8_t field1 &nbsp;: 0<br>            uint8_t[10] field2 &nbsp;: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br>           uint8_t[10]* field3 &nbsp;: ptr-&gt; [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] <br><br>&gt;&gt;&gt; msgC = nescDecls.TosMsg(99, "myMsg", ("field1", variable), ("field2", array), ("field3", pointer))<br>&gt;&gt;&gt; msgC<br>TosMsg(am=99) myMsg:<br>                uint8_t field1 &nbsp;: 0<br>            uint8_t[10] field2 &nbsp;: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br>           uint8_t[10]* field3 &nbsp;: ptr-&gt; [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br><br>&gt;&gt;&gt; msgC.parseMigMsg(migMsg)<br>&gt;&gt;&gt; msgC<br>TosMsg(am=104) myMsg:<br>                uint8_t field1 &nbsp;: 169<br>            uint8_t[10] field2 &nbsp;: [15, 15, 15, 0, 15, 15, 15, 15, 15, 254]<br>           uint8_t[10]* field3 &nbsp;: ptr-&gt; [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]<br></pre>




<p>Of course, the pointer to the array in field3 is neither packed nor
unpacked, and therefore msgC.field3 does not have the same value as
msgB.field3.
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Message_Queues"></a>
<h3><a class="mozTocH3" name="mozTocId411367"></a>Message Queues</h3>




<p>A MessageQueue is used to receive messages and can buffer at most a
pre-specified number of messages. If the size of the queue grows too
large, the oldest messages are discarded. A MessageQueue can be
registered to receive a single type of message or multiple types of
messages, and then a thread can loop over the queue to get the
messages. Here is a simple example (warning: this will lock up your
python session if you don't actually have messages arriving):
</p>




<pre>&gt;&gt;&gt; import pytos.Comm as Comm<br>&gt;&gt;&gt; comm = Comm.Comm()<br>&gt;&gt;&gt; comm.connect('sf@locahost:9001')<br>&gt;&gt;&gt; msg = app.msgs.DrainMsg<br>&gt;&gt;&gt; msgQ = Comm.MessageQueue(5)<br>&gt;&gt;&gt; comm.register(msg, msgQ)<br>&gt;&gt;&gt; for i in range(100)&nbsp;: #receive 100 messages and print them<br>...   (addr, msg) = msgQ.get()<br>...   msg<br></pre>




<p>One can also use the threading package to start a new thread to
process the messages, as shown in the python/apps/Oscope.py file. When
the thread is set to be a "daemon" thread, it will run indefinitely
until all non-daemon threads (such as the main thread) are dead.
Example:
</p>




<pre>   ....main...<br>       msgThread = threading.Thread(target=self.processMessages)<br>       msgThread.setDaemon(True)<br>       msgThread.start()<br><br>   def processMessages(self)&nbsp;:<br>       while True&nbsp;:<br>           (addr,msg) = self.msgQueue.get()<br>           msg<br></pre>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Listen"></a>
<h2><a class="mozTocH2" name="mozTocId587582"></a> Listen </h2>




<p>As a simple example of what PyTOS can do, run the Listen.py tool,
which is equivalent to the C and Java Listen tools except that it
automatically parses the message payloads.
</p>




<pre>Listen.py telosb sf@localhost:9001<br></pre>




<p>This version of Listen allows the user to filter messages and set different levels of verbosity.  See a <a href="Pytos%20Screenshots.html" title="Pytos Screenshots"> Screenshots</a> for basic operation with the OscilloscopeRF application.
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="GUIs"></a>
<h2><a class="mozTocH2" name="mozTocId321912"></a> GUIs </h2>




<p>Gui material is not yet available for the TinyOS 2.x version.</p>


<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Advanced"></a>
<h2><a class="mozTocH2" name="mozTocId905230"></a> Advanced </h2>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Using_Mig_Messages_Directly"></a>
<h3><a class="mozTocH3" name="mozTocId686914"></a> Using Mig Messages Directly</h3>




<p>Mig objects can be used directly through the jpype.jimport module.&nbsp;For example:  
</p>




<pre>from jpype import JPackage<br>oscopeMsg = JPackage("net.tinyos.oscope").OscopeMsg()<br>comm.send(65535, oscopeMsg)<br></pre>




<p>Furthermore, mig objects can be received directly by using them in the register/unregister commands.  
</p>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Event_driven_programming"></a>
<h3><a class="mozTocH3" name="mozTocId216162"></a> Event driven programming</h3>




<p>Although the description of the comm stack API above indicates that
the register/unregister functions take the Comm.MessageQueue object as
a parameter, they can actually take any messageReceived function or
object which has that function. The messageReceived functions must take
two parameters: "addr" and "msg". This is a way to provide a callback
function for message handling, ie. to perform event-driven message
handling.
</p>



<p>In fact event-driven programming in general is possible in
python is a manner similar to that used in TinyOS when one uses the
pytos.util.Timer object. To create a timer that will first pause for <i>waitTime</i> seconds, and then every <i>period</i> seconds invoke the function <i>callbackFcn</i> exactly <i>numFirings</i> times, do this
</p>




<pre> t = Timer( callbackFcn , period , numFirings , waitTime )<br></pre>




<p>This timer is then started with
</p>




<pre> t.start()<br></pre>




<p>and may be cancelled at any time with
</p>




<pre> t.cancel()<br></pre>




<p>Additionally, at any point, a timer may be restarted with
</p>




<pre> t.start()<br></pre>




<p>There several reasons, however, not event-driven programming in python, particularly for message handling:
</p>




<ol>



  <li> event-based code needs to be made thread safe since it can be
called by multiple threads. Message handling code, for example, can be
called by multiple serialForwarder threads simultaneously.
  </li>



  <li> With event-driven message handling, the message handling is
being done on the data source's thread of control (e.g the
serialForwarder thread). This means that the data souce (such as the
serial forwarder) cannot process incoming packets while the user is
handling messages
  </li>



  <li>python errors that happen on the java SerialForwarder thread of control are difficult to handle
  </li>



  <li> It is easier to write for-loops using threads than as event-driven loops
  </li>



</ol>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Inheriting_from_Java_tools"></a>
<h3><a class="mozTocH3" name="mozTocId479200"></a> Inheriting from Java tools </h3>




<p>Java tools can be used from the python command line simply by importing them with the jpype.JPackage function.&nbsp;<span style="font-weight: bold;">Note the the following example will not currently work as Drip and Drain are not currently implemented.</span><span style="font-weight: bold;"></span> For example:
</p>




<pre>from jpype import JPackage<br>drain = JPackage("net.tinyos.drain").Drain()<br></pre>




<p>However, one may want to add python-specific functions to the drain
tool, such as the ability to register as a listener for a python TosMsg
object instead of a java mig object. To do this, we create a new python
object that <i>inherits</i> from the java object using the
pytos.util.JavaInheritor object. The Drain.py object is a good example:
it inherits from both Drain.java (which builds the drain tree) and
DrainConnector.java (which listens for messages on the drain tree), and
then adds new functions for registering as a listener of incoming
TosMsg objects. </p>



<p>To use the JavaInheritor object, follow three steps:
</p>




<ol>



  <li> create a new object that inherits from the JavaInheritor
  </li>



  <li> in the constructor of that object, instantiate the java objects you want it to inherit from
  </li>



  <li> call the JavaInheritor constructor with those objects.  
  </li>



</ol>




<p>To see how the python version of the Drain tool does it:
</p>




<pre>from jpype import JPackage  <br><br>drain = JPackage("net.tinyos.drain")<br><br>class Drain( JavaInheritor )&nbsp;: <br><br>    def __init__( self )&nbsp;:<br>        drainObj = drain.Drain(spAddr, moteIF)<br>        drainConnectorObj = drain.DrainConnector(spAddr, moteIF)<br>        JavaInheritor.__init__(self, (drainObj, drainConnectorObj) )<br><br></pre>




<p>Now, you can print an instance of the python Drain object to see what it inherits from the Java objects:
</p>




<pre>&gt;&gt;&gt; drain = pytos.util.Drain.Drain()<br>&gt;&gt;&gt; drain<br>Python object derived from java classes:<br>        net.tinyos.drain.Drain<br>        net.tinyos.drain.DrainConnector<br><br>The following java fields/methods are inherited:<br>        Drain.main()<br>        Drain.buildTree()<br>        Drain.sendTo()<br>        Drain.send()<br>        DrainConnector.registerListener()<br>        DrainConnector.deregisterListener()<br>        DrainConnector.setDebug()<br>        DrainConnector.messageReceived()<br></pre>




<div class="editsection" style="float: right; margin-left: 5px;"><br>



</div>



<a name="Adding_a_New_Layer_of_Dispatch"></a>
<h3><a class="mozTocH3" name="mozTocId811840"></a>Adding a New Layer of Dispatch</h3>




<p>This section is for pytos developers.  If you are just a user of pytos, skip this section.
</p>



<p>Unlike statically typed systems like MIG, the dynamic typing
system described above allows multiple levels of dispatch. A new layer
of message dispatch can be added by creating a new MessageListener
which unpacks an incoming message, removes the data field, creates a
new msg with the data, and passes the new message on to another
MessageListener. See pytos.tools.Drain.py or pytos.tools.Rpc.py for an
example.
</p>



<p>There are three steps to creating multiple layers of dispatch:
</p>




<ol>



  <li> All message listeners must subclass the Comm.MessageListener
class, which allows java hashing to work and therefore allows both the
java registerListener and deregisterListener commands to work
  </li>



  <li> When the migMsg is received and the TosMsg.parseMigMsg()
command is called at a low-level of dispatch, the migMsg data field
will be longer than the TosMsg data field (because the low-level of
dispatch does not yet know how to parse the rest of the data). The last
field of the TosMsg must therefore be a nescArray of length 0 and the
TosMsg will expand this field to be as long as necessary to hold all
unparsable bytes from the mig Msg (as described above). This data array
can then be used to construct the new packet for the next level of
dispatch. <font color="red">Important note:</font> wrapper headers
used as such must be "packed", otherwise nesc may not report the
correct length of the packet and you may have errors.
  </li>



  <li> the old message should be added as the parent of the new message
  </li>



</ol>




<p>An example from the Drain.py file is included here:
</p>




<pre>class DrainMsgPeeler( Comm.MessageListener )&nbsp;:<br><br>  def __init__(self, app, msg, callback)&nbsp;:<br>    self.drainMsg = nescDecls.TosMsg(app.enums.AM_DRAINMSG, app.types.DrainMsg)<br>    self.msg = msg<br>    Comm.MessageListener.__init__(self, callback )<br>    <br>  def messageReceived( self , addr , migMsg )&nbsp;:<br>    drainMsg = deepcopy(self.drainMsg)<br>    drainMsg.parseMigMsg(migMsg)      #drainMsg is expanded as necessary to hold extra data<br>    msg = deepcopy(self.msg)<br>    bytes = drainMsg.data.getBytes()  <br>    msg.setBytes( bytes )             # a new message is created from the extra data<br>    msg.parentMsg = drainMsg          #the old message is set as the new msg's parent<br>    self.callback( addr, msg )<br></pre>



</body>
</html>
